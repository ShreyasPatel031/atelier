{
  "api.agentConfig.lean.isReasoningModel": {
    "id": "api.agentConfig.lean.isReasoningModel",
    "name": "isReasoningModel",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/agentConfig.lean.ts",
    "relative_path": "api/agentConfig.lean.ts",
    "depends_on": [],
    "source_code": "isReasoningModel = (model: string): boolean => {\n  return model.includes('o3') || model.includes('o1') || model.includes('o4');\n}",
    "start_line": 56,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "model"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function isReasoningModel",
    "component_id": "api.agentConfig.lean.isReasoningModel"
  },
  "api.agentConfig.isReasoningModel": {
    "id": "api.agentConfig.isReasoningModel",
    "name": "isReasoningModel",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/agentConfig.ts",
    "relative_path": "api/agentConfig.ts",
    "depends_on": [],
    "source_code": "isReasoningModel = (model: string): boolean => {\n  return model.includes('o3') || model.includes('o1') || model.includes('o4');\n}",
    "start_line": 380,
    "end_line": 382,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "model"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function isReasoningModel",
    "component_id": "api.agentConfig.isReasoningModel"
  },
  "api.chat.handler": {
    "id": "api.chat.handler",
    "name": "handler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/chat.js",
    "relative_path": "api/chat.js",
    "depends_on": [
      "api.chat.getAllNodeIds",
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function handler(req, res) {\n  console.log('üöÄ Chat API called:', req.method, req.url);\n  \n  // Handle CORS preflight\n  if (req.method === 'OPTIONS') {\n    console.log('üì° Handling CORS preflight');\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n    res.status(200).end();\n    return;\n  }\n\n  if (req.method !== 'POST') {\n    console.log('‚ùå Method not allowed:', req.method);\n    res.status(405).json({ error: 'Method not allowed' });\n    return;\n  }\n\n  try {\n    console.log('üîë Checking API key...');\n    // Check for API key\n    if (!process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY === 'your-openai-api-key-here') {\n      console.log('‚ùå API key not configured');\n      res.status(500).json({ \n        error: 'OpenAI API key not configured',\n        message: 'Please set your OpenAI API key in the .env file'\n      });\n      return;\n    }\n\n    console.log('‚úÖ API key found');\n    const { messages, currentGraph, images } = req.body;\n    console.log('üì® Received messages:', messages);\n    console.log('üìä Received current graph:', currentGraph ? `${currentGraph.children?.length || 0} nodes` : 'none');\n    console.log('üì∏ Received images:', images ? `${images.length} images` : 'none');\n\n    if (!messages || !Array.isArray(messages)) {\n      console.log('‚ùå Invalid messages format');\n      res.status(400).json({ error: 'Messages array is required' });\n      return;\n    }\n\n    console.log('ü§ñ Initializing OpenAI client');\n    // Initialize OpenAI client\n    const openai = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n    });\n\n    // Helper function to get all node IDs recursively\n    const getAllNodeIds = (node) => {\n      const ids = [node.id];\n      if (node.children) {\n        node.children.forEach((child) => {\n          ids.push(...getAllNodeIds(child));\n        });\n      }\n      return ids;\n    };\n\n    // Build current graph state description\n    const graphStateDescription = currentGraph ? `\nCURRENT ARCHITECTURE STATE:\n${currentGraph.children?.length ? \n  `EXISTING NODES: ${getAllNodeIds(currentGraph).filter(id => id !== 'root').join(', ')}\nEXISTING EDGES: ${currentGraph.edges?.length ? currentGraph.edges.map((edge) => `${edge.source} ‚Üí ${edge.target}`).join(', ') : 'none'}\n\nüìä Architecture Summary: ${currentGraph.children.length} top-level nodes, ${currentGraph.edges?.length || 0} edges\n\nFULL GRAPH JSON:\n${JSON.stringify(currentGraph, null, 2)}` \n  : 'EXISTING NODES: none, EXISTING EDGES: none'\n}` : 'CURRENT ARCHITECTURE STATE: Empty (no architecture created yet)';\n\n    console.log('üì° Setting up streaming response');\n    // Set up streaming response\n    res.setHeader('Content-Type', 'text/plain; charset=utf-8');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n\n    console.log('üîÑ Creating chat completion...');\n    \n    // Process messages to include images if provided\n    const processedMessages = messages.map(msg => {\n      // Check if this message has images (either from the message itself or from the global images array)\n      const messageImages = msg.images || (msg.role === 'user' && images ? images : []);\n      \n    console.log('üîç Processing message:', msg.role, 'has images:', !!msg.images, 'global images:', images?.length || 0);\n    console.log('üîç MessageImages:', messageImages?.length || 0);\n      \n      if (messageImages && messageImages.length > 0) {\n        // Convert images to OpenAI format\n        const imageContent = messageImages.map(imageDataUrl => ({\n          type: \"image_url\",\n          image_url: {\n            url: imageDataUrl\n          }\n        }));\n        \n        console.log('üì∏ Created image content for message:', imageContent.length, 'images');\n        \n        return {\n          role: msg.role,\n          content: [\n            { type: \"text\", text: msg.content },\n            ...imageContent\n          ]\n        };\n      }\n      return msg;\n    });\n    \n    // Use gpt-4.1 which supports images\n    const modelToUse = 'gpt-4.1';\n    console.log('ü§ñ Using model:', modelToUse);\n    \n    // Create chat completion with streaming and tools\n    const stream = await openai.chat.completions.create({\n      model: modelToUse,\n      messages: [\n        {\n          role: 'system',\n          content: `You are a helpful AI assistant specialized in architecture design and technical discussions. Keep responses concise and focused. Avoid long lists of questions - ask 1-2 key questions at a time. Use markdown formatting for better readability.\n\n${graphStateDescription}\n\nWhen discussing the current architecture, you can reference the existing nodes and edges from the FULL GRAPH JSON above. If the user asks about modifications or improvements, you can suggest specific changes to the current architecture by referencing the exact node IDs and structure shown in the JSON.\n\n${images && images.length > 0 ? `IMPORTANT: The user has provided ${images.length} image(s) showing architecture diagrams. Analyze these images carefully and provide insights about the architecture shown, suggest improvements, or help replicate similar patterns.` : ''}`\n        },\n        ...processedMessages\n      ],\n      stream: true,\n      temperature: 0.7,\n      max_tokens: 1024,\n      tools: [\n        {\n          type: \"function\",\n          function: {\n            name: \"create_architecture_diagram\",\n            description: \"Create an architecture diagram based on the user's requirements and conversation summary\",\n            parameters: {\n              type: \"object\",\n              properties: {\n                requirements_summary: {\n                  type: \"string\",\n                  description: \"A clear summary of the user's architecture requirements based on the conversation\"\n                },\n                architecture_type: {\n                  type: \"string\",\n                  description: \"The type of architecture being requested (e.g., microservices, serverless, monolith, etc.)\"\n                }\n              },\n              required: [\"requirements_summary\", \"architecture_type\"]\n            }\n          }\n        }\n      ],\n      tool_choice: \"auto\"\n    });\n\n    console.log('üì¶ Starting to stream response...');\n    let toolCallDetected = false;\n    let toolCallData = null;\n    let accumulatedArguments = '';\n    \n    // Stream the response\n    for await (const chunk of stream) {\n      const data = JSON.stringify(chunk);\n      console.log('üì§ Streaming chunk:', data);\n      \n      // Check if this chunk contains a tool call\n      if (chunk.choices?.[0]?.delta?.tool_calls) {\n        toolCallDetected = true;\n        console.log('üîß Tool call detected in chunk');\n        console.log('üîç Tool call chunk:', JSON.stringify(chunk.choices[0].delta.tool_calls, null, 2));\n        \n        // If we have tool call data, handle it\n        if (chunk.choices[0].delta.tool_calls[0]?.function?.name === 'create_architecture_diagram') {\n          toolCallData = chunk.choices[0].delta.tool_calls[0];\n          console.log('üèóÔ∏è Architecture diagram tool call detected');\n          console.log('üîç Tool call data:', JSON.stringify(toolCallData, null, 2));\n        }\n        \n        // Accumulate arguments if they exist\n        if (chunk.choices[0].delta.tool_calls[0]?.function?.arguments) {\n          accumulatedArguments += chunk.choices[0].delta.tool_calls[0].function.arguments;\n          console.log('üìù Accumulated arguments so far:', accumulatedArguments);\n        }\n      }\n      \n      res.write(`data: ${data}\\n\\n`);\n    }\n\n    // If a tool call was detected, handle it\n    if (toolCallDetected && toolCallData && accumulatedArguments) {\n      console.log('üõ†Ô∏è Processing tool call...');\n      console.log('üîç Tool call data:', JSON.stringify(toolCallData, null, 2));\n      console.log('üìù Final accumulated arguments:', accumulatedArguments);\n      \n      try {\n        // Parse the accumulated tool call arguments\n        console.log('üìù Raw arguments string:', accumulatedArguments);\n        const args = JSON.parse(accumulatedArguments);\n        console.log('üìã Parsed tool call arguments:', args);\n        \n        // Validate required fields\n        if (!args.requirements_summary || !args.architecture_type) {\n          throw new Error(`Missing required fields. Got: ${JSON.stringify(args)}`);\n        }\n        \n        // Send a special message indicating diagram creation\n        const diagramMessage = {\n          type: \"diagram_creation\",\n          message: `Creating architecture diagram for: ${args.architecture_type}`,\n          requirements: args.requirements_summary\n        };\n        \n        console.log('üì§ Sending diagram creation message:', diagramMessage);\n        res.write(`data: ${JSON.stringify(diagramMessage)}\\n\\n`);\n        \n        // Trigger the diagram creation on the frontend\n        const triggerMessage = {\n          type: \"trigger_diagram\",\n          requirements: args.requirements_summary,\n          architecture_type: args.architecture_type\n        };\n        \n        console.log('üöÄ Sending trigger message:', triggerMessage);\n        res.write(`data: ${JSON.stringify(triggerMessage)}\\n\\n`);\n        \n        console.log('‚úÖ Diagram creation triggered successfully');\n        \n      } catch (error) {\n        console.error('‚ùå Error processing tool call:', error);\n        console.error('‚ùå Error details:', error.message);\n        console.error('‚ùå Tool call data:', JSON.stringify(toolCallData, null, 2));\n        console.error('‚ùå Accumulated arguments:', accumulatedArguments);\n        \n        res.write(`data: ${JSON.stringify({\n          type: \"error\",\n          message: `Failed to process diagram creation request: ${error.message}`\n        })}\\n\\n`);\n      }\n    } else {\n      console.log('‚ÑπÔ∏è No tool call detected or tool call data missing');\n      console.log('üîç toolCallDetected:', toolCallDetected);\n      console.log('üîç toolCallData:', toolCallData);\n      console.log('üîç accumulatedArguments:', accumulatedArguments);\n    }\n\n    console.log('‚úÖ Stream completed, sending [DONE]');\n    // Send completion signal\n    res.write('data: [DONE]\\n\\n');\n    res.end();\n\n  } catch (error) {\n    console.error('Chat API error:', error);\n    \n    if (error.code === 'insufficient_quota') {\n      res.status(402).json({ \n        error: 'Insufficient quota',\n        message: 'OpenAI API quota exceeded. Please check your billing.'\n      });\n    } else if (error.code === 'invalid_api_key') {\n      res.status(401).json({ \n        error: 'Invalid API key',\n        message: 'Please check your OpenAI API key in the .env file'\n      });\n    } else {\n      res.status(500).json({ \n        error: 'Internal server error',\n        message: error.message || 'An unexpected error occurred'\n      });\n    }\n  }\n}",
    "start_line": 3,
    "end_line": 279,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "req",
      "res"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handler",
    "component_id": "api.chat.handler"
  },
  "api.chat.getAllNodeIds": {
    "id": "api.chat.getAllNodeIds",
    "name": "getAllNodeIds",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/chat.js",
    "relative_path": "api/chat.js",
    "depends_on": [
      "api.chat.getAllNodeIds"
    ],
    "source_code": "getAllNodeIds = (node) => {\n      const ids = [node.id];\n      if (node.children) {\n        node.children.forEach((child) => {\n          ids.push(...getAllNodeIds(child));\n        });\n      }\n      return ids;\n    }",
    "start_line": 53,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getAllNodeIds",
    "component_id": "api.chat.getAllNodeIds"
  },
  "api.embed.handler": {
    "id": "api.embed.handler",
    "name": "handler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/embed.ts",
    "relative_path": "api/embed.ts",
    "depends_on": [
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function handler(req: any, res: any) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Only POST allowed' });\n  }\n\n  try {\n    const { text } = req.body;\n\n    if (!text) {\n      return res.status(400).json({ error: 'Missing text parameter' });\n    }\n\n    if (!process.env.OPENAI_API_KEY) {\n      console.error('‚ùå OPENAI_API_KEY not found');\n      return res.status(500).json({ error: 'Missing OPENAI_API_KEY' });\n    }\n\n    const openai = new OpenAI({ \n      apiKey: process.env.OPENAI_API_KEY?.trim()\n    });\n\n    const response = await openai.embeddings.create({\n      model: 'text-embedding-3-small',\n      input: text\n    });\n\n    const embedding = response.data[0].embedding;\n    \n    return res.json({ embedding });\n  } catch (err) {\n    console.error('[embed] API error:', err);\n    return res.status(500).json({ \n      error: 'Embedding failed',\n      details: err instanceof Error ? err.message : String(err)\n    });\n  }\n}",
    "start_line": 3,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "req",
      "res"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handler",
    "component_id": "api.embed.handler"
  },
  "api.generateChatName.ChatNameRequest": {
    "id": "api.generateChatName.ChatNameRequest",
    "name": "ChatNameRequest",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generateChatName.ts",
    "relative_path": "api/generateChatName.ts",
    "depends_on": [],
    "source_code": "interface ChatNameRequest {\n  architecture?: any;           // ELK graph structure\n  userPrompt?: string;         // Original user request\n  nodeCount?: number;          // Number of nodes in architecture\n  edgeCount?: number;          // Number of edges in architecture\n  services?: string[];         // List of service names\n}",
    "start_line": 7,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChatNameRequest",
    "component_id": "api.generateChatName.ChatNameRequest"
  },
  "api.generateChatName.handler": {
    "id": "api.generateChatName.handler",
    "name": "handler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generateChatName.ts",
    "relative_path": "api/generateChatName.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "api.generateChatName.extractArchitectureInfo",
      "api.generateChatName.ChatNameRequest",
      "api.generateChatName.buildNamingContext",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function handler(req: any, res: any) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ message: 'Method Not Allowed' });\n  }\n\n  const { architecture, userPrompt, nodeCount, edgeCount, services }: ChatNameRequest = req.body;\n\n  if (!userPrompt || userPrompt.trim() === '') {\n    return res.status(400).json({ error: 'User prompt is required for chat name generation' });\n  }\n\n  try {\n    // Extract key information for naming\n    const architectureInfo = extractArchitectureInfo(architecture);\n    \n    // Build context for AI naming\n    const context = buildNamingContext({\n      userPrompt,\n      nodeCount,\n      edgeCount,\n      services: services || architectureInfo.services,\n      platforms: architectureInfo.platforms,\n      patterns: architectureInfo.patterns\n    });\n\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-3.5-turbo\",\n      messages: [\n        { \n          role: \"system\", \n          content: \"You are a technical architect naming system architectures. Given a user's request and the actual architecture components, create a concise, descriptive name that captures BOTH the user's intent AND the technical implementation. The name should be 2-4 words, technical but readable. Avoid generic terms like 'Chat', 'Session', 'URL', 'Web', 'Link', or 'Based'. Focus on what the architecture DOES and what platforms/patterns it uses. Examples: 'GCP Microservices API', 'Multi-Cloud Data Pipeline', 'Serverless Payment Gateway'. Return ONLY the name without quotes, brackets, or formatting.\"\n        },\n        { \n          role: \"user\", \n          content: `Create a concise name for this architecture:\\n\\n${context}\\n\\nName should reflect both the user's goal and the actual technical components used.`\n        }\n      ],\n      max_tokens: 20,\n      temperature: 0.5,\n    });\n\n    const rawName = completion.choices[0].message.content?.trim() || '';\n    console.log('Raw name from OpenAI:', JSON.stringify(rawName));\n    // Clean the name: remove quotes, numbering, and take only the first line\n    let generatedName = rawName.replace(/^[\"']+|[\"']+$/g, '').replace(/^[\"']+|[\"']+$/g, '');\n    // If it's a numbered list, take only the first item\n    if (generatedName.includes('\\n')) {\n      generatedName = generatedName.split('\\n')[0];\n    }\n    // Remove numbering like \"1. \" or \"2. \"\n    generatedName = generatedName.replace(/^\\d+\\.\\s*/, '');\n    console.log('Cleaned name:', JSON.stringify(generatedName));\n\n    if (generatedName) {\n      res.status(200).json({ \n        name: generatedName,\n        context: context // For debugging\n      });\n    } else {\n      throw new Error(\"No name generated by OpenAI.\");\n    }\n  } catch (error) {\n    console.error('Error generating chat name with OpenAI:', error);\n    \n    // NO FALLBACKS - throw the error so the frontend knows it failed\n    throw error;\n  }\n}",
    "start_line": 15,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "req",
      "res"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handler",
    "component_id": "api.generateChatName.handler"
  },
  "api.generateChatName.extractArchitectureInfo": {
    "id": "api.generateChatName.extractArchitectureInfo",
    "name": "extractArchitectureInfo",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generateChatName.ts",
    "relative_path": "api/generateChatName.ts",
    "depends_on": [],
    "source_code": "function extractArchitectureInfo(architecture: any) {\n  const services: string[] = [];\n  const platforms: string[] = [];\n  const patterns: string[] = [];\n\n  if (!architecture) {\n    return { services, platforms, patterns };\n  }\n\n  // Recursively extract node information\n  function extractFromNodes(nodes: any[]) {\n    if (!Array.isArray(nodes)) return;\n    \n    for (const node of nodes) {\n      if (node.id && node.data?.label) {\n        const label = node.data.label.toLowerCase();\n        const id = node.id.toLowerCase();\n        \n        // Platform detection\n        if (label.includes('gcp') || id.includes('gcp')) platforms.push('GCP');\n        if (label.includes('aws') || id.includes('aws')) platforms.push('AWS');\n        if (label.includes('azure') || id.includes('azure')) platforms.push('Azure');\n        if (label.includes('kubernetes') || id.includes('k8s') || id.includes('gke')) platforms.push('Kubernetes');\n        \n        // Service types\n        if (id.includes('api') || label.includes('api')) patterns.push('API');\n        if (id.includes('db') || id.includes('sql') || label.includes('database')) patterns.push('Database');\n        if (id.includes('storage') || label.includes('storage')) patterns.push('Storage');\n        if (id.includes('ml') || id.includes('ai') || label.includes('vertex')) patterns.push('AI/ML');\n        if (id.includes('microservice') || label.includes('service')) patterns.push('Microservices');\n        if (id.includes('serverless') || id.includes('function') || id.includes('lambda')) patterns.push('Serverless');\n        \n        // Extract service names\n        services.push(node.data.label);\n      }\n      \n      // Recurse into children\n      if (node.children) {\n        extractFromNodes(node.children);\n      }\n    }\n  }\n\n  extractFromNodes(architecture.children || []);\n  \n  return {\n    services: [...new Set(services)].slice(0, 5), // Limit to 5 unique services\n    platforms: [...new Set(platforms)],\n    patterns: [...new Set(patterns)]\n  };\n}",
    "start_line": 87,
    "end_line": 137,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architecture"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractArchitectureInfo",
    "component_id": "api.generateChatName.extractArchitectureInfo"
  },
  "api.generateChatName.buildNamingContext": {
    "id": "api.generateChatName.buildNamingContext",
    "name": "buildNamingContext",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generateChatName.ts",
    "relative_path": "api/generateChatName.ts",
    "depends_on": [],
    "source_code": "function buildNamingContext(data: {\n  userPrompt?: string;\n  nodeCount?: number;\n  edgeCount?: number;\n  services?: string[];\n  platforms?: string[];\n  patterns?: string[];\n}) {\n  const parts = [];\n  \n  if (data.userPrompt) {\n    parts.push(`User request: \"${data.userPrompt}\"`);\n  }\n  \n  if (data.platforms?.length) {\n    parts.push(`Platforms: ${data.platforms.join(', ')}`);\n  }\n  \n  if (data.patterns?.length) {\n    parts.push(`Patterns: ${data.patterns.join(', ')}`);\n  }\n  \n  if (data.nodeCount && data.edgeCount) {\n    parts.push(`Architecture: ${data.nodeCount} components, ${data.edgeCount} connections`);\n  }\n  \n  if (data.services?.length) {\n    const topServices = data.services.slice(0, 3);\n    parts.push(`Key services: ${topServices.join(', ')}`);\n  }\n  \n  return parts.join('\\n');\n}",
    "start_line": 142,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function buildNamingContext",
    "component_id": "api.generateChatName.buildNamingContext"
  },
  "api.generateName.handler": {
    "id": "api.generateName.handler",
    "name": "handler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generateName.ts",
    "relative_path": "api/generateName.ts",
    "depends_on": [
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function handler(req: any, res: any) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { description = \"architecture\" } = req.body;\n\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-3.5-turbo\",\n      messages: [\n        {\n          role: \"system\",\n          content: \"You are a naming assistant. Generate short, professional names for cloud architectures. Keep names to 2-4 words maximum. Be creative but professional. Examples: 'Cloud Gateway Hub', 'Serverless Data Pipeline', 'Multi-Region Setup', 'API Gateway Architecture'.\"\n        },\n        {\n          role: \"user\",\n          content: `Generate a name for a new ${description} architecture. Just return the name, nothing else.`\n        }\n      ],\n      max_tokens: 20,\n      temperature: 0.8,\n    });\n\n    const generatedName = completion.choices[0]?.message?.content?.trim() || 'New Architecture';\n\n    res.status(200).json({ name: generatedName });\n  } catch (error) {\n    console.error('Error generating name:', error);\n    \n    // Fallback names if OpenAI fails\n    const fallbackNames = [\n      'Cloud Architecture',\n      'Serverless Setup',\n      'Microservices Platform',\n      'API Gateway Hub',\n      'Data Pipeline',\n      'Container Platform',\n      'Event-Driven System',\n      'Hybrid Cloud Setup'\n    ];\n    \n    const randomName = fallbackNames[Math.floor(Math.random() * fallbackNames.length)];\n    \n    res.status(200).json({ name: randomName });\n  }\n}",
    "start_line": 7,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "req",
      "res"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handler",
    "component_id": "api.generateName.handler"
  },
  "api.generated.dynamicAgentResources.DynamicAgentResources": {
    "id": "api.generated.dynamicAgentResources.DynamicAgentResources",
    "name": "DynamicAgentResources",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generated/dynamicAgentResources.ts",
    "relative_path": "api/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "interface DynamicAgentResources {\n  groupIcons: {\n    all: string[];\n    aws: string[];\n    gcp: string[];\n    azure: string[];\n  };\n  regularIcons: {\n    aws: string[];\n    gcp: string[];\n    azure: string[];\n    generic: string[];\n  };\n  totalCounts: {\n    groupIcons: number;\n    regularIcons: number;\n  };\n}",
    "start_line": 4,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DynamicAgentResources",
    "component_id": "api.generated.dynamicAgentResources.DynamicAgentResources"
  },
  "api.generated.dynamicAgentResources.getGroupIconsByProvider": {
    "id": "api.generated.dynamicAgentResources.getGroupIconsByProvider",
    "name": "getGroupIconsByProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generated/dynamicAgentResources.ts",
    "relative_path": "api/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function getGroupIconsByProvider(provider: 'aws' | 'gcp' | 'azure'): string[] {\n  return dynamicAgentResources.groupIcons[provider];\n}",
    "start_line": 1818,
    "end_line": 1820,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getGroupIconsByProvider",
    "component_id": "api.generated.dynamicAgentResources.getGroupIconsByProvider"
  },
  "api.generated.dynamicAgentResources.getRegularIconsByProvider": {
    "id": "api.generated.dynamicAgentResources.getRegularIconsByProvider",
    "name": "getRegularIconsByProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generated/dynamicAgentResources.ts",
    "relative_path": "api/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function getRegularIconsByProvider(provider: 'aws' | 'gcp' | 'azure' | 'generic'): string[] {\n  return dynamicAgentResources.regularIcons[provider];\n}",
    "start_line": 1822,
    "end_line": 1824,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getRegularIconsByProvider",
    "component_id": "api.generated.dynamicAgentResources.getRegularIconsByProvider"
  },
  "api.generated.dynamicAgentResources.isGroupIcon": {
    "id": "api.generated.dynamicAgentResources.isGroupIcon",
    "name": "isGroupIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generated/dynamicAgentResources.ts",
    "relative_path": "api/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function isGroupIcon(iconName: string): boolean {\n  return availableGroupIcons.includes(iconName);\n}",
    "start_line": 1826,
    "end_line": 1828,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isGroupIcon",
    "component_id": "api.generated.dynamicAgentResources.isGroupIcon"
  },
  "api.generated.dynamicAgentResources.isRegularIcon": {
    "id": "api.generated.dynamicAgentResources.isRegularIcon",
    "name": "isRegularIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generated/dynamicAgentResources.ts",
    "relative_path": "api/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function isRegularIcon(iconName: string): boolean {\n  return Object.values(availableRegularIcons).flat().includes(iconName);\n}",
    "start_line": 1830,
    "end_line": 1832,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isRegularIcon",
    "component_id": "api.generated.dynamicAgentResources.isRegularIcon"
  },
  "api.generated.dynamicAgentResources.getIconProvider": {
    "id": "api.generated.dynamicAgentResources.getIconProvider",
    "name": "getIconProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/generated/dynamicAgentResources.ts",
    "relative_path": "api/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function getIconProvider(iconName: string): 'aws' | 'gcp' | 'azure' | null {\n  if (iconName.startsWith('aws_')) return 'aws';\n  if (iconName.startsWith('gcp_')) return 'gcp';\n  if (iconName.startsWith('azure_')) return 'azure';\n  return null;\n}",
    "start_line": 1834,
    "end_line": 1839,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getIconProvider",
    "component_id": "api.generated.dynamicAgentResources.getIconProvider"
  },
  "api.simple-agent.handler": {
    "id": "api.simple-agent.handler",
    "name": "handler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/simple-agent.ts",
    "relative_path": "api/simple-agent.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function handler(req: any, res: any) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  const { \n    message, \n    conversationHistory = [], \n    currentGraph, \n    referenceArchitecture = \"\",\n    toolOutputs = null,\n    previousResponseId = null,\n    images = [] // Add images parameter\n  } = req.body;\n  \n  // DEBUG: Log images received\n  console.log('üì∏ DEBUG: simple-agent received images:', images?.length || 0);\n  if (images && images.length > 0) {\n    console.log('üì∏ DEBUG: Image data received:', images.map((img: any) => img.substring(0, 50) + '...'));\n  }\n  \n  // Handle two modes: initial conversation start OR tool output continuation\n  const isToolOutputContinuation = toolOutputs && previousResponseId;\n  \n  if (!isToolOutputContinuation && !message) {\n    return res.status(400).json({ error: 'Message required for new conversation' });\n  }\n\n  // Agent mode determined\n  if (!isToolOutputContinuation) {\n    console.log('ü§ñ AGENT: Received user message:', message);\n    console.log('üîÑ AGENT: Conversation history length:', conversationHistory.length);\n    console.log('üìä AGENT: Current graph state:', currentGraph ? `${currentGraph.children?.length || 0} nodes` : 'empty');\n    console.log('üèóÔ∏è AGENT: Reference architecture received:', referenceArchitecture ? referenceArchitecture.substring(0, 100) + '...' : 'NONE');\n  } else {\n    console.log('üîß AGENT: Tool output continuation with response ID:', previousResponseId);\n    console.log('üîß AGENT: Tool outputs count:', toolOutputs?.length || 0);\n  }\n\n  const openai = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n    timeout: timeoutConfigs.requestTimeout,\n  });\n\n  try {\n    // Helper function to get all node IDs recursively\n    const getAllNodeIds = (node: any): string[] => {\n      const ids = [node.id];\n      if (node.children) {\n        node.children.forEach((child: any) => {\n          ids.push(...getAllNodeIds(child));\n        });\n      }\n      return ids;\n    };\n\n    // Build current graph state description - MINIMAL\n    const graphStateDescription = currentGraph ? `\nCURRENT GRAPH: ${currentGraph.children?.length || 0} nodes, ${currentGraph.edges?.length || 0} edges\n${currentGraph.children?.length ? `EXISTING: ${getAllNodeIds(currentGraph).filter(id => id !== 'root').slice(0, 10).join(', ')}${getAllNodeIds(currentGraph).length > 10 ? '...' : ''}` : 'Empty graph'}` : 'Empty graph';\n\n    // LEAN system prompt - no massive examples or icon lists\n    const baseMessages = [\n      {\n        role: 'system',\n        content: `${leanSystemPrompt}\n\n${graphStateDescription}\n\nTurn: ${conversationHistory.length + 1}/3${conversationHistory.length >= 2 ? ' (FINAL)' : ''}\n\n${referenceArchitecture ? `Reference: ${referenceArchitecture.substring(0, 300)}...` : ''}`\n      },\n      ...conversationHistory,\n      {\n        role: 'user',\n        content: message\n      }\n    ];\n\n    let conversationInput: any[];\n\n    if (isToolOutputContinuation) {\n      // Tool output continuation mode\n      console.log('üîß AGENT: Preparing tool output continuation...');\n      conversationInput = toolOutputs;\n    } else {\n      // Initial conversation mode\n      conversationInput = baseMessages;\n    }\n\n    // OpenAI Responses API call\n    console.log('üß† AGENT: Calling OpenAI Responses API for turn', conversationHistory.length + 1);\n    if (!isToolOutputContinuation) {\n      console.log('üìù AGENT: System prompt length:', conversationInput[0].content.length, 'chars');\n      console.log('üìù AGENT: System prompt preview:', conversationInput[0].content.substring(0, 200) + '...');\n    }\n\n    // Build the API request - MINIMAL TOOL DEFINITION\n    const apiRequest: any = {\n      model: modelConfigs.reasoning.model,\n      input: conversationInput,\n      tools: [\n        {\n          type: 'function',\n          name: 'batch_update',\n          description: 'Execute graph operations. Format: {operations: [{name: \"add_node\", nodename: \"id\", parentId: \"parent\", data: {label: \"Name\", icon: \"icon_name\"}}, {name: \"group_nodes\", nodeIds: [\"id1\", \"id2\"], parentId: \"parent\", groupId: \"group\", groupIconName: \"group_icon\"}, {name: \"add_edge\", edgeId: \"e1\", sourceId: \"source\", targetId: \"target\", label: \"action\"}]}',\n          strict: false,\n          parameters: {\n            type: 'object',\n            properties: {\n              operations: {\n                type: 'array',\n                description: 'Array of operations to execute',\n                items: {\n                  type: 'object',\n                  properties: {\n                    name: {\n                      type: 'string',\n                      enum: ['add_node', 'delete_node', 'move_node', 'add_edge', 'delete_edge', 'group_nodes', 'remove_group']\n                    },\n                    nodename: { type: 'string' },\n                    parentId: { type: 'string' },\n                    nodeId: { type: 'string' },\n                    newParentId: { type: 'string' },\n                    edgeId: { type: 'string' },\n                    sourceId: { type: 'string' },\n                    targetId: { type: 'string' },\n                    nodeIds: { type: 'array', items: { type: 'string' } },\n                    groupId: { type: 'string' },\n                    groupIconName: { type: 'string' },\n                    data: { type: 'object' },\n                    label: { type: 'string' }\n                  },\n                  required: ['name']\n                }\n              }\n            },\n            required: ['operations']\n          }\n        }\n      ],\n      temperature: modelConfigs.reasoning.temperature,\n      top_p: modelConfigs.reasoning.top_p,\n      max_output_tokens: modelConfigs.reasoning.max_tokens,\n      tool_choice: modelConfigs.reasoning.tool_choice,\n      parallel_tool_calls: modelConfigs.reasoning.parallel_tool_calls\n    };\n\n\n    // Add previous response ID for continuation\n    if (isToolOutputContinuation && previousResponseId) {\n      apiRequest.previous_response_id = previousResponseId;\n    }\n\n    console.log('‚úÖ AGENT: OpenAI response received');\n    const response = await openai.responses.create(apiRequest);\n    \n    console.log('üîç AGENT: Full response:', JSON.stringify(response, null, 2));\n    console.log('üîç AGENT: response.id:', response.id);\n    console.log('üîç AGENT: response.response_id:', (response as any).response_id);\n    console.log('üîç AGENT: response.conversation_id:', (response as any).conversation_id);\n\n    // Extract response ID - try multiple possible fields\n    const responseId = response.id || (response as any).response_id || (response as any).conversation_id || `temp_${Date.now()}`;\n    console.log('üîç AGENT: Final extracted response ID:', responseId);\n    console.log('üîç AGENT: responseId type:', typeof responseId);\n\n    // Parse function calls from response\n    const functionCalls = response.output?.filter((item: any) => item.type === 'function_call') || [];\n    console.log('üîß AGENT: Found', functionCalls.length, 'function calls to execute');\n\n    if (functionCalls.length === 0) {\n      console.log('‚ö†Ô∏è AGENT: No function calls found in response');\n      return res.json({\n        success: true,\n        functionCalls: [],\n        count: 0,\n        turnNumber: conversationHistory.length + 1,\n        isLikelyFinalTurn: true,\n        continueMessage: \"Architecture complete\",\n        responseId: responseId,\n        hasMoreWork: false\n      });\n    }\n\n    // Process and validate function calls\n    const parsedCalls = functionCalls.map((call: any, index: number) => {\n      console.log(`üîç AGENT: Raw call ${index + 1} - name: \"${call.name}\"`);\n      console.log(`üîç AGENT: Raw arguments:`, call.arguments);\n\n      let parsedArgs;\n      try {\n        parsedArgs = typeof call.arguments === 'string' ? JSON.parse(call.arguments) : call.arguments;\n      } catch (error) {\n        console.error(`‚ùå AGENT: Failed to parse arguments for call ${index + 1}:`, error);\n        throw new Error(`Invalid function call arguments: ${error.message}`);\n      }\n\n      console.log(`üìû AGENT: Tool ${index + 1}/${functionCalls.length} - ${call.name}:`, parsedArgs);\n\n      if (parsedArgs.operations && parsedArgs.operations.length > 0) {\n        console.log('üß™ AGENT: First operation parameter keys:', Object.keys(parsedArgs.operations[0]));\n        console.log('üß™ AGENT: First operation sample:', parsedArgs.operations[0]);\n      }\n\n      return {\n        name: call.name,\n        arguments: parsedArgs,\n        call_id: call.call_id || call.id || `call_${Date.now()}_${index}`\n      };\n    });\n\n    console.log('üöÄ AGENT: Sending tool calls to frontend for execution');\n\n    // Determine if this is likely the final turn\n    const currentTurn = conversationHistory.length + 1;\n    const isLikelyFinalTurn = currentTurn >= 3; // Max 3 turns\n\n    console.log('üìä AGENT: Current turn:', currentTurn, 'Likely final:', isLikelyFinalTurn);\n\n    // Check if we have more work to do\n    console.log('üîç AGENT: parsedCalls length:', parsedCalls.length);\n    console.log('üîç AGENT: parsedCalls type:', typeof parsedCalls);\n    console.log('üîç AGENT: parsedCalls array?:', Array.isArray(parsedCalls));\n    \n    const hasMoreWork = parsedCalls.length > 0;\n    console.log('üîç AGENT: hasMoreWork calculation:', parsedCalls.length, '> 0 =', hasMoreWork);\n\n    const finalResponse = {\n      success: true,\n      functionCalls: parsedCalls,\n      count: parsedCalls.length,\n      turnNumber: currentTurn,\n      isLikelyFinalTurn: isLikelyFinalTurn,\n      continueMessage: isLikelyFinalTurn ? \"Architecture complete\" : `Continue with turn ${currentTurn + 1}`,\n      responseId: responseId,\n      hasMoreWork: hasMoreWork\n    };\n\n    console.log('üîç AGENT: Final response payload:', JSON.stringify(finalResponse, null, 2));\n\n    return res.json(finalResponse);\n\n  } catch (error) {\n    console.error('‚ùå AGENT: Error in simple-agent:', error);\n    \n    // Enhanced error response\n    const errorResponse = {\n      success: false,\n      error: error.message || 'Unknown error occurred',\n      details: error.stack || 'No stack trace available',\n      timestamp: new Date().toISOString()\n    };\n    \n    return res.status(500).json(errorResponse);\n  }\n}",
    "start_line": 37,
    "end_line": 294,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "req",
      "res"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handler",
    "component_id": "api.simple-agent.handler"
  },
  "api.stream.handler": {
    "id": "api.stream.handler",
    "name": "handler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/api/stream.ts",
    "relative_path": "api/stream.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function handler(req: any, res: any) {\n  try {\n    // Server request received\n    \n    // Check environment variables\n    if (!process.env.OPENAI_API_KEY) {\n      console.error('‚ùå OPENAI_API_KEY not found');\n      res.status(500).json({ error: 'Missing OpenAI API key' });\n      return;\n    }\n    \n      // Env OK\n    \n    // Handle CORS preflight\n    if (req.method === 'OPTIONS') {\n      res.setHeader('Access-Control-Allow-Origin', '*');\n      res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Encoding, x-session-id');\n      res.status(200).end();\n      return;\n    }\n\n    // Get payload from request\n    let payload: string;\n    let previousResponseIdFromClient: string | undefined;\n    \n    if (req.method === \"POST\") {\n      const body = req.body;\n      \n      // For FormData requests (with images), conversation is in body?.conversation\n      // For JSON requests, payload is in body?.payload\n      payload = body?.conversation || body?.payload;\n      previousResponseIdFromClient = body?.previous_response_id;\n    } else {\n      payload = req.query.payload || '';\n      previousResponseIdFromClient = req.query.previous_response_id;\n    }\n\n    if (!payload) {\n      console.error('‚ùå No payload provided');\n      res.status(400).json({ error: 'No payload provided' });\n      return;\n    }\n\n    // Processing payload\n    \n    let parsedPayload;\n    try {\n      parsedPayload = typeof payload === 'string' ? JSON.parse(payload) : payload;\n    } catch (error) {\n      console.error('‚ùå Failed to parse payload:', error);\n      res.status(400).json({ error: 'Invalid payload format' });\n      return;\n    }\n\n    // Parse conversation array (like the working local server)\n    const conversation = Array.isArray(parsedPayload) ? parsedPayload : [];\n    \n    // Detect if this is a tool output continuation (Responses API item)\n    const isFunctionCallOutput = Array.isArray(conversation) && conversation[0]?.type === 'function_call_output';\n    \n    // Request analysis\n\n    // Add comprehensive system message only for normal role-based conversations\n    let messages = conversation;\n    if (!isFunctionCallOutput) {\n      if (messages.length === 0 || messages[0]?.role !== 'system') {\n        const systemMessage = {\n          role: 'system' as const,\n          // Pull all static instructions from central config\n          content: elkGraphDescription\n        };\n        \n        if (messages.length === 0) {\n          messages = [systemMessage];\n        } else {\n          messages = [systemMessage, ...messages];\n        }\n      }\n    }\n    \n    // Conversation ready for reasoning agent\n\n    // Initialize OpenAI client\n    // Initializing OpenAI client\n    const model = modelConfigs.reasoning.model;\n    const timeout = timeoutConfigs.requestTimeout;\n    \n    const openai = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n      timeout: timeout,\n    });\n\n    // Set up SSE headers\n    res.setHeader('Content-Type', 'text/event-stream');\n    res.setHeader('Cache-Control', 'no-cache');\n    res.setHeader('Connection', 'keep-alive');\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Encoding, x-session-id');\n\n    // Starting OpenAI stream\n\n    // Use the messages array that was already prepared with system message\n    // messages is already set above with proper system message\n\n    try {\n      // Starting conversation loop\n      \n      // Extract current graph state from the system message\n      let elkGraph = { id: \"root\", children: [], edges: [] };\n      \n      // isFunctionCallOutput already computed above\n      \n      if (isFunctionCallOutput) {\n          // Processing function call output\n      }\n      \n      // Look for the current graph state in the system message\n      const systemMessage = messages.find(msg => msg.role === 'system');\n      if (systemMessage && systemMessage.content) {\n        const graphMatch = systemMessage.content.match(/```json\\n([\\s\\S]*?)\\n```/);\n        if (graphMatch) {\n          try {\n            const parsedGraph = JSON.parse(graphMatch[1]);\n            elkGraph = parsedGraph;\n            // Extracted current graph state\n          } catch (error) {\n            console.error('‚ùå Failed to parse graph state from system message:', error);\n          }\n        } else {\n          // No graph state found in system message\n        }\n      }\n      \n      let finalCleanedConversation = [...messages];\n      // For tool output continuations, do not filter; pass raw items through\n      if (!isFunctionCallOutput) {\n        // Strictly keep only role-based messages (system/user/assistant) as inputs\n        finalCleanedConversation = finalCleanedConversation.filter((item: any) => 'role' in item);\n      }\n      let turnCount = 0;\n      let lastResponseId: string | null = null;\n      let lastUserNudge: any | null = null;\n      \n      // Send helper function\n      const send = (data: any) => {\n        res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n      };\n      \n      while (true) { // Continue until natural completion\n        turnCount++;\n        // Starting conversation turn\n        \n        // Allow ALL tools. Prompting (not hard restrictions) will steer behavior.\n        const allowedTools = allTools.map(tool => ({ type: \"function\", name: tool.name }));\n        const baseRequest: any = {\n          model,\n          tools: allTools.map(tool => ({\n            type: \"function\",\n            name: tool.name,\n            description: tool.description,\n            parameters: tool.parameters\n          })),\n          // Let the model choose when to call tools vs return messages\n          tool_choice: \"auto\",\n          parallel_tool_calls: false,\n          stream: true\n        };\n\n        // Provide minimal reasoning effort and low verbosity specifically for GPT-5 variants\n        if (String(model).includes('gpt-5')) {\n          baseRequest.reasoning = { effort: \"minimal\" };\n          baseRequest.text = { verbosity: \"low\" };\n        }\n\n        // If this is a tool output continuation from client, require a valid previous_response_id\n        if (isFunctionCallOutput) {\n          console.log('üîß Processing function call output continuation');\n          console.log('üîç Function call outputs:', conversation.map((item: any) => ({\n            type: item.type,\n            call_id: item.call_id,\n            output_length: item.output?.length || 0\n          })));\n          \n          if (!previousResponseIdFromClient || !String(previousResponseIdFromClient).startsWith('resp_')) {\n            console.error('‚ùå Invalid or missing previous_response_id for tool output:', previousResponseIdFromClient);\n            if (!res.headersSent) {\n              res.status(400).json({\n                error: \"Missing or invalid previous_response_id for tool output chaining\",\n                details: \"Client must supply a valid previous_response_id (resp_*) when sending function_call_output\"\n              });\n            }\n            return;\n          }\n          \n          // Validate that all items are function_call_output types\n          const invalidItems = conversation.filter((item: any) => item.type !== 'function_call_output');\n          if (invalidItems.length > 0) {\n            console.error('‚ùå Invalid items in function call output request:', invalidItems);\n            if (!res.headersSent) {\n              res.status(400).json({\n                error: \"Invalid function call output format\",\n                details: \"All items must be of type 'function_call_output'\"\n              });\n            }\n            return;\n          }\n          \n          baseRequest.previous_response_id = previousResponseIdFromClient;\n          baseRequest.input = conversation; // pass raw tool output item(s)\n          console.log(`‚úÖ Tool output chaining with response ID: ${previousResponseIdFromClient}`);\n        } else if (lastResponseId && lastUserNudge) {\n          // Normal next turn: chain with last response id and only send nudge\n          baseRequest.previous_response_id = lastResponseId;\n          baseRequest.input = [lastUserNudge];\n        } else {\n          baseRequest.input = finalCleanedConversation;\n        }\n\n        // Minimal request verification log (headers implied via SDK)\n        try {\n          const toolsValid = Array.isArray(baseRequest.tools) && baseRequest.tools.every((t: any) => t?.type === 'function' && t?.name && t?.parameters && t?.parameters.type === 'object');\n          console.log('REQ /v1/responses', {\n            model: baseRequest.model,\n            tool_choice: baseRequest.tool_choice,\n            stream: baseRequest.stream === true,\n            parallel_tool_calls: !!baseRequest.parallel_tool_calls,\n            tools_valid: toolsValid,\n            tools_count: Array.isArray(baseRequest.tools) ? baseRequest.tools.length : 0,\n            has_previous_response_id: !!baseRequest.previous_response_id\n          });\n        } catch {}\n\n        // Create stream (no fallback ‚Äì invalid chaining must fail loudly)\n        const stream: any = await openai.responses.create(baseRequest);\n\n        // OpenAI stream created\n\n        // Minimal, protocol-aligned logging only\n        let createdLogged = false;\n        for await (const delta of stream) {\n          // Check if client has disconnected more gracefully\n          if (res.destroyed || res.writableEnded || !res.writable) {\n            console.warn('‚ö†Ô∏è Client disconnected during stream - stopping gracefully');\n            try {\n              // Attempt to clean up the stream\n              if (typeof stream.controller?.abort === 'function') {\n                stream.controller.abort();\n              }\n            } catch (cleanupError) {\n              console.warn('‚ö†Ô∏è Error during stream cleanup:', cleanupError);\n            }\n            break;\n          }\n          try {\n            // Emit the SSE as-is\n            send(delta);\n            // Protocol visibility logs (strict subset)\n            if (delta.type === 'response.created' && !createdLogged) {\n              createdLogged = true;\n              console.log('EVENT response.created');\n            }\n            // Suppress noisy per-delta logs; keep minimal visibility\n            // function_call_arguments.delta and .done are intentionally not logged per event\n            if (delta.type === 'response.output_item.added' && (delta as any)?.item?.type === 'function_call') {\n              // Keep a single concise log for tool-call addition\n              console.log('EVENT response.output_tool_call.added');\n            }\n            \n            // Do not synthesize function_call_output here; the frontend will send real outputs\n\n            if (delta.type === \"response.completed\") {\n              console.log('EVENT response.completed');\n              const calls = delta.response?.output?.filter((x: any) => x.type === \"function_call\") ?? [];\n              const textResponses = delta.response?.output?.filter((x: any) => x.type === \"message\") ?? [];\n              // Server-side debug: log output type counts\n              const typeCounts: Record<string, number> = {};\n              for (const item of (delta.response?.output ?? [])) {\n                typeCounts[item.type] = (typeCounts[item.type] || 0) + 1;\n              }\n              // output type counts\n              if (delta.response?.id) {\n                lastResponseId = delta.response.id;\n                // Echo the response id back to client so the follow-up tool output can chain correctly\n                send({ type: 'response.id', id: lastResponseId });\n              }\n              \n              // Check if the response indicates completion\n              const responseText = textResponses.map((msg: any) => msg.content || '').join(' ').toLowerCase();\n              const completionIndicators = [\n                'all user requirements have been fully implemented',\n                'architecture completely fulfills the user requirements',\n                'user requirements are completely satisfied',\n                'the architecture is now complete and fulfills all requirements',\n                'all aspects of the user requirements have been implemented',\n                'architecture diagram complete and requirements satisfied',\n                'final architecture complete - all requirements met'\n              ];\n              const hasCompletionIndicator = completionIndicators.some(indicator => responseText.includes(indicator));\n\n              // Special handling: for function_call_output continuations, ALWAYS end this turn after response.completed\n              if (isFunctionCallOutput) {\n                send({ type: 'done', data: '[DONE]' });\n                res.write('data: [DONE]\\n\\n');\n                res.end();\n                return;\n              }\n\n              // Normal conversational handling\n              if (calls.length === 0 && hasCompletionIndicator) {\n                console.log('‚úÖ Conversation complete - AI indicated completion');\n                // Explicitly signal final completion before closing\n                send({ type: 'final.completed' });\n                send({ type: 'done', data: '[DONE]' });\n                res.write('data: [DONE]\\n\\n');\n                res.end();\n                return;\n              } else if (calls.length > 0) {\n                // One or more tool calls were issued. Stop the server loop now and\n                // let the client execute tools and POST back function_call_output in a new request.\n                send({ type: 'done', data: '[DONE]' });\n                res.write('data: [DONE]\\n\\n');\n                res.end();\n                return;\n              } else {\n                // hard nudge to force tool use\n                lastUserNudge = {\n                  role: 'user',\n                  content: 'Use batch_update now with a small set of 3‚Äì7 operations to make incremental progress. After executing, return the entire current graph JSON in a message. Continue this small-burst cadence across turns until the architecture is complete.'\n                };\n                finalCleanedConversation.push(lastUserNudge);\n              }\n              \n              // Do NOT feed back any assistant outputs (message/reasoning/function_call) to next turn.\n              // GPT-5 may require paired reasoning/message items; excluding them avoids 400 pairing errors.\n              const outputToAdd: any[] = [];\n              \n              finalCleanedConversation.push(...outputToAdd);\n              // added assistant items\n              break;\n            }\n          } catch (deltaError) {\n            console.error('‚ùå Error processing delta:', deltaError);\n          }\n        }\n        \n        // Capture response id for next turn chaining\n        if (lastResponseId == null) {\n          // best effort; response id is usually available on response.completed\n        }\n        // No need to check maxTurns since we let it run until natural completion\n      }\n      \n      // Final completion if we exit the loop\n      // conversation completed\n      send({ type: \"done\", data: \"[DONE]\" });\n      res.write('data: [DONE]\\n\\n');\n      res.end();\n\n    } catch (openaiError) {\n      console.error('‚ùå OpenAI API error:', openaiError);\n      \n      // Extract more detailed error information\n      let errorMessage = 'Unknown error';\n      let errorCode = 500;\n      \n      if (openaiError instanceof Error) {\n        errorMessage = openaiError.message;\n        \n        // Handle specific OpenAI API errors\n        if (errorMessage.includes('No tool output found')) {\n          const callIdMatch = errorMessage.match(/call_[a-zA-Z0-9]+/);\n          const missingCallId = callIdMatch ? callIdMatch[0] : 'unknown';\n          console.error('üö® OpenAI \"No tool output found\" error - function call ID mismatch');\n          console.error('üö® This usually happens when function calls are sent with wrong response ID context');\n          console.error('üö® Missing function call ID:', missingCallId);\n          console.error('üö® Request details:', { \n            method: req.method, \n            hasResponseId: !!previousResponseIdFromClient,\n            responseId: previousResponseIdFromClient\n          });\n          errorMessage = `Function call ID mismatch: OpenAI expected output for ${missingCallId} but received different context`;\n          errorCode = 400;\n        } else if (errorMessage.includes('Invalid request')) {\n          console.error('üö® OpenAI invalid request error');\n          errorCode = 400;\n        } else if (errorMessage.includes('rate limit')) {\n          console.error('üö® OpenAI rate limit error');\n          errorCode = 429;\n        }\n      }\n      \n      if (!res.headersSent) {\n        res.status(errorCode).json({ \n          error: 'OpenAI API failed',\n          details: errorMessage,\n          errorType: openaiError instanceof Error ? openaiError.name : 'UnknownError'\n        });\n      } else {\n        res.write(`data: {\"error\": \"OpenAI API failed: ${errorMessage}\", \"errorType\": \"${openaiError instanceof Error ? openaiError.name : 'UnknownError'}\"}\\n\\n`);\n        res.write('data: [DONE]\\n\\n');\n        res.end();\n      }\n    }\n\n  } catch (error) {\n    console.error('‚ùå Stream handler error:', error);\n    \n    try {\n      if (!res.headersSent) {\n        res.status(500).json({ \n          error: 'Stream handler failed',\n          details: error instanceof Error ? error.message : String(error)\n        });\n      } else {\n        res.write(`data: {\"error\": \"Stream failed: ${error instanceof Error ? error.message : String(error)}\"}\\n\\n`);\n        res.write('data: [DONE]\\n\\n');\n        res.end();\n      }\n    } catch (responseError) {\n      console.error('‚ùå Failed to send error response:', responseError);\n    }\n  }\n}",
    "start_line": 9,
    "end_line": 433,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "req",
      "res"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handler",
    "component_id": "api.stream.handler"
  },
  "client.components.App.AppContent": {
    "id": "client.components.App.AppContent",
    "name": "AppContent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/App.jsx",
    "relative_path": "client/components/App.jsx",
    "depends_on": [
      "client.contexts.ViewModeContext.useViewMode"
    ],
    "source_code": "function AppContent() {\n  const { config } = useViewMode();\n  \n  // Simple state management for chat\n  const [isSessionActive, setIsSessionActive] = useState(true); // Always active\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [isAgentReady, setIsAgentReady] = useState(true); // Always ready\n  \n  // Right panel collapse state\n  const [rightPanelCollapsed, setRightPanelCollapsed] = useState(false)\n\n  const startSession = () => {\n    // No-op since chat is always available\n  };\n\n  const stopSession = () => {\n    // No-op since chat is always available\n  };\n\n  const sendTextMessage = (text) => {\n    console.log('Chat message:', text);\n    // This will be handled by the chat component directly\n  };\n\n  const sendClientEvent = (event) => {\n    console.log('Client event:', event);\n  };\n\n  return (\n    <div className=\"h-screen w-screen overflow-hidden flex\">\n      {/* Main Canvas Area */}\n      <div className=\"flex-1 overflow-hidden\">\n        <ErrorBoundary>\n          {config.mode === 'embed' && (\n            <EmbedView\n              isSessionActive={isSessionActive}\n              isConnecting={isConnecting}\n              isAgentReady={isAgentReady}\n              startSession={startSession}\n              stopSession={stopSession}\n              sendTextMessage={sendTextMessage}\n              sendClientEvent={sendClientEvent}\n              events={[]}\n              rightPanelCollapsed={rightPanelCollapsed}\n            />\n          )}\n          {config.mode === 'canvas' && (\n            <CanvasView\n              isSessionActive={isSessionActive}\n              isConnecting={isConnecting}\n              isAgentReady={isAgentReady}\n              startSession={startSession}\n              stopSession={stopSession}\n              sendTextMessage={sendTextMessage}\n              sendClientEvent={sendClientEvent}\n              events={[]}\n              rightPanelCollapsed={rightPanelCollapsed}\n            />\n          )}\n          {config.mode === 'auth' && (\n            <AuthView\n              isSessionActive={isSessionActive}\n              isConnecting={isConnecting}\n              isAgentReady={isAgentReady}\n              startSession={startSession}\n              stopSession={stopSession}\n              sendTextMessage={sendTextMessage}\n              sendClientEvent={sendClientEvent}\n              events={[]}\n              rightPanelCollapsed={rightPanelCollapsed}\n            />\n          )}\n        </ErrorBoundary>\n      </div>\n      \n      {/* Right Panel - Conditionally shown based on ViewMode config */}\n      {config.showChatPanel && (\n        <RightPanelChat \n          isCollapsed={rightPanelCollapsed}\n          onToggleCollapse={() => setRightPanelCollapsed(!rightPanelCollapsed)}\n          currentGraph={null} // TODO: Pass actual graph from InteractiveCanvas\n        />\n      )}\n    </div>\n  );\n}",
    "start_line": 20,
    "end_line": 105,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function AppContent",
    "component_id": "client.components.App.AppContent"
  },
  "client.components.App.startSession": {
    "id": "client.components.App.startSession",
    "name": "startSession",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/App.jsx",
    "relative_path": "client/components/App.jsx",
    "depends_on": [],
    "source_code": "startSession = () => {\n    // No-op since chat is always available\n  }",
    "start_line": 31,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function startSession",
    "component_id": "client.components.App.startSession"
  },
  "client.components.App.stopSession": {
    "id": "client.components.App.stopSession",
    "name": "stopSession",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/App.jsx",
    "relative_path": "client/components/App.jsx",
    "depends_on": [],
    "source_code": "stopSession = () => {\n    // No-op since chat is always available\n  }",
    "start_line": 35,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function stopSession",
    "component_id": "client.components.App.stopSession"
  },
  "client.components.App.sendTextMessage": {
    "id": "client.components.App.sendTextMessage",
    "name": "sendTextMessage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/App.jsx",
    "relative_path": "client/components/App.jsx",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "sendTextMessage = (text) => {\n    console.log('Chat message:', text);\n    // This will be handled by the chat component directly\n  }",
    "start_line": 39,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sendTextMessage",
    "component_id": "client.components.App.sendTextMessage"
  },
  "client.components.App.sendClientEvent": {
    "id": "client.components.App.sendClientEvent",
    "name": "sendClientEvent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/App.jsx",
    "relative_path": "client/components/App.jsx",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "sendClientEvent = (event) => {\n    console.log('Client event:', event);\n  }",
    "start_line": 44,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sendClientEvent",
    "component_id": "client.components.App.sendClientEvent"
  },
  "client.components.App.App": {
    "id": "client.components.App.App",
    "name": "App",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/App.jsx",
    "relative_path": "client/components/App.jsx",
    "depends_on": [],
    "source_code": "function App() {\n  return (\n    <ViewModeProvider fallbackMode=\"auth\">\n      <NodeStyleProvider>\n        <AppContent />\n      </NodeStyleProvider>\n    </ViewModeProvider>\n  );\n}",
    "start_line": 107,
    "end_line": 115,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function App",
    "component_id": "client.components.App.App"
  },
  "client.components.DebugGeometry.DebugGeometry": {
    "id": "client.components.DebugGeometry.DebugGeometry",
    "name": "DebugGeometry",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/DebugGeometry.tsx",
    "relative_path": "client/components/DebugGeometry.tsx",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "DebugGeometry = () => {\n  const rf = useReactFlow();\n\n  useEffect(() => {\n    /** wait for RF to mount everything */\n    const timer = setTimeout(() => {\n      const edge = rf.getEdges().find(e => e.id === 'e1');\n      if (!edge) {\n        console.log('[üîç DOM] No edge with id e1 found');\n        return;\n      }\n\n      console.log('[üîç DOM] Found edge:', edge);\n\n      const srcHandle = document.querySelector(\n        `[data-id=\"${edge.source}__${edge.sourceHandle}\"]`\n      ) as HTMLElement | null;\n\n      const tgtHandle = document.querySelector(\n        `[data-id=\"${edge.target}__${edge.targetHandle}\"]`\n      ) as HTMLElement | null;\n\n      const srcNodeEl = document.querySelector(`[id=\"node-${edge.source}\"]`);\n      const tgtNodeEl = document.querySelector(`[id=\"node-${edge.target}\"]`);\n\n      console.log('[üîç DOM]', {\n        edgeId: edge.id,\n        source: edge.source,\n        target: edge.target,\n        srcHandle: srcHandle?.getBoundingClientRect(),\n        tgtHandle: tgtHandle?.getBoundingClientRect(),\n        srcNode: srcNodeEl?.getBoundingClientRect(),\n        tgtNode: tgtNodeEl?.getBoundingClientRect(),\n      });\n    }, 1000); // Wait 1 second for everything to be mounted\n\n    return () => clearTimeout(timer);\n  }, [rf]);\n\n  return null;   // invisible helper\n}",
    "start_line": 4,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function DebugGeometry",
    "component_id": "client.components.DebugGeometry.DebugGeometry"
  },
  "client.components.ErrorBoundary.ErrorBoundary": {
    "id": "client.components.ErrorBoundary.ErrorBoundary",
    "name": "ErrorBoundary",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ErrorBoundary.jsx",
    "relative_path": "client/components/ErrorBoundary.jsx",
    "depends_on": [
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.error(\"Error caught by ErrorBoundary:\", error);\n    console.error(\"Error info:\", errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div className=\"p-4 border border-red-300 bg-red-50 rounded-md\">\n          <h2 className=\"text-lg font-semibold text-red-700\">Something went wrong</h2>\n          <details className=\"mt-2 text-sm text-red-600\">\n            <summary>Error details</summary>\n            <pre className=\"mt-2 p-2 bg-red-100 rounded overflow-auto max-h-40\">\n              {this.state.error && this.state.error.toString()}\n            </pre>\n          </details>\n          <button\n            className=\"mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n            onClick={() => this.setState({ hasError: false })}\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}",
    "start_line": 3,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ErrorBoundary",
    "component_id": "client.components.ErrorBoundary.ErrorBoundary"
  },
  "client.components.FramerEmbeddable.FramerEmbeddableProps": {
    "id": "client.components.FramerEmbeddable.FramerEmbeddableProps",
    "name": "FramerEmbeddableProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/FramerEmbeddable.tsx",
    "relative_path": "client/components/FramerEmbeddable.tsx",
    "depends_on": [],
    "source_code": "interface FramerEmbeddableProps {\n  apiEndpoint?: string;\n  width?: string | number;\n  height?: string | number;\n  style?: React.CSSProperties;\n}",
    "start_line": 6,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FramerEmbeddableProps",
    "component_id": "client.components.FramerEmbeddable.FramerEmbeddableProps"
  },
  "client.components.FramerEmbeddable.FramerEmbeddable": {
    "id": "client.components.FramerEmbeddable.FramerEmbeddable",
    "name": "FramerEmbeddable",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/FramerEmbeddable.tsx",
    "relative_path": "client/components/FramerEmbeddable.tsx",
    "depends_on": [
      "client.components.FramerEmbeddable.FramerEmbeddableProps",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function FramerEmbeddable({\n  apiEndpoint = 'https://archgen-ecru.vercel.app',\n  width = '100%',\n  height = '800px',\n  style = {}\n}: FramerEmbeddableProps) {\n  const [isSessionActive, setIsSessionActive] = useState(false);\n  const [events, setEvents] = useState<any[]>([]);\n\n  const startSession = () => {\n    setIsSessionActive(true);\n  };\n\n  const stopSession = () => {\n    setIsSessionActive(false);\n  };\n\n  const sendTextMessage = (message: string) => {\n    console.log('Sending message:', message);\n  };\n\n  const sendClientEvent = (event: any) => {\n    console.log('Sending event:', event);\n  };\n\n  const containerStyle: React.CSSProperties = {\n    width: typeof width === 'number' ? `${width}px` : width,\n    height: typeof height === 'number' ? `${height}px` : height,\n    border: '1px solid #e0e0e0',\n    borderRadius: '8px',\n    overflow: 'hidden',\n    backgroundColor: '#ffffff',\n    ...style\n  };\n\n  return (\n    <ApiEndpointProvider apiEndpoint={apiEndpoint}>\n      <ViewModeProvider fallbackMode=\"embed\">\n        <div style={containerStyle}>\n          <InteractiveCanvas\n            isSessionActive={isSessionActive}\n            startSession={startSession}\n            stopSession={stopSession}\n            sendTextMessage={sendTextMessage}\n            sendClientEvent={sendClientEvent}\n            events={events}\n            apiEndpoint={apiEndpoint}\n            isPublicMode={true}\n          />\n        </div>\n      </ViewModeProvider>\n    </ApiEndpointProvider>\n  );\n}",
    "start_line": 13,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function FramerEmbeddable",
    "component_id": "client.components.FramerEmbeddable.FramerEmbeddable"
  },
  "client.components.StepEdge.Window": {
    "id": "client.components.StepEdge.Window",
    "name": "Window",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/StepEdge.tsx",
    "relative_path": "client/components/StepEdge.tsx",
    "depends_on": [],
    "source_code": "interface Window {\n    libavoid?: any;\n    Avoid?: any;\n    __edgeDebug?: {\n      [key: string]: {\n        snappedPoints: Point[];\n        rawPolyline?: Point[];\n        fallbackApplied: boolean;\n        status?: RoutingStatus;\n        message?: string;\n        sourcePosition: Position | undefined;\n        targetPosition: Position | undefined;\n      };\n    };\n  }",
    "start_line": 21,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Window",
    "component_id": "client.components.StepEdge.Window"
  },
  "client.components.auth.ComingSoonCard.ComingSoonCardProps": {
    "id": "client.components.auth.ComingSoonCard.ComingSoonCardProps",
    "name": "ComingSoonCardProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/auth/ComingSoonCard.tsx",
    "relative_path": "client/components/auth/ComingSoonCard.tsx",
    "depends_on": [],
    "source_code": "interface ComingSoonCardProps {\n  onClose: () => void;\n}",
    "start_line": 3,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ComingSoonCardProps",
    "component_id": "client.components.auth.ComingSoonCard.ComingSoonCardProps"
  },
  "client.components.auth.ComingSoonCard.ComingSoonCard": {
    "id": "client.components.auth.ComingSoonCard.ComingSoonCard",
    "name": "ComingSoonCard",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/auth/ComingSoonCard.tsx",
    "relative_path": "client/components/auth/ComingSoonCard.tsx",
    "depends_on": [
      "client.components.auth.ComingSoonCard.ComingSoonCardProps"
    ],
    "source_code": "ComingSoonCard: React.FC<ComingSoonCardProps> = ({ onClose }) => {\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n      <div className=\"bg-white p-8 rounded-lg shadow-lg text-center relative\">\n        <button\n          onClick={onClose}\n          className=\"absolute top-2 right-2 text-gray-400 hover:text-gray-600\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-6 w-6\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n          </svg>\n        </button>\n        <h2 className=\"text-2xl font-bold mb-4\">Coming soon</h2>\n        <p className=\"mb-6\">Thank you for your support.</p>\n      </div>\n    </div>\n  );\n}",
    "start_line": 7,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function ComingSoonCard",
    "component_id": "client.components.auth.ComingSoonCard.ComingSoonCard"
  },
  "client.components.canvas.ConfirmModal.ConfirmModal": {
    "id": "client.components.canvas.ConfirmModal.ConfirmModal",
    "name": "ConfirmModal",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/canvas/ConfirmModal.tsx",
    "relative_path": "client/components/canvas/ConfirmModal.tsx",
    "depends_on": [],
    "source_code": "function ConfirmModal({\n  show,\n  title,\n  message,\n  confirmText = \"Delete\",\n  cancelText = \"Cancel\",\n  onConfirm,\n  onCancel,\n}: {\n  show: boolean;\n  title: string;\n  message: string;\n  confirmText?: string;\n  cancelText?: string;\n  onConfirm: () => void;\n  onCancel: () => void;\n}) {\n  if (!show) return null;\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-[9999]\" onClick={onCancel}>\n      <div className=\"bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl\" onClick={e => e.stopPropagation()}>\n        <div className=\"flex items-center justify-between mb-4\">\n          <h3 className=\"text-lg font-semibold text-gray-900\">{title}</h3>\n          <button onClick={onCancel} className=\"text-gray-400 hover:text-gray-600\">\n            <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\"/>\n            </svg>\n          </button>\n        </div>\n        <p className=\"text-gray-600 mb-4\">{message}</p>\n        <div className=\"flex gap-2\">\n          <button onClick={onCancel} className=\"flex-1 px-4 py-2 text-gray-600 hover:text-gray-800\">{cancelText}</button>\n          <button onClick={onConfirm} className=\"flex-1 px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700\">\n            {confirmText}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}",
    "start_line": 4,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ConfirmModal",
    "component_id": "client.components.canvas.ConfirmModal.ConfirmModal"
  },
  "client.components.canvas.PromptModal.PromptModal": {
    "id": "client.components.canvas.PromptModal.PromptModal",
    "name": "PromptModal",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/canvas/PromptModal.tsx",
    "relative_path": "client/components/canvas/PromptModal.tsx",
    "depends_on": [],
    "source_code": "function PromptModal({\n  show,\n  title,\n  placeholder,\n  defaultValue,\n  onConfirm,\n  onCancel,\n}: {\n  show: boolean;\n  title: string;\n  placeholder: string;\n  defaultValue: string;\n  onConfirm: (value: string) => void;\n  onCancel: () => void;\n}) {\n  const ref = useRef<HTMLInputElement>(null);\n  useEffect(() => { if (show) ref.current?.focus(); }, [show]);\n  if (!show) return null;\n\n  return (\n    <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-[9999]\" onClick={onCancel}>\n      <div className=\"bg-white rounded-lg p-6 max-w-md w-full mx-4 shadow-xl\" onClick={e => e.stopPropagation()}>\n        <div className=\"flex items-center justify-between mb-4\">\n          <h3 className=\"text-lg font-semibold text-gray-900\">{title}</h3>\n          <button onClick={onCancel} className=\"text-gray-400 hover:text-gray-600 transition-colors\">\n            <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\"/>\n            </svg>\n          </button>\n        </div>\n\n        <input\n          ref={ref}\n          type=\"text\"\n          placeholder={placeholder}\n          defaultValue={defaultValue}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\") onConfirm((e.target as HTMLInputElement).value);\n            if (e.key === \"Escape\") onCancel();\n          }}\n          className=\"w-full p-3 bg-gray-50 border rounded-lg text-sm text-gray-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none\"\n        />\n        <div className=\"flex gap-2 mt-4\">\n          <button onClick={onCancel} className=\"flex-1 px-4 py-2 text-gray-600 hover:text-gray-800\">Cancel</button>\n          <button\n            onClick={() => onConfirm(ref.current?.value || \"\")}\n            className=\"flex-1 px-4 py-2 bg-gray-900 text-white rounded-lg hover:bg-gray-800\"\n          >\n            Confirm\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}",
    "start_line": 4,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function PromptModal",
    "component_id": "client.components.canvas.PromptModal.PromptModal"
  },
  "client.components.canvas.ShareOverlay.ShareOverlayState": {
    "id": "client.components.canvas.ShareOverlay.ShareOverlayState",
    "name": "ShareOverlayState",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/canvas/ShareOverlay.tsx",
    "relative_path": "client/components/canvas/ShareOverlay.tsx",
    "depends_on": [],
    "source_code": "type ShareOverlayState = { show: boolean; url: string; error?: string; copied?: boolean };",
    "start_line": 5,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ShareOverlayState",
    "component_id": "client.components.canvas.ShareOverlay.ShareOverlayState"
  },
  "client.components.console.ErrorBoundary.ErrorBoundary": {
    "id": "client.components.console.ErrorBoundary.ErrorBoundary",
    "name": "ErrorBoundary",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/console/ErrorBoundary.jsx",
    "relative_path": "client/components/console/ErrorBoundary.jsx",
    "depends_on": [
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // You can also log the error to an error reporting service\n    console.error(\"Error caught by ErrorBoundary:\", error);\n    console.error(\"Error info:\", errorInfo);\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div className=\"p-4 border border-red-300 bg-red-50 rounded-md\">\n          <h2 className=\"text-lg font-semibold text-red-700\">Something went wrong</h2>\n          <details className=\"mt-2 text-sm text-red-600\">\n            <summary>Error details</summary>\n            <pre className=\"mt-2 p-2 bg-red-100 rounded overflow-auto max-h-40\">\n              {this.state.error && this.state.error.toString()}\n            </pre>\n          </details>\n          <button\n            className=\"mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n            onClick={() => this.setState({ hasError: false })}\n          >\n            Try again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}",
    "start_line": 3,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ErrorBoundary",
    "component_id": "client.components.console.ErrorBoundary.ErrorBoundary"
  },
  "client.components.graph.__tests__.findLCG.test.findNodeById": {
    "id": "client.components.graph.__tests__.findLCG.test.findNodeById",
    "name": "findNodeById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/__tests__/findLCG.test.ts",
    "relative_path": "client/components/graph/__tests__/findLCG.test.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.__tests__.findLCG.test.findNodeById",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function findNodeById(node: ElkGraphNode, id: NodeID): ElkGraphNode | null {\n  if (node.id === id) return node;\n  if (node.children) {\n    for (const child of node.children) {\n      const found = findNodeById(child, id);\n      if (found) return found;\n    }\n  }\n  return null;\n}",
    "start_line": 7,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findNodeById",
    "component_id": "client.components.graph.__tests__.findLCG.test.findNodeById"
  },
  "client.components.graph.initialGraph.getInitialGraph": {
    "id": "client.components.graph.initialGraph.getInitialGraph",
    "name": "getInitialGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/initialGraph.ts",
    "relative_path": "client/components/graph/initialGraph.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "getInitialGraph = (): RawGraph => ({\n  id: \"root\",\n\n  // /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ children ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n  children: [\n\n    // /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 1. edge devices ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    // {\n    //   id: \"devices\",\n    //   data: {\n    //     label: \"Edge Devices\",\n    //     icon : \"browser_client\",\n    //     style: STYLES.GREEN\n    //   },\n    //   children: [\n    //     { id: \"iot_device\", data: { label: \"IoT Device\", icon: \"iot_core\" } },\n    //     { id: \"gateway\",    data: { label: \"Gateway\",    icon: \"vpn_gateway_generic\" } }\n    //   ],\n    //   edges: [\n    //     {\n    //       id     : \"e_device_gateway\",\n    //       sources: [\"iot_device\"],\n    //       targets: [\"gateway\"],\n    //       labels : [{ text: \"send telemetry\" }]\n    //     }\n    //   ]\n    // },\n\n    // /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 2. Google Cloud Platform ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n    // {\n    //   id: \"gcp\",\n    //   data: {\n    //     label: \"Google Cloud Platform\",\n    //     icon : \"gcp_logo\",\n    //     style: STYLES.BLUE\n    //   },\n\n    //   /* nested groups --------------------------------------------------- */\n    //   children: [\n\n    //     /* 2-A. Pub/Sub ingest */\n    //     {\n    //       id: \"messaging\",\n    //       data: {\n    //         label: \"Messaging\",\n    //         icon : \"pubsub\",\n    //         style: STYLES.YELLOW\n    //       },\n    //       children: [\n    //         { id: \"pubsub\", data: { label: \"Cloud Pub/Sub\", icon: \"pubsub\" } }\n    //       ]\n    //     },\n\n    //     /* 2-B. Observability */\n    //     {\n    //       id: \"observability\",\n    //       data: {\n    //         label: \"Observability\",\n    //         icon : \"cloud_monitoring\",\n    //         style: STYLES.GREY\n    //       },\n    //       children: [\n    //         { id: \"cloud_monitoring\", data: { label: \"Cloud Monitoring\", icon: \"cloud_monitoring\" } },\n    //         { id: \"cloud_logging\",    data: { label: \"Cloud Logging\",    icon: \"cloud_logging\"     } }\n    //       ],\n    //       edges: [\n    //         {\n    //           id     : \"e_monitoring_logging\",\n    //           sources: [\"cloud_monitoring\"],\n    //           targets: [\"cloud_logging\"],\n    //           labels : [{ text: \"export metrics\" }]\n    //         }\n    //       ]\n    //     },\n\n    //     /* 2-C. Data-flow pipeline */\n    //     {\n    //       id: \"etl_pipeline\",\n    //       data: {\n    //         label: \"Data Pipelines\",\n    //         icon : \"dataflow\",\n    //         style: STYLES.PURPLE\n    //       },\n    //       children: [\n    //         { id: \"dataflow\", data: { label: \"Cloud Dataflow\", icon: \"dataflow\" } }\n    //       ]\n    //     },\n\n    //     /* 2-D. Storage */\n    //     {\n    //       id: \"storage\",\n    //       data: {\n    //         label: \"Storage\",\n    //         icon : \"cloud_storage\",\n    //         style: STYLES.GREEN\n    //       },\n    //       children: [\n    //         { id: \"cloud_storage\",   data: { label: \"Cloud Storage\",  icon: \"cloud_storage\"   } },\n    //         { id: \"cloud_datastore\", data: { label: \"Cloud Datastore\",icon: \"cloud_datastore\" } },\n    //         { id: \"cloud_bigtable\",  data: { label: \"Cloud Bigtable\", icon: \"bigtable\"        } }\n    //       ]\n    //     },\n\n    //     /* 2-E. Analytics */\n    //     {\n    //       id: \"analytics\",\n    //       data: {\n    //         label: \"Analytics\",\n    //         icon : \"bigquery\",\n    //         style: STYLES.TEAL\n    //       },\n    //       children: [\n    //         { id: \"bigquery\", data: { label: \"BigQuery\",      icon: \"bigquery\"    } },\n    //         { id: \"dataproc\", data: { label: \"Cloud Dataproc\", icon: \"dataproc\"    } },\n    //         { id: \"datalab\",  data: { label: \"Cloud Datalab\",  icon: \"cloud_datalab\" } }\n    //       ]\n    //     },\n\n    //     /* 2-F. Application & presentation */\n    //     {\n    //       id: \"compute\",\n    //       data: {\n    //         label: \"Application & Presentation\",\n    //         icon : \"app_engine\",\n    //         style: STYLES.GREY\n    //       },\n    //       children: [\n    //         { id: \"app_engine\",      data: { label: \"App Engine\",      icon: \"app_engine\"      } },\n    //         { id: \"container_engine\",data: { label: \"Container Engine\",icon: \"gke_autopilot\"   } },\n    //         { id: \"compute_engine\",  data: { label: \"Compute Engine\",  icon: \"compute_engine\"  } }\n    //       ]\n    //     }\n    //   ],\n\n    //   /* edges inside the GCP super-group -------------------------------- */\n    //   edges: [\n    //     /* ingest ‚Üí pipeline */\n    //     {\n    //       id:\"e_pubsub_dataflow\",\n    //       sources:[\"pubsub\"],\n    //       targets:[\"dataflow\"],\n    //       labels:[{ text:\"stream ingest\" }]\n    //     },\n\n    //     /* pipeline ‚Üí storage */\n    //     { id:\"e_dataflow_storage\",   sources:[\"dataflow\"], targets:[\"cloud_storage\"],   labels:[{ text:\"write\" }] },\n    //     { id:\"e_dataflow_datastore\", sources:[\"dataflow\"], targets:[\"cloud_datastore\"], labels:[{ text:\"write\" }] },\n    //     { id:\"e_dataflow_bigtable\",  sources:[\"dataflow\"], targets:[\"cloud_bigtable\"],  labels:[{ text:\"write\" }] },\n\n    //     /* pipeline ‚Üí analytics */\n    //     { id:\"e_dataflow_bigquery\", sources:[\"dataflow\"], targets:[\"bigquery\"], labels:[{ text:\"stream\"  }] },\n    //     { id:\"e_dataflow_dataproc\", sources:[\"dataflow\"], targets:[\"dataproc\"], labels:[{ text:\"trigger\" }] },\n    //     { id:\"e_dataflow_datalab\",  sources:[\"dataflow\"], targets:[\"datalab\"],  labels:[{ text:\"feed\"    }] },\n\n    //     /* logging ‚Üí analytics */\n    //     { id:\"e_logging_bigquery\", sources:[\"cloud_logging\"], targets:[\"bigquery\"], labels:[{ text:\"export logs\" }] },\n\n    //     /* analytics ‚Üí presentation */\n    //     { id:\"e_bigquery_appengine\", sources:[\"bigquery\"], targets:[\"app_engine\"],      labels:[{ text:\"serve insights\" }] },\n    //     { id:\"e_bigquery_container\", sources:[\"bigquery\"], targets:[\"container_engine\"],labels:[{ text:\"serve insights\" }] },\n    //     { id:\"e_bigquery_compute\",   sources:[\"bigquery\"], targets:[\"compute_engine\"],  labels:[{ text:\"serve insights\" }] }\n    //   ]\n    // }\n  // ],\n\n  // edges: [\n    // {\n    //   id     : \"e_gateway_pubsub\",\n    //   sources: [\"gateway\"],\n    //   targets: [\"pubsub\"],\n    //   labels : [{ text: \"streams data\" }]\n    // }\n  ]\n})",
    "start_line": 7,
    "end_line": 180,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function getInitialGraph",
    "component_id": "client.components.graph.initialGraph.getInitialGraph"
  },
  "client.components.graph.mutations.collectNodeIds": {
    "id": "client.components.graph.mutations.collectNodeIds",
    "name": "collectNodeIds",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.collectNodeIds",
      "client.types.graph.NodeID",
      "client.components.graph.utils.elk.edgePoints.add",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "collectNodeIds = (n: ElkGraphNode, acc: Set<NodeID> = new Set()) => {\n  acc.add(n.id);\n  (n.children ?? []).forEach(c => collectNodeIds(c, acc));\n  return acc;\n}",
    "start_line": 26,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "n",
      "acc"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function collectNodeIds",
    "component_id": "client.components.graph.mutations.collectNodeIds"
  },
  "client.components.graph.mutations.isDescendantOf": {
    "id": "client.components.graph.mutations.isDescendantOf",
    "name": "isDescendantOf",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.collectNodeIds",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "isDescendantOf = (root: ElkGraphNode, maybeDesc: ElkGraphNode): boolean =>\n  collectNodeIds(root).has(maybeDesc.id)",
    "start_line": 33,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root",
      "maybeDesc"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function isDescendantOf",
    "component_id": "client.components.graph.mutations.isDescendantOf"
  },
  "client.components.graph.mutations.edgeIdExists": {
    "id": "client.components.graph.mutations.edgeIdExists",
    "name": "edgeIdExists",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.collectEdges",
      "client.types.graph.ElkGraphNode",
      "client.types.graph.EdgeID"
    ],
    "source_code": "edgeIdExists = (g: ElkGraphNode, eid: EdgeID): boolean =>\n  collectEdges(g).some(({ edgeArr }) => edgeArr.some(e => e.id === eid))",
    "start_line": 37,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "g",
      "eid"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function edgeIdExists",
    "component_id": "client.components.graph.mutations.edgeIdExists"
  },
  "client.components.graph.mutations.purgeEdgesReferencing": {
    "id": "client.components.graph.mutations.purgeEdgesReferencing",
    "name": "purgeEdgesReferencing",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "purgeEdgesReferencing = (root: ElkGraphNode, victimIds: Set<NodeID>): void => {\n  const sweep = (n: ElkGraphNode) => {\n    if (n.edges) {\n      n.edges = n.edges.filter(\n        e =>\n          !e.sources.some(s => victimIds.has(s)) &&\n          !e.targets.some(t => victimIds.has(t))\n      );\n    }\n    (n.children ?? []).forEach(sweep);\n  };\n  sweep(root);\n}",
    "start_line": 41,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root",
      "victimIds"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function purgeEdgesReferencing",
    "component_id": "client.components.graph.mutations.purgeEdgesReferencing"
  },
  "client.components.graph.mutations.reattachEdgesForSubtree": {
    "id": "client.components.graph.mutations.reattachEdgesForSubtree",
    "name": "reattachEdgesForSubtree",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.ElkGraphNode",
      "client.components.graph.mutations.updateEdgesForNode"
    ],
    "source_code": "reattachEdgesForSubtree = (subRoot: ElkGraphNode, graph: ElkGraphNode) => {\n  const queue: ElkGraphNode[] = [subRoot];\n  while (queue.length) {\n    const n = queue.shift()!;\n    updateEdgesForNode(n.id, graph);\n    n.children?.forEach(c => queue.push(c));\n  }\n}",
    "start_line": 55,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "subRoot",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function reattachEdgesForSubtree",
    "component_id": "client.components.graph.mutations.reattachEdgesForSubtree"
  },
  "client.components.graph.mutations.findNodeById": {
    "id": "client.components.graph.mutations.findNodeById",
    "name": "findNodeById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.mutations.findNodeById",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "findNodeById = (node: ElkGraphNode, id: NodeID): ElkGraphNode | null => {\n  if (node.id === id) return node;\n  if (node.children) {\n    for (const child of node.children) {\n      const found = findNodeById(child, id);\n      if (found) return found;\n    }\n  }\n  return null;\n}",
    "start_line": 71,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "id"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function findNodeById",
    "component_id": "client.components.graph.mutations.findNodeById"
  },
  "client.components.graph.mutations.findParentOfNode": {
    "id": "client.components.graph.mutations.findParentOfNode",
    "name": "findParentOfNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.mutations.findParentOfNode",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "findParentOfNode = (\n  root: ElkGraphNode,\n  id: NodeID,\n  parent: ElkGraphNode | null = null\n): ElkGraphNode | null => {\n  if (root.id === id) return parent;\n  if (root.children) {\n    for (const child of root.children) {\n      const result = findParentOfNode(child, id, root);\n      if (result) return result;\n    }\n  }\n  return null;\n}",
    "start_line": 85,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root",
      "id",
      "parent"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function findParentOfNode",
    "component_id": "client.components.graph.mutations.findParentOfNode"
  },
  "client.components.graph.mutations.getPathToNode": {
    "id": "client.components.graph.mutations.getPathToNode",
    "name": "getPathToNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.mutations.getPathToNode",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "getPathToNode = (\n  node: ElkGraphNode,\n  nodeId: NodeID,\n  path: ElkGraphNode[] = []\n): ElkGraphNode[] | null => {\n  if (node.id === nodeId) return [...path, node];\n  if (node.children) {\n    for (const child of node.children) {\n      const result = getPathToNode(child, nodeId, [...path, node]);\n      if (result) return result;\n    }\n  }\n  return null;\n}",
    "start_line": 103,
    "end_line": 116,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "nodeId",
      "path"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function getPathToNode",
    "component_id": "client.components.graph.mutations.getPathToNode"
  },
  "client.components.graph.mutations.findCommonAncestor": {
    "id": "client.components.graph.mutations.findCommonAncestor",
    "name": "findCommonAncestor",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.mutations.getPathToNode",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "findCommonAncestor = (\n  layout: ElkGraphNode,\n  id1: NodeID,\n  id2: NodeID\n): ElkGraphNode | null => {\n  const path1 = getPathToNode(layout, id1);\n  const path2 = getPathToNode(layout, id2);\n  if (!path1 || !path2) return null;\n  let common: ElkGraphNode | null = null;\n  for (let i = 0; i < Math.min(path1.length, path2.length); i++) {\n    if (path1[i].id === path2[i].id) {\n      common = path1[i];\n    } else {\n      break;\n    }\n  }\n  return common;\n}",
    "start_line": 121,
    "end_line": 138,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout",
      "id1",
      "id2"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function findCommonAncestor",
    "component_id": "client.components.graph.mutations.findCommonAncestor"
  },
  "client.components.graph.mutations.findLCG": {
    "id": "client.components.graph.mutations.findLCG",
    "name": "findLCG",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.getPathToNode",
      "client.types.graph.ElkGraphNode",
      "client.types.graph.NodeID",
      "client.components.graph.mutations.findNodeById",
      "client.components.graph.mutations.findParentOfNode"
    ],
    "source_code": "findLCG = (\n  graph: ElkGraphNode,\n  ids: NodeID[]\n): ElkGraphNode | null => {\n  // Edge case: empty array\n  if (ids.length === 0) {\n    return null;\n  }\n\n  // Deduplicate IDs to handle duplicate selections\n  const uniqueIds = Array.from(new Set(ids));\n\n  // Edge case: single unique node - return its parent (or root if no parent)\n  if (uniqueIds.length === 1) {\n    const node = findNodeById(graph, uniqueIds[0]);\n    if (!node) return null;\n    const parent = findParentOfNode(graph, uniqueIds[0]);\n    return parent || graph;\n  }\n\n  // For 2+ nodes: get paths for all nodes\n  const paths = uniqueIds\n    .map(id => getPathToNode(graph, id))\n    .filter((path): path is ElkGraphNode[] => path !== null);\n\n  // If any node not found, return null\n  if (paths.length !== uniqueIds.length) {\n    return null;\n  }\n\n  // Find longest common prefix across all paths\n  if (paths.length === 0) {\n    return null;\n  }\n\n  let common: ElkGraphNode | null = null;\n  const minLength = Math.min(...paths.map(p => p.length));\n\n  for (let i = 0; i < minLength; i++) {\n    const firstId = paths[0][i].id;\n    // Check if all paths have the same node at this depth\n    if (paths.every(p => p[i].id === firstId)) {\n      common = paths[0][i];\n    } else {\n      // Paths diverge at this depth, stop here\n      break;\n    }\n  }\n\n  // Critical fix: Check if the common ancestor is one of the selected items\n  // If so, return its parent instead (LCG should be PARENT of selection, not part of it)\n  if (common && uniqueIds.includes(common.id)) {\n    const parent = findParentOfNode(graph, common.id);\n    return parent || graph;\n  }\n\n  return common;\n}",
    "start_line": 152,
    "end_line": 209,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "ids"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function findLCG",
    "component_id": "client.components.graph.mutations.findLCG"
  },
  "client.components.graph.mutations.EdgeCollection": {
    "id": "client.components.graph.mutations.EdgeCollection",
    "name": "EdgeCollection",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.ElkGraphEdge",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "interface EdgeCollection {\n  edgeArr: ElkGraphEdge[];\n  parent: ElkGraphNode;\n}",
    "start_line": 214,
    "end_line": 217,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeCollection",
    "component_id": "client.components.graph.mutations.EdgeCollection"
  },
  "client.components.graph.mutations.collectEdges": {
    "id": "client.components.graph.mutations.collectEdges",
    "name": "collectEdges",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.collectEdges",
      "client.types.graph.ElkGraphNode",
      "client.components.graph.mutations.EdgeCollection"
    ],
    "source_code": "collectEdges = (node: ElkGraphNode | null | undefined, collection: EdgeCollection[] = []): EdgeCollection[] => {\n  if (!node) return collection;\n  if (node.edges) {\n    collection.push({ edgeArr: node.edges, parent: node });\n  }\n  if (node.children) {\n    for (const child of node.children) {\n      if (child) {\n        collectEdges(child, collection);\n      }\n    }\n  }\n  return collection;\n}",
    "start_line": 222,
    "end_line": 235,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "collection"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function collectEdges",
    "component_id": "client.components.graph.mutations.collectEdges"
  },
  "client.components.graph.mutations.updateEdgesForNode": {
    "id": "client.components.graph.mutations.updateEdgesForNode",
    "name": "updateEdgesForNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.collectEdges",
      "client.types.graph.NodeID",
      "client.types.graph.ElkGraphNode",
      "client.components.graph.mutations.findCommonAncestor"
    ],
    "source_code": "updateEdgesForNode = (nodeId: NodeID, layout: ElkGraphNode): ElkGraphNode => {\n  const allEdges = collectEdges(layout);\n  for (const { edgeArr, parent } of allEdges) {\n    // Loop backwards in case we need to remove any edges.\n    for (let i = edgeArr.length - 1; i >= 0; i--) {\n      const edge = edgeArr[i];\n      if (edge.sources.includes(nodeId) || edge.targets.includes(nodeId)) {\n        // For simplicity, assume one source and one target per edge.\n        const sourceId = edge.sources[0];\n        const targetId = edge.targets[0];\n        const commonAncestor = findCommonAncestor(layout, sourceId, targetId);\n        if (commonAncestor && (!parent || parent.id !== commonAncestor.id)) {\n          // Remove the edge from the current parent's edge list.\n          edgeArr.splice(i, 1);\n          if (!commonAncestor.edges) commonAncestor.edges = [];\n          commonAncestor.edges.push(edge);\n        }\n      }\n    }\n  }\n  return layout;\n}",
    "start_line": 241,
    "end_line": 262,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "layout"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function updateEdgesForNode",
    "component_id": "client.components.graph.mutations.updateEdgesForNode"
  },
  "client.components.graph.mutations.notFound": {
    "id": "client.components.graph.mutations.notFound",
    "name": "notFound",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "notFound = (type: \"node\"|\"edge\"|\"shape\", id: string) =>\n  console.error(`‚ùå ${type} '${id}' not found ‚Äì caller / stack:`, new Error().stack)",
    "start_line": 265,
    "end_line": 266,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "type",
      "id"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function notFound",
    "component_id": "client.components.graph.mutations.notFound"
  },
  "client.components.graph.mutations.addNode": {
    "id": "client.components.graph.mutations.addNode",
    "name": "addNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.styles.getStyle",
      "client.types.graph.ElkGraphNode",
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.types.graph.createNodeID",
      "client.components.graph.mutations.findNodeById",
      "client.components.graph.mutations.notFound"
    ],
    "source_code": "addNode = (\n  nodeName: string, \n  parentId: NodeID, \n  graph: RawGraph,\n  data?: { label?: string; icon?: string; style?: any }\n): RawGraph => {\n  \n  // Clone the graph to ensure React detects the state change\n  const clonedGraph = structuredClone(graph);\n\n  // Check for duplicate ID using normalized name\n  const normalizedId = createNodeID(nodeName);\n  if (findNodeById(clonedGraph, normalizedId)) {\n    throw new Error(`duplicate node id '${normalizedId}'`);\n  }\n  \n  // Special case: when parentId is 'root', use the cloned graph itself as the parent\n  let parentNode: ElkGraphNode;\n  if (parentId === 'root') {\n    parentNode = clonedGraph as ElkGraphNode; // The cloned graph IS the root node\n  } else {\n    const foundParent = findNodeById(clonedGraph, parentId);\n    if (!foundParent) {\n      notFound(\"node\", parentId);\n      throw new Error(`Parent node '${parentId}' not found`);\n    }\n    parentNode = foundParent;\n  }\n\n  \n  // Ensure parent has a children array\n  if (!parentNode.children) {\n    parentNode.children = [];\n  }\n  \n  // Create the new node - using createNodeID to maintain ID creation consistency\n  const newNode: ElkGraphNode = {\n    id: normalizedId,\n    labels: [{ text: data?.label || nodeName }],\n    children: []\n  };\n  \n  // Add optional data properties\n  if (data) {\n    // Process style if it's a string reference\n    if (data.style && typeof data.style === 'string') {\n      data = {\n        ...data,\n        style: getStyle(data.style)\n      };\n    }\n    \n    newNode.data = {\n      ...newNode.data,\n      ...data\n    };\n  }\n  \n  // Add to parent\n  parentNode.children.push(newNode);\n  \n  return clonedGraph;\n}",
    "start_line": 279,
    "end_line": 341,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeName",
      "parentId",
      "graph",
      "data"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addNode",
    "component_id": "client.components.graph.mutations.addNode"
  },
  "client.components.graph.mutations.deleteNode": {
    "id": "client.components.graph.mutations.deleteNode",
    "name": "deleteNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.mutations.collectNodeIds",
      "client.components.graph.mutations.purgeEdgesReferencing",
      "client.components.graph.mutations.findParentOfNode",
      "client.components.graph.mutations.notFound"
    ],
    "source_code": "deleteNode = (nodeId: NodeID, graph: RawGraph): RawGraph => {\n  \n  // First, find and remove the node from its parent\n  const parent = findParentOfNode(graph, nodeId);\n  if (!parent || !parent.children) {\n    notFound(\"node\", nodeId);\n    throw new Error(`Node '${nodeId}' not found or trying to remove root`);\n  }\n\n  // 1. locate\n  const doomed = parent.children.find(c => c.id === nodeId)!;\n  \n  // 2. remove from parent\n  parent.children = parent.children.filter(c => c !== doomed);\n  \n  // 3. purge every edge that pointed to it or descendants\n  purgeEdgesReferencing(graph, collectNodeIds(doomed));\n  \n  return graph;\n}",
    "start_line": 346,
    "end_line": 365,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function deleteNode",
    "component_id": "client.components.graph.mutations.deleteNode"
  },
  "client.components.graph.mutations.moveNode": {
    "id": "client.components.graph.mutations.moveNode",
    "name": "moveNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.mutations.isDescendantOf",
      "client.components.graph.mutations.reattachEdgesForSubtree",
      "client.components.graph.mutations.findNodeById",
      "client.components.graph.mutations.notFound",
      "client.components.graph.mutations.findParentOfNode"
    ],
    "source_code": "moveNode = (nodeId: NodeID, newParentId: NodeID, graph: RawGraph): RawGraph => {\n  \n  const node = findNodeById(graph, nodeId);\n  const newParent = findNodeById(graph, newParentId);\n  \n  if (!node) {\n    notFound(\"node\", nodeId);\n    throw new Error(`Node '${nodeId}' not found`);\n  }\n  \n  if (!newParent) {\n    notFound(\"node\", newParentId);\n    throw new Error(`New parent node '${newParentId}' not found`);\n  }\n  \n  // 1. forbid moving into own descendant (cycle)\n  if (isDescendantOf(node, newParent)) {\n    throw new Error(`Cannot move '${nodeId}' into its own descendant '${newParentId}'`);\n  }\n\n  // 2. forbid ID collision among siblings (already ensured but cheap to keep)\n  if (newParent.children?.some(c => c.id === nodeId)) {\n    throw new Error(`'${newParentId}' already contains a child with id '${nodeId}'`);\n  }\n  \n  const oldParent = findParentOfNode(graph, nodeId);\n  if (!oldParent || !oldParent.children) {\n    throw new Error(`Node '${nodeId}' not found in any parent`);\n  }\n  \n  // Remove the node from its old parent\n  oldParent.children = oldParent.children.filter(child => child.id !== nodeId);\n  \n  // Add the node to the new parent\n  if (!newParent.children) newParent.children = [];\n  newParent.children.push(node);\n  \n  // Update edge connections - this is the key improvement\n  // const updatedGraph = updateEdgesForNode(nodeId, graph);\n  reattachEdgesForSubtree(node, graph);\n  \n  return graph;\n}",
    "start_line": 370,
    "end_line": 412,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "newParentId",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function moveNode",
    "component_id": "client.components.graph.mutations.moveNode"
  },
  "client.components.graph.mutations.addEdge": {
    "id": "client.components.graph.mutations.addEdge",
    "name": "addEdge",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.addEdgeInternal",
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.types.graph.EdgeID"
    ],
    "source_code": "addEdge = (edgeId: EdgeID, sourceId: NodeID, targetId: NodeID, labelOrGraph?: string | RawGraph, sourceHandle?: string, targetHandle?: string, graph?: RawGraph): RawGraph => {\n  // Detect if graph was passed as 4th parameter (backward compatibility)\n  // If 4th param is an object with 'id' property, it's a graph, not a label\n  if (labelOrGraph && typeof labelOrGraph === 'object' && 'id' in labelOrGraph) {\n    // Old signature: (edgeId, sourceId, targetId, graph, label?, sourceHandle?, targetHandle?)\n    const actualGraph = labelOrGraph as RawGraph;\n    const actualLabel = sourceHandle as string | undefined; // Shifted params\n    const actualSourceHandle = targetHandle;\n    const actualTargetHandle = graph as unknown as string | undefined;\n    return addEdgeInternal(edgeId, sourceId, targetId, actualGraph, actualLabel, actualSourceHandle, actualTargetHandle);\n  }\n  // New signature: graph is last parameter (from mutate function)\n  // (edgeId, sourceId, targetId, label?, sourceHandle?, targetHandle?, graph)\n  if (!graph) {\n    throw new Error('Graph parameter is required');\n  }\n  const actualLabel = typeof labelOrGraph === 'string' ? labelOrGraph : undefined;\n  return addEdgeInternal(edgeId, sourceId, targetId, graph, actualLabel, sourceHandle, targetHandle);\n}",
    "start_line": 421,
    "end_line": 439,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edgeId",
      "sourceId",
      "targetId",
      "labelOrGraph",
      "sourceHandle",
      "targetHandle",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addEdge",
    "component_id": "client.components.graph.mutations.addEdge"
  },
  "client.components.graph.mutations.addEdgeInternal": {
    "id": "client.components.graph.mutations.addEdgeInternal",
    "name": "addEdgeInternal",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.types.graph.ElkGraphEdge",
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.types.graph.EdgeID",
      "client.components.graph.mutations.edgeIdExists",
      "scripts.test-vercel-preview.error",
      "client.components.graph.mutations.findCommonAncestor"
    ],
    "source_code": "addEdgeInternal = (edgeId: EdgeID, sourceId: NodeID, targetId: NodeID, graph: RawGraph, label?: string, sourceHandle?: string, targetHandle?: string): RawGraph => {\n  console.log('üîß [addEdgeInternal] Called:', { edgeId, sourceId, targetId, label, sourceHandle, targetHandle });\n  \n  // Clone the graph to ensure React detects the state change\n  const clonedGraph = structuredClone(graph);\n  console.log('‚úÖ [addEdgeInternal] Cloned graph, original edges:', graph.edges?.length || 0, 'cloned edges:', clonedGraph.edges?.length || 0);\n  \n  // duplicate-ID check\n  if (edgeIdExists(clonedGraph, edgeId)) {\n    console.error('‚ùå [addEdgeInternal] Edge ID already exists:', edgeId);\n    throw new Error(`Edge id '${edgeId}' already exists`);\n  }\n  console.log('‚úÖ [addEdgeInternal] Edge ID does not exist, proceeding');\n  \n  // self-loop guard\n  if (sourceId === targetId) {\n    console.error('‚ùå [addEdgeInternal] Self-loop detected:', sourceId);\n    throw new Error(`Self-loop edges are not supported (source === target '${sourceId}')`);\n  }\n  \n  // Find the common ancestor for edge placement\n  let commonAncestor = findCommonAncestor(clonedGraph, sourceId, targetId);\n  console.log('üîç [addEdgeInternal] Common ancestor:', commonAncestor ? { id: commonAncestor.id, hasEdges: !!commonAncestor.edges } : 'null');\n  \n  // If no common ancestor found, or it's null, default to root\n  if (!commonAncestor) {\n    console.log('‚ö†Ô∏è [addEdgeInternal] No common ancestor found, attaching to root');\n    // No common ancestor found, attach to root node instead\n    const root = clonedGraph;\n    \n    // Create the edge\n    const newEdge: ElkGraphEdge = {\n      id: edgeId,\n      sources: [sourceId],\n      targets: [targetId]\n    };\n    \n    // Store handle IDs if provided (for connector handles)\n    if (sourceHandle || targetHandle) {\n      newEdge.data = {\n        sourceHandle,\n        targetHandle\n      };\n      console.log('‚úÖ [addEdgeInternal] Added handle IDs to edge:', { sourceHandle, targetHandle });\n    }\n    \n    // Add label if provided\n    if (label) {\n      newEdge.labels = [{ text: label }];\n    }\n    \n    // Ensure the root has edges array\n    if (!root.edges) {\n      root.edges = [];\n      console.log('üìù [addEdgeInternal] Created edges array on root');\n    }\n    \n    // Add the edge to the root\n    root.edges.push(newEdge);\n    console.log('‚úÖ [addEdgeInternal] Added edge to root, root now has', root.edges.length, 'edges');\n    \n    return clonedGraph;\n  }\n  \n  // Create the edge\n  const newEdge: ElkGraphEdge = {\n    id: edgeId,\n    sources: [sourceId],\n    targets: [targetId]\n  };\n  \n  // Store handle IDs if provided (for connector handles)\n  if (sourceHandle || targetHandle) {\n    newEdge.data = {\n      sourceHandle,\n      targetHandle\n    };\n    console.log('‚úÖ [addEdgeInternal] Added handle IDs to edge:', { sourceHandle, targetHandle });\n  }\n  \n  // Add label if provided\n  if (label) {\n    newEdge.labels = [{ text: label }];\n  }\n  \n  // Ensure the common ancestor has edges array\n  if (!commonAncestor.edges) {\n    commonAncestor.edges = [];\n    console.log('üìù [addEdgeInternal] Created edges array on common ancestor');\n  }\n  \n  // Add the edge to the common ancestor\n  commonAncestor.edges.push(newEdge);\n  console.log('‚úÖ [addEdgeInternal] Added edge to common ancestor, ancestor now has', commonAncestor.edges.length, 'edges');\n  \n  return clonedGraph;\n}",
    "start_line": 444,
    "end_line": 540,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edgeId",
      "sourceId",
      "targetId",
      "graph",
      "label",
      "sourceHandle",
      "targetHandle"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addEdgeInternal",
    "component_id": "client.components.graph.mutations.addEdgeInternal"
  },
  "client.components.graph.mutations.deleteEdge": {
    "id": "client.components.graph.mutations.deleteEdge",
    "name": "deleteEdge",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.EdgeID",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.mutations.notFound",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "deleteEdge = (edgeId: EdgeID, graph: RawGraph): RawGraph => {\n  \n  let edgeFound = false;\n  \n  function removeEdge(node: ElkGraphNode): void {\n    if (node.edges) {\n      const initialLength = node.edges.length;\n      node.edges = node.edges.filter(edge => edge.id !== edgeId);\n      if (node.edges.length < initialLength) {\n        edgeFound = true;\n      }\n    }\n    if (node.children) {\n      for (const child of node.children) {\n        removeEdge(child);\n      }\n    }\n  }\n  \n  removeEdge(graph);\n  \n  if (!edgeFound) {\n    notFound(\"edge\", edgeId);\n    throw new Error(`Edge '${edgeId}' not found`);\n  }\n  \n  console.timeEnd(\"deleteEdge\");\n  console.groupEnd();\n  return graph;\n}",
    "start_line": 545,
    "end_line": 574,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edgeId",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function deleteEdge",
    "component_id": "client.components.graph.mutations.deleteEdge"
  },
  "client.components.graph.mutations.groupNodes": {
    "id": "client.components.graph.mutations.groupNodes",
    "name": "groupNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.styles.getStyle",
      "client.types.graph.ElkGraphNode",
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.mutations.isDescendantOf",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.types.graph.createNodeID",
      "client.components.graph.mutations.reattachEdgesForSubtree",
      "client.components.graph.mutations.findNodeById",
      "client.components.graph.mutations.notFound",
      "client.components.graph.mutations.findParentOfNode"
    ],
    "source_code": "groupNodes = (nodeIds: NodeID[], parentId: NodeID, groupId: NodeID, graph: RawGraph, style?: any): RawGraph => {\n  console.group(`[mutation] groupNodes '${groupId}' (${nodeIds.length} nodes) ‚Üí parent '${parentId}'${style ? ' with style' : ''}`);\n  console.time(\"groupNodes\");\n  \n  // Check for duplicate ID using normalized group ID\n  const normalizedGroupId = createNodeID(groupId);\n  if (findNodeById(graph, normalizedGroupId)) {\n    throw new Error(`duplicate group id '${normalizedGroupId}'`);\n  }\n  \n  const parent = findNodeById(graph, parentId);\n  if (!parent || !parent.children) {\n    notFound(\"node\", parentId);\n    throw new Error(`Parent node '${parentId}' not found`);\n  }\n\n  // Prevent cycles: check if any node being grouped is a descendant of the parent or is the parent itself\n  for (const id of nodeIds) {\n    const cand = findNodeById(graph, id)!;\n    if (isDescendantOf(cand, parent) || cand.id === parentId) {\n      throw new Error(\"Cannot group a node into one of its descendants (cycle)\");\n    }\n  }\n  \n  const groupNode: ElkGraphNode = {\n    id: normalizedGroupId,\n    labels: [{ text: groupId }],\n    children: [],\n    edges: []\n  };\n  \n  // Add style data if provided\n  if (style) {\n    // Use the getStyle helper to resolve string style names to actual style objects\n    const resolvedStyle = getStyle(style);\n    groupNode.data = {\n      ...groupNode.data,\n      label: groupId,\n      style: resolvedStyle\n    };\n  } else {\n    // Default data with group icon\n    groupNode.data = {\n      label: groupId,\n      groupIcon: 'gcp_system' // Default group icon\n    };\n  }\n  \n  // Track which nodes are actually moved to update their edges later\n  const movedNodeIds: NodeID[] = [];\n  \n  // Find and move the specified nodes into the new group\n  for (const nodeId of nodeIds) {\n    // Find the node and its actual parent (which may not be the specified parent)\n    const node = findNodeById(graph, nodeId);\n    if (!node) {\n      notFound(\"node\", nodeId);\n      continue;\n    }\n    \n    const actualParent = findParentOfNode(graph, nodeId);\n    if (!actualParent || !actualParent.children) {\n      console.warn(`Parent of node ${nodeId} not found`);\n      continue;\n    }\n    \n    // Remove the node from its actual parent\n    actualParent.children = actualParent.children.filter(child => child.id !== nodeId);\n    \n    // Add the node to the group\n    if (!groupNode.children) groupNode.children = [];\n    groupNode.children.push(node);\n    movedNodeIds.push(nodeId);\n  }\n  \n  // Only add the group if it has children\n  if (groupNode.children && groupNode.children.length > 0) {\n    parent.children.push(groupNode);\n    \n    // Update edges for all moved nodes and their descendants\n    movedNodeIds\n      .map(id => findNodeById(graph, id)!)\n      .forEach(subRoot => reattachEdgesForSubtree(subRoot, graph));\n  } else {\n    console.warn(`No nodes were moved to group ${groupId}`);\n  }\n  \n  \n  console.timeEnd(\"groupNodes\");\n  console.groupEnd();\n  return graph;\n}",
    "start_line": 584,
    "end_line": 675,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeIds",
      "parentId",
      "groupId",
      "graph",
      "style"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function groupNodes",
    "component_id": "client.components.graph.mutations.groupNodes"
  },
  "client.components.graph.mutations.removeGroup": {
    "id": "client.components.graph.mutations.removeGroup",
    "name": "removeGroup",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.mutations.findNodeById",
      "client.components.graph.mutations.purgeEdgesReferencing",
      "client.components.graph.mutations.findParentOfNode",
      "client.components.graph.mutations.moveNode"
    ],
    "source_code": "removeGroup = (groupId: NodeID, graph: RawGraph): RawGraph => {\n  console.group(`[mutation] removeGroup '${groupId}'`);\n  console.time(\"removeGroup\");\n\n  /* locate group & parent ------------------------------------------------ */\n  const groupNode  = findNodeById(graph, groupId);\n  if (!groupNode)          throw new Error(`Group '${groupId}' not found`);\n  const parentNode = findParentOfNode(graph, groupId);\n  if (!parentNode || !parentNode.children)\n    throw new Error(`Group '${groupId}' has no parent (maybe root?)`);\n\n  /* 1. hoist every child with the *existing* moveNode -------------------- */\n  const childIds = (groupNode.children ?? []).map(c => c.id);\n  for (const cid of childIds) moveNode(cid, parentNode.id, graph);\n\n  /* 2. relocate the group's own edges straight into the parent ----------- */\n  if (groupNode.edges?.length) {\n    parentNode.edges = parentNode.edges ?? [];\n    parentNode.edges.push(...groupNode.edges);\n  }\n\n  /* 3. finally remove the empty group container -------------------------- */\n  parentNode.children = parentNode.children.filter(c => c.id !== groupId);\n\n  /* 4. scrub edges that pointed *to* the deleted group itself ------------ */\n  purgeEdgesReferencing(graph, new Set<NodeID>([groupId]));\n\n  console.timeEnd(\"removeGroup\");\n  console.groupEnd();\n  return graph;\n}",
    "start_line": 681,
    "end_line": 711,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "groupId",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function removeGroup",
    "component_id": "client.components.graph.mutations.removeGroup"
  },
  "client.components.graph.mutations.createWrapperSection": {
    "id": "client.components.graph.mutations.createWrapperSection",
    "name": "createWrapperSection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.types.graph.ElkGraphNode",
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.types.graph.createNodeID",
      "client.components.graph.mutations.findLCG",
      "client.components.graph.mutations.reattachEdgesForSubtree",
      "client.components.graph.mutations.findNodeById",
      "client.components.graph.mutations.findParentOfNode"
    ],
    "source_code": "createWrapperSection = (\n  selectionIds: NodeID[], \n  graph: RawGraph\n): { graph: RawGraph; wrapperId: NodeID } => {\n  if (!graph) {\n    throw new Error('Cannot create wrapper section: graph is null or undefined');\n  }\n  \n  if (selectionIds.length === 0) {\n    throw new Error('Cannot create wrapper section: no nodes selected');\n  }\n  \n  // 1. Find LCG of selection\n  const lcg = findLCG(graph, selectionIds);\n  if (!lcg) {\n    throw new Error('Cannot create wrapper section: no common ancestor found');\n  }\n  \n  // 2. Create wrapper ID\n  const wrapperId = createNodeID(`wrapper-${Date.now()}`);\n  \n  // 3. Create wrapper group node (always FREE mode)\n  const wrapperNode: ElkGraphNode = {\n    id: wrapperId,\n    labels: [{ text: 'Wrapper Section' }],\n    children: [],\n    edges: [],\n    // Phase 3: No longer write mode to Domain - mode will be set in ViewState.layout\n    data: {\n      label: 'Wrapper Section',\n      isGroup: true,\n      groupIcon: 'gcp_system'\n    }\n  };\n  \n  // 4. Deep clone graph to avoid mutations\n  const updatedGraph = JSON.parse(JSON.stringify(graph));\n  const updatedLcg = findNodeById(updatedGraph, lcg.id);\n  if (!updatedLcg || !updatedLcg.children) {\n    throw new Error(`LCG \"${lcg.id}\" not found in updated graph`);\n  }\n  \n  // 5. Find and move selected nodes into wrapper (reparent only explicit selection)\n  const movedNodeIds: NodeID[] = [];\n  \n  for (const nodeId of selectionIds) {\n    const node = findNodeById(updatedGraph, nodeId);\n    if (!node) {\n      console.warn(`[createWrapperSection] Node \"${nodeId}\" not found, skipping`);\n      continue;\n    }\n    \n    // Find actual parent and remove from parent\n    const actualParent = findParentOfNode(updatedGraph, nodeId);\n    if (actualParent && actualParent.children) {\n      actualParent.children = actualParent.children.filter(child => child.id !== nodeId);\n      \n      // Add to wrapper\n      if (!wrapperNode.children) wrapperNode.children = [];\n      wrapperNode.children.push(node);\n      movedNodeIds.push(nodeId);\n    }\n  }\n  \n  if (movedNodeIds.length === 0) {\n    throw new Error('No nodes were successfully moved to wrapper section');\n  }\n  \n  // 6. Add wrapper to LCG\n  updatedLcg.children.push(wrapperNode);\n  \n  // 7. Reattach edges for moved subtrees\n  if (movedNodeIds.length > 0) {\n    movedNodeIds\n      .map(id => findNodeById(updatedGraph, id)!)\n      .forEach(subRoot => reattachEdgesForSubtree(subRoot, updatedGraph));\n  }\n  \n  return { graph: updatedGraph, wrapperId };\n}",
    "start_line": 723,
    "end_line": 802,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "selectionIds",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function createWrapperSection",
    "component_id": "client.components.graph.mutations.createWrapperSection"
  },
  "client.components.graph.mutations.batchUpdate": {
    "id": "client.components.graph.mutations.batchUpdate",
    "name": "batchUpdate",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/mutations.ts",
    "relative_path": "client/components/graph/mutations.ts",
    "depends_on": [
      "client.components.graph.mutations.addEdge",
      "client.components.graph.mutations.removeGroup",
      "client.types.graph.NodeID",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.types.graph.EdgeID",
      "client.components.graph.mutations.deleteEdge",
      "client.components.graph.mutations.deleteNode",
      "client.components.graph.mutations.addNode",
      "client.components.graph.mutations.groupNodes",
      "client.components.graph.mutations.moveNode"
    ],
    "source_code": "batchUpdate = (operations: Array<{\n  name: string;\n  nodename?: string;\n  parentId?: NodeID;\n  nodeId?: NodeID;\n  newParentId?: NodeID;\n  edgeId?: EdgeID;\n  sourceId?: NodeID;\n  targetId?: NodeID;\n  nodeIds?: NodeID[];\n  groupId?: NodeID;\n  data?: { label?: string; icon?: string; style?: any };\n  label?: string;\n  style?: any;\n}>, graph: RawGraph) => {\n  // console.group(`[mutation] batchUpdate (${operations.length} operations)`);\n  // console.time(\"batchUpdate\");\n  \n  let updatedGraph = { ...graph };\n  \n  for (const operation of operations) {\n    const { name, ...args } = operation;\n    \n    // console.log(`üîç Processing batch operation '${name}' with args:`, args);\n    \n    switch (name) {\n      case \"add_node\":\n        if (!args.nodename || typeof args.nodename !== 'string') {\n          throw new Error(`add_node requires 'nodename' as a string, got: ${JSON.stringify(args.nodename)}`);\n        }\n        // Default parentId to \"root\" if not provided\n        const parentId = args.parentId || \"root\";\n        if (typeof parentId !== 'string') {\n          throw new Error(`add_node requires 'parentId' as a string, got: ${JSON.stringify(args.parentId)}`);\n        }\n        updatedGraph = addNode(args.nodename, parentId, updatedGraph, args.data);\n        break;\n        \n      case \"delete_node\":\n        if (!args.nodeId || typeof args.nodeId !== 'string') {\n          throw new Error(`delete_node requires 'nodeId' as a string, got: ${JSON.stringify(args.nodeId)}`);\n        }\n        updatedGraph = deleteNode(args.nodeId, updatedGraph);\n        break;\n        \n      case \"move_node\":\n        if (!args.nodeId || typeof args.nodeId !== 'string') {\n          throw new Error(`move_node requires 'nodeId' as a string, got: ${JSON.stringify(args.nodeId)}`);\n        }\n        if (!args.newParentId || typeof args.newParentId !== 'string') {\n          throw new Error(`move_node requires 'newParentId' as a string, got: ${JSON.stringify(args.newParentId)}`);\n        }\n        updatedGraph = moveNode(args.nodeId, args.newParentId, updatedGraph);\n        break;\n        \n      case \"add_edge\":\n        if (!args.edgeId || typeof args.edgeId !== 'string') {\n          throw new Error(`add_edge requires 'edgeId' as a string, got: ${JSON.stringify(args.edgeId)}`);\n        }\n        if (!args.sourceId || typeof args.sourceId !== 'string') {\n          throw new Error(`add_edge requires 'sourceId' as a string, got: ${JSON.stringify(args.sourceId)}`);\n        }\n        if (!args.targetId || typeof args.targetId !== 'string') {\n          throw new Error(`add_edge requires 'targetId' as a string, got: ${JSON.stringify(args.targetId)}`);\n        }\n        updatedGraph = addEdge(args.edgeId, args.sourceId, args.targetId, args.label, undefined, undefined, updatedGraph);\n        break;\n        \n      case \"delete_edge\":\n        if (!args.edgeId || typeof args.edgeId !== 'string') {\n          throw new Error(`delete_edge requires 'edgeId' as a string, got: ${JSON.stringify(args.edgeId)}`);\n        }\n        updatedGraph = deleteEdge(args.edgeId, updatedGraph);\n        break;\n        \n      case \"group_nodes\":\n        if (!args.nodeIds || !Array.isArray(args.nodeIds) || args.nodeIds.length === 0) {\n          throw new Error(`group_nodes requires 'nodeIds' as a non-empty array, got: ${JSON.stringify(args.nodeIds)}`);\n        }\n        if (!args.parentId || typeof args.parentId !== 'string') {\n          throw new Error(`group_nodes requires 'parentId' as a string, got: ${JSON.stringify(args.parentId)}`);\n        }\n        if (!args.groupId || typeof args.groupId !== 'string') {\n          throw new Error(`group_nodes requires 'groupId' as a string, got: ${JSON.stringify(args.groupId)}`);\n        }\n        updatedGraph = groupNodes(args.nodeIds, args.parentId, args.groupId, updatedGraph, args.style || args.data?.style);\n        break;\n        \n      case \"remove_group\":\n        if (!args.groupId || typeof args.groupId !== 'string') {\n          throw new Error(`remove_group requires 'groupId' as a string, got: ${JSON.stringify(args.groupId)}`);\n        }\n        updatedGraph = removeGroup(args.groupId, updatedGraph);\n        break;\n        \n      default:\n        console.warn(`Unknown operation: ${name}`);\n    }\n  }\n  \n  // console.timeEnd(\"batchUpdate\");\n  // console.groupEnd();\n  return updatedGraph;\n}",
    "start_line": 807,
    "end_line": 910,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operations",
      "graph"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function batchUpdate",
    "component_id": "client.components.graph.mutations.batchUpdate"
  },
  "client.components.graph.styles.canvasStyles.getEdgeStyle": {
    "id": "client.components.graph.styles.canvasStyles.getEdgeStyle",
    "name": "getEdgeStyle",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/styles/canvasStyles.ts",
    "relative_path": "client/components/graph/styles/canvasStyles.ts",
    "depends_on": [],
    "source_code": "getEdgeStyle = (isSelected: boolean, isConnected: boolean) => ({\n  ...CANVAS_STYLES.edges.default,\n  ...(isSelected && CANVAS_STYLES.edges.selected),\n  ...(isConnected && {\n    stroke: CANVAS_STYLES.edges.connected.stroke,\n    strokeWidth: CANVAS_STYLES.edges.connected.strokeWidth,\n  }),\n})",
    "start_line": 81,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "isSelected",
      "isConnected"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function getEdgeStyle",
    "component_id": "client.components.graph.styles.canvasStyles.getEdgeStyle"
  },
  "client.components.graph.styles.canvasStyles.getEdgeZIndex": {
    "id": "client.components.graph.styles.canvasStyles.getEdgeZIndex",
    "name": "getEdgeZIndex",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/styles/canvasStyles.ts",
    "relative_path": "client/components/graph/styles/canvasStyles.ts",
    "depends_on": [],
    "source_code": "getEdgeZIndex = (isSelected: boolean) => \n  isSelected ? CANVAS_STYLES.zIndex.selectedEdges : CANVAS_STYLES.zIndex.edges",
    "start_line": 90,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "isSelected"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function getEdgeZIndex",
    "component_id": "client.components.graph.styles.canvasStyles.getEdgeZIndex"
  },
  "client.components.graph.styles.getStyle": {
    "id": "client.components.graph.styles.getStyle",
    "name": "getStyle",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/styles.ts",
    "relative_path": "client/components/graph/styles.ts",
    "depends_on": [],
    "source_code": "getStyle = (styleInput: string | any): { bg: string, border: string } => {\n  if (typeof styleInput === 'string' && styleInput in STYLES) {\n    return STYLES[styleInput as keyof typeof STYLES];\n  }\n  \n  // If it's already a style object with bg and border, return it\n  if (styleInput && typeof styleInput === 'object' && 'bg' in styleInput && 'border' in styleInput) {\n    return styleInput;\n  }\n  \n  // Default fallback\n  return STYLES.GREY;\n}",
    "start_line": 12,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "styleInput"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function getStyle",
    "component_id": "client.components.graph.styles.getStyle"
  },
  "client.components.graph.types.index.RawGraph": {
    "id": "client.components.graph.types.index.RawGraph",
    "name": "RawGraph",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types/index.ts",
    "relative_path": "client/components/graph/types/index.ts",
    "depends_on": [],
    "source_code": "interface RawGraph extends _ElkGraph {}",
    "start_line": 4,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface RawGraph",
    "component_id": "client.components.graph.types.index.RawGraph"
  },
  "client.components.graph.types.index.LayoutGraph": {
    "id": "client.components.graph.types.index.LayoutGraph",
    "name": "LayoutGraph",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types/index.ts",
    "relative_path": "client/components/graph/types/index.ts",
    "depends_on": [],
    "source_code": "interface LayoutGraph extends _ElkGraph {}",
    "start_line": 5,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LayoutGraph",
    "component_id": "client.components.graph.types.index.LayoutGraph"
  },
  "client.components.graph.types.CustomNode": {
    "id": "client.components.graph.types.CustomNode",
    "name": "CustomNode",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [],
    "source_code": "interface CustomNode extends Node {\n  parentId?: string;\n}",
    "start_line": 3,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CustomNode",
    "component_id": "client.components.graph.types.CustomNode"
  },
  "client.components.graph.types.NodeID": {
    "id": "client.components.graph.types.NodeID",
    "name": "NodeID",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [],
    "source_code": "type NodeID = string & { __brand: \"NodeID\" };",
    "start_line": 8,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type NodeID",
    "component_id": "client.components.graph.types.NodeID"
  },
  "client.components.graph.types.EdgeID": {
    "id": "client.components.graph.types.EdgeID",
    "name": "EdgeID",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [],
    "source_code": "type EdgeID = string & { __brand: \"EdgeID\" };",
    "start_line": 9,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EdgeID",
    "component_id": "client.components.graph.types.EdgeID"
  },
  "client.components.graph.types.createNodeID": {
    "id": "client.components.graph.types.createNodeID",
    "name": "createNodeID",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [
      "client.components.graph.types.NodeID"
    ],
    "source_code": "function createNodeID(id: string): NodeID {\n  return id as NodeID;\n}",
    "start_line": 12,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createNodeID",
    "component_id": "client.components.graph.types.createNodeID"
  },
  "client.components.graph.types.createEdgeID": {
    "id": "client.components.graph.types.createEdgeID",
    "name": "createEdgeID",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [
      "client.components.graph.types.EdgeID"
    ],
    "source_code": "function createEdgeID(id: string): EdgeID {\n  return id as EdgeID;\n}",
    "start_line": 16,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createEdgeID",
    "component_id": "client.components.graph.types.createEdgeID"
  },
  "client.components.graph.types.NodeData": {
    "id": "client.components.graph.types.NodeData",
    "name": "NodeData",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [],
    "source_code": "interface NodeData {\n  label: string;\n  width?: number;\n  height?: number;\n  isParent?: boolean;\n  leftHandles?: string[];\n  rightHandles?: string[];\n  position?: { x: number; y: number };\n}",
    "start_line": 20,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeData",
    "component_id": "client.components.graph.types.NodeData"
  },
  "client.components.graph.types.EdgeData": {
    "id": "client.components.graph.types.EdgeData",
    "name": "EdgeData",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [],
    "source_code": "interface EdgeData {\n  bendPoints?: { x: number; y: number }[];\n}",
    "start_line": 30,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeData",
    "component_id": "client.components.graph.types.EdgeData"
  },
  "client.components.graph.types.ElkGraphNode": {
    "id": "client.components.graph.types.ElkGraphNode",
    "name": "ElkGraphNode",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [
      "client.components.graph.types.NodeID",
      "client.components.graph.types.ElkGraphNode",
      "client.components.graph.types.ElkGraphEdge"
    ],
    "source_code": "interface ElkGraphNode {\n  id: NodeID;\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  labels?: { text: string }[];\n  children?: ElkGraphNode[];\n  edges?: ElkGraphEdge[];\n  layoutOptions?: Record<string, any>;\n  container?: NodeID;\n  absoluteBendPoints?: Array<{\n    index: number;\n    x: number;\n    y: number;\n    originalX: number;\n    originalY: number;\n  }>;\n}",
    "start_line": 34,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkGraphNode",
    "component_id": "client.components.graph.types.ElkGraphNode"
  },
  "client.components.graph.types.ElkGraphEdge": {
    "id": "client.components.graph.types.ElkGraphEdge",
    "name": "ElkGraphEdge",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [
      "client.components.graph.types.NodeID",
      "client.components.graph.types.EdgeID"
    ],
    "source_code": "interface ElkGraphEdge {\n  id: EdgeID;\n  sources: NodeID[];\n  targets: NodeID[];\n  sections?: {\n    startPoint: { x: number; y: number };\n    endPoint: { x: number; y: number };\n    bendPoints?: { x: number; y: number }[];\n  }[];\n  container?: NodeID;\n  absoluteBendPoints?: Array<{\n    index: number;\n    x: number;\n    y: number;\n    originalX: number;\n    originalY: number;\n  }>;\n  // Store handle IDs for connector handles (bypasses connection point lookup)\n  data?: {\n    sourceHandle?: string;\n    targetHandle?: string;\n  };\n}",
    "start_line": 54,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkGraphEdge",
    "component_id": "client.components.graph.types.ElkGraphEdge"
  },
  "client.components.graph.types.ElkGraph": {
    "id": "client.components.graph.types.ElkGraph",
    "name": "ElkGraph",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [
      "client.components.graph.types.NodeID",
      "client.components.graph.types.ElkGraphNode",
      "client.components.graph.types.ElkGraphEdge"
    ],
    "source_code": "interface ElkGraph {\n  id: NodeID;\n  children?: ElkGraphNode[];\n  edges?: ElkGraphEdge[];\n  layoutOptions?: Record<string, any>;\n}",
    "start_line": 78,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkGraph",
    "component_id": "client.components.graph.types.ElkGraph"
  },
  "client.components.graph.types.InputAudioTranscription": {
    "id": "client.components.graph.types.InputAudioTranscription",
    "name": "InputAudioTranscription",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/types.ts",
    "relative_path": "client/components/graph/types.ts",
    "depends_on": [],
    "source_code": "interface InputAudioTranscription {\n  /**\n   * The language of the input audio. Supplying the input language in ISO-639-1 (e.g. en) \n   * format will improve accuracy and latency.\n   */\n  language?: string;\n  \n  /**\n   * The model to use for transcription, current options are gpt-4o-transcribe, \n   * gpt-4o-mini-transcribe, and whisper-1.\n   */\n  model?: string;\n  \n  /**\n   * An optional text to guide the model's style or continue a previous audio segment. \n   * For whisper-1, the prompt is a list of keywords. For gpt-4o-transcribe models, \n   * the prompt is a free text string, for example \"expect words related to technology\".\n   */\n  prompt?: string;\n}",
    "start_line": 85,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InputAudioTranscription",
    "component_id": "client.components.graph.types.InputAudioTranscription"
  },
  "client.components.graph.userRequirements.process_user_requirements": {
    "id": "client.components.graph.userRequirements.process_user_requirements",
    "name": "process_user_requirements",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/userRequirements.ts",
    "relative_path": "client/components/graph/userRequirements.ts",
    "depends_on": [
      "client.utils.chatUtils.addReasoningMessage",
      "scripts.test-vercel-preview.log",
      "client.utils.chatUtils.updateStreamingMessage",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.chatUtils.makeChatVisible",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function process_user_requirements() {\n    console.log('üöÄ process_user_requirements: FUNCTION CALLED!');\n    \n    // Signal that processing has started for the status icon\n    window.dispatchEvent(new CustomEvent('userRequirementsStart'));\n    \n    console.log('üì§ Dispatched userRequirementsStart event');\n    addReasoningMessage(\"‚ö° Processing your request...\");\n    console.log('üí¨ Added reasoning message');\n    makeChatVisible();\n    console.log('üëÅÔ∏è Made chat visible');\n  \n  // START PERFORMANCE TIMING\n  const processStart = performance.now();\n\n  \n\n  \n  try {\n    // Get the current text input\n    const currentTextInput = (window as any).chatTextInput || '';\n    console.log('üìù Current text input from global state:', currentTextInput);\n    \n    // Handle empty input\n    if (!currentTextInput.trim()) {\n      console.warn('‚ö†Ô∏è No text input provided');\n      return;\n    }\n    \n    console.log('‚úÖ Text input validation passed, proceeding with:', currentTextInput.trim());\n    \n    // Clear any previous conversation data to start fresh\n    (window as any).chatConversationData = \"\";\n    \n    // Store current input globally for processing\n    (window as any).chatTextInput = currentTextInput;\n    \n    const dataCollectionTime = performance.now();\n    console.log('‚è±Ô∏è Data collection time recorded:', dataCollectionTime);\n\n    \n    // Update the reasoning message to show progress\n    console.log('üìù Calling updateStreamingMessage...');\n    updateStreamingMessage(\n      null, // messageId will be found automatically\n      \"üîç Analyzing your requirements...\", \n      true, // isStreaming\n      null // currentFunction\n    );\n    console.log('‚úÖ updateStreamingMessage called successfully');\n    \n    // Get images from global state\n    const storedImages = (window as any).selectedImages || [];\n    console.log('üñºÔ∏è Retrieved stored images:', storedImages.length, 'images');\n    console.log('üñºÔ∏è Image data:', storedImages);\n    \n    // DEBUG: Check if images are being used\n    if (storedImages.length > 0) {\n      console.log('üì∏ DEBUG: Images found in process_user_requirements - will be included in architecture generation');\n    } else {\n      console.log('üì∏ DEBUG: No images found in process_user_requirements');\n    }\n\n          \n    // Build conversationData as formatted string\n    const conversationData = `USER: ${currentTextInput}\n\n${currentTextInput}`;\n    console.log('üí¨ Built conversation data:', conversationData.length, 'characters');\n    \n    const conversationPrepTime = performance.now();\n\n    \n    // Store globally for processing\n    (window as any).chatConversationData = conversationData;\n    console.log('üíæ Stored conversation data globally');\n\n    \n    // Notify that we're moving to architecture generation\n    console.log('üèóÔ∏è Updating message to \"Generating architecture...\"');\n    updateStreamingMessage(\n      null, // messageId will be found automatically\n      \"üèóÔ∏è Generating architecture...\", \n      true, // isStreaming  \n      null // currentFunction\n    );\n    \n    const setupCompleteTime = performance.now();\n    console.log('‚è±Ô∏è Setup complete time:', setupCompleteTime);\n\n    \n         // Get current graph state\n     const currentGraph = (window as any).getCurrentGraph?.() || { id: \"root\", children: [] };\n\n    \n     // Reasoning message tracking\n     let reasoningMessageId: string | null = null;\n     let reasoningContent = \"\";\n \n     // Function call message tracking  \n     const functionCallMessages = new Map<string, { messageId: string; content: string }>();\n     \n     // DISABLED: StreamExecutor creation - using simple agent instead\n         /*\n         const streamExecutor = new StreamExecutor({\n       elkGraph: currentGraph,\n       apiEndpoint: undefined, // Use default\n       setElkGraph: (newGraph: any) => {\n\n         const setGraphFunction = (window as any).setElkGraph;\n         if (setGraphFunction && typeof setGraphFunction === 'function') {\n           setGraphFunction(newGraph);\n         }\n       },\n      addLine: (message: string) => {\n\n      },\n      appendToTextLine: () => {}, // Suppress verbose text logging\n      appendToReasoningLine: (text: string) => {\n        reasoningContent += text;\n        updateStreamingMessage(\n          reasoningMessageId,\n          reasoningContent,\n          true,\n          null\n        );\n      },\n      appendToArgsLine: (text: string, itemId: string) => {\n        if (!functionCallMessages.has(itemId)) {\n          functionCallMessages.set(itemId, {\n            messageId: addFunctionCallingMessage(\"Processing...\"),\n            content: \"\"\n          });\n        }\n        \n        const callInfo = functionCallMessages.get(itemId)!;\n        callInfo.content += text;\n        \n        updateStreamingMessage(\n          callInfo.messageId,\n          callInfo.content,\n          true,\n          null\n        );\n      },\n      completeFunctionCall: (functionName: string, callId: string) => {\n\n          // Find and update the message to show completion\n          const callInfo = functionCallMessages.get(callId);\n          if (callInfo) {\n              updateStreamingMessage(callInfo.messageId, callInfo.content, true, functionName);\n          }\n          \n          // Remove the message from active function calls\n          functionCallMessages.delete(callId);\n          \n          // Graph is already updated by handleFunctionCall - no need to override it here\n      },\n      setBusy: (busy: boolean) => {\n\n      },\n      onComplete: () => {\n        const completeTime = performance.now();\n\n        \n        // Only add completion message if no active streaming\n        if (functionCallMessages.size === 0 && !reasoningMessageId) {\n          addProcessCompleteMessage();\n        }\n        \n        // Clear reasoning tracking\n        reasoningMessageId = null;\n        reasoningContent = \"\";\n        \n\n      }\n    });\n    */\n    \n    const executorSetupTime = performance.now();\n\n    \n\n    \n    // DISABLED: Old broken StreamExecutor - using new simple agent instead\n    // await streamExecutor.execute();\n    \n\n    \n  } catch (error) {\n    console.error('‚ùå Error in process_user_requirements:', error);\n    updateStreamingMessage(\n      null,\n      `‚ùå Error: ${error}`,\n      false,\n      null\n    );\n  }\n  \n  const processEnd = performance.now();\n\n}",
    "start_line": 3,
    "end_line": 204,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function process_user_requirements",
    "component_id": "client.components.graph.userRequirements.process_user_requirements"
  },
  "client.components.graph.utils.edgePoints.NodeEdgePoints": {
    "id": "client.components.graph.utils.edgePoints.NodeEdgePoints",
    "name": "NodeEdgePoints",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/edgePoints.ts",
    "relative_path": "client/components/graph/utils/edgePoints.ts",
    "depends_on": [],
    "source_code": "interface NodeEdgePoints { \n  left: any[]; \n  right: any[]; \n  top: any[]; \n  bottom: any[];\n  // Add index signature to allow dynamic access with string keys\n  [key: string]: any[];\n}",
    "start_line": 4,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeEdgePoints",
    "component_id": "client.components.graph.utils.edgePoints.NodeEdgePoints"
  },
  "client.components.graph.utils.edgePoints.EdgePointMap": {
    "id": "client.components.graph.utils.edgePoints.EdgePointMap",
    "name": "EdgePointMap",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/edgePoints.ts",
    "relative_path": "client/components/graph/utils/edgePoints.ts",
    "depends_on": [
      "client.components.graph.utils.edgePoints.NodeEdgePoints"
    ],
    "source_code": "type EdgePointMap = Record<string, NodeEdgePoints>;",
    "start_line": 12,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EdgePointMap",
    "component_id": "client.components.graph.utils.edgePoints.EdgePointMap"
  },
  "client.components.graph.utils.edgePoints.determineConnectionSide": {
    "id": "client.components.graph.utils.edgePoints.determineConnectionSide",
    "name": "determineConnectionSide",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/edgePoints.ts",
    "relative_path": "client/components/graph/utils/edgePoints.ts",
    "depends_on": [],
    "source_code": "function determineConnectionSide(nodePosition: {x: number, y: number}, nodeWidth: number, nodeHeight: number, connectionPoint: {x: number, y: number}) {\n  // Calculate the center of the node\n  const centerX = nodePosition.x + nodeWidth / 2;\n  const centerY = nodePosition.y + nodeHeight / 2;\n  \n  // Calculate distances from the connection point to each edge of the node\n  const distToLeft = Math.abs(connectionPoint.x - nodePosition.x);\n  const distToRight = Math.abs(connectionPoint.x - (nodePosition.x + nodeWidth));\n  const distToTop = Math.abs(connectionPoint.y - nodePosition.y);\n  const distToBottom = Math.abs(connectionPoint.y - (nodePosition.y + nodeHeight));\n  \n  // Find the minimum distance\n  const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);\n  \n  // Return the side with the minimum distance\n  if (minDist === distToLeft) return \"left\";\n  if (minDist === distToRight) return \"right\";\n  if (minDist === distToTop) return \"top\";\n  if (minDist === distToBottom) return \"bottom\";\n  \n  // Fallback - should never happen\n  return \"right\";\n}",
    "start_line": 15,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodePosition",
      "nodeWidth",
      "nodeHeight",
      "connectionPoint"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function determineConnectionSide",
    "component_id": "client.components.graph.utils.edgePoints.determineConnectionSide"
  },
  "client.components.graph.utils.edgePoints.buildNodeEdgePoints": {
    "id": "client.components.graph.utils.edgePoints.buildNodeEdgePoints",
    "name": "buildNodeEdgePoints",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/edgePoints.ts",
    "relative_path": "client/components/graph/utils/edgePoints.ts",
    "depends_on": [
      "client.components.graph.utils.edgePoints.EdgePointMap",
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.absPositions.AbsMap",
      "client.components.graph.utils.edgePoints.determineConnectionSide"
    ],
    "source_code": "function buildNodeEdgePoints(graph: any, abs: AbsMap): EdgePointMap {\n  const map: EdgePointMap = {};\n\n  const add = (nodeId: string, side: \"left\" | \"right\" | \"top\" | \"bottom\", entry: any) => {\n    // Initialize the node in the map if it doesn't exist\n    if (!map[nodeId]) {\n      map[nodeId] = { left: [], right: [], top: [], bottom: [] };\n    }\n    map[nodeId][side].push(entry);\n  };\n\n  // First pass: collect all nodes with their dimensions\n  const nodeDimensions = new Map();\n  const collectNodeDimensions = (node: any) => {\n    nodeDimensions.set(node.id, {\n      width: node.width || 80,\n      height: node.height || 40\n    });\n    (node.children || []).forEach(collectNodeDimensions);\n  };\n  collectNodeDimensions(graph);\n\n  const visitContainerEdges = (container: any) => {\n    (container.edges || []).forEach((e: any) => {\n      const sec = e.sections?.[0];\n      if (!sec) return;\n\n      const { x: ox, y: oy } = abs[container.id] ?? { x: 0, y: 0 };\n\n      if (e.sources?.[0] && sec.startPoint) {\n        const sourceNodeId = e.sources[0];\n        const startPointX = ox + sec.startPoint.x;\n        const startPointY = oy + sec.startPoint.y;\n        const sourceNodePos = abs[sourceNodeId] || { x: 0, y: 0 };\n        const sourceNodeDim = nodeDimensions.get(sourceNodeId) || { width: 80, height: 40 };\n        \n        // Determine which side of the source node the connection is coming from\n        const sourceSide = determineConnectionSide(\n          sourceNodePos,\n          sourceNodeDim.width,\n          sourceNodeDim.height,\n          { x: startPointX, y: startPointY }\n        );\n        \n        // Keep debug for load balancer edges only (main problem pattern)\n        if (e.id && e.id.includes('lb_app')) {\n          console.log(`üîó Edge ${e.id} at container ${container.id}: coords ${startPointX},${startPointY} -> node ${sourceNodePos.x},${sourceNodePos.y}`);\n        }\n        \n        add(sourceNodeId, sourceSide, {\n          edgeId: e.id,\n          x: startPointX,\n          y: startPointY,\n          originalX: sec.startPoint.x,\n          originalY: sec.startPoint.y,\n          side: sourceSide\n        });\n      }\n\n      if (e.targets?.[0] && sec.endPoint) {\n        const targetNodeId = e.targets[0];\n        const endPointX = ox + sec.endPoint.x;\n        const endPointY = oy + sec.endPoint.y;\n        const targetNodePos = abs[targetNodeId] || { x: 0, y: 0 };\n        const targetNodeDim = nodeDimensions.get(targetNodeId) || { width: 80, height: 40 };\n        \n        // Determine which side of the target node the connection is going to\n        const targetSide = determineConnectionSide(\n          targetNodePos,\n          targetNodeDim.width,\n          targetNodeDim.height,\n          { x: endPointX, y: endPointY }\n        );\n        \n        add(targetNodeId, targetSide, {\n          edgeId: e.id,\n          x: endPointX,\n          y: endPointY,\n          originalX: sec.endPoint.x,\n          originalY: sec.endPoint.y,\n          side: targetSide\n        });\n      }\n\n      // bendPoints ‚Üí store absolute coords next to the edge object for later\n      if (sec.bendPoints?.length) {\n        e.absoluteBendPoints = sec.bendPoints.map((p: any, index: number) => {\n          const absBendX = ox + p.x;\n          const absBendY = oy + p.y;\n          \n          // For first and last bendpoints in edges with multiple bendpoints\n          if (sec.bendPoints.length >= 2) {\n            if (index === 0 && e.sources && e.sources.length > 0) {\n              const sourceId = e.sources[0];\n              const sourceSide = map[sourceId]?.right[0]?.side || 'right';\n              const sourcePoint = map[sourceId]?.[sourceSide][0];\n              if (sourcePoint) {\n                return {\n                  index,\n                  x: absBendX,\n                  y: sourcePoint.y,\n                  originalX: p.x,\n                  originalY: p.y\n                };\n              }\n            }\n            \n            if (index === sec.bendPoints.length - 1 && e.targets && e.targets.length > 0) {\n              const targetId = e.targets[0];\n              const targetSide = map[targetId]?.left[0]?.side || 'left';\n              const targetPoint = map[targetId]?.[targetSide][0];\n              if (targetPoint) {\n                return {\n                  index,\n                  x: absBendX,\n                  y: targetPoint.y,\n                  originalX: p.x,\n                  originalY: p.y\n                };\n              }\n            }\n          }\n          \n          return {\n            index,\n            x: absBendX,\n            y: absBendY,\n            originalX: p.x,\n            originalY: p.y\n          };\n        });\n      }\n    });\n\n    (container.children || []).forEach(visitContainerEdges);\n  };\n\n  visitContainerEdges(graph);\n  return map;\n}",
    "start_line": 40,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "abs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function buildNodeEdgePoints",
    "component_id": "client.components.graph.utils.edgePoints.buildNodeEdgePoints"
  },
  "client.components.graph.utils.elk.absPositions.AbsPos": {
    "id": "client.components.graph.utils.elk.absPositions.AbsPos",
    "name": "AbsPos",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/absPositions.ts",
    "relative_path": "client/components/graph/utils/elk/absPositions.ts",
    "depends_on": [],
    "source_code": "interface AbsPos { x: number; y: number; width: number; height: number }",
    "start_line": 4,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AbsPos",
    "component_id": "client.components.graph.utils.elk.absPositions.AbsPos"
  },
  "client.components.graph.utils.elk.absPositions.AbsMap": {
    "id": "client.components.graph.utils.elk.absPositions.AbsMap",
    "name": "AbsMap",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/absPositions.ts",
    "relative_path": "client/components/graph/utils/elk/absPositions.ts",
    "depends_on": [
      "client.components.graph.utils.elk.absPositions.AbsPos"
    ],
    "source_code": "type AbsMap = Record<string, AbsPos>;",
    "start_line": 5,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type AbsMap",
    "component_id": "client.components.graph.utils.elk.absPositions.AbsMap"
  },
  "client.components.graph.utils.elk.absPositions.computeAbsolutePositions": {
    "id": "client.components.graph.utils.elk.absPositions.computeAbsolutePositions",
    "name": "computeAbsolutePositions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/absPositions.ts",
    "relative_path": "client/components/graph/utils/elk/absPositions.ts",
    "depends_on": [
      "client.components.graph.utils.elk.absPositions.AbsMap"
    ],
    "source_code": "function computeAbsolutePositions(root: any): AbsMap {\n  const map: AbsMap = {};\n  \n  function recurse(node: any, parentX: number, parentY: number) {\n    if (!node) return;\n    \n    const absX = (node.x ?? 0) + parentX;\n    const absY = (node.y ?? 0) + parentY;\n    \n    map[node.id] = { \n      x: absX, \n      y: absY, \n      width: node.width ?? NON_ROOT_DEFAULT_OPTIONS.width, \n      height: node.height ?? 100  // Fallback height if not set\n    };\n    \n    // Debug deeply nested positioning\n\n    \n    (node.children || []).forEach((child: any) => \n      recurse(child, absX, absY)\n    );\n  }\n  \n  recurse(root, 0, 0);\n  return map;\n}",
    "start_line": 8,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function computeAbsolutePositions",
    "component_id": "client.components.graph.utils.elk.absPositions.computeAbsolutePositions"
  },
  "client.components.graph.utils.elk.edgePoints.HandleMap": {
    "id": "client.components.graph.utils.elk.edgePoints.HandleMap",
    "name": "HandleMap",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/edgePoints.ts",
    "relative_path": "client/components/graph/utils/elk/edgePoints.ts",
    "depends_on": [],
    "source_code": "type HandleMap = Record<string, { x: number; y: number }>;",
    "start_line": 3,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type HandleMap",
    "component_id": "client.components.graph.utils.elk.edgePoints.HandleMap"
  },
  "client.components.graph.utils.elk.edgePoints.Point": {
    "id": "client.components.graph.utils.elk.edgePoints.Point",
    "name": "Point",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/edgePoints.ts",
    "relative_path": "client/components/graph/utils/elk/edgePoints.ts",
    "depends_on": [],
    "source_code": "type Point = { x: number; y: number };",
    "start_line": 4,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Point",
    "component_id": "client.components.graph.utils.elk.edgePoints.Point"
  },
  "client.components.graph.utils.elk.edgePoints.warn": {
    "id": "client.components.graph.utils.elk.edgePoints.warn",
    "name": "warn",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/edgePoints.ts",
    "relative_path": "client/components/graph/utils/elk/edgePoints.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "warn = (msg: string, obj?: any) =>\n  console.warn(`[edgePoints] ${msg}`, obj ?? \"\")",
    "start_line": 6,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "msg",
      "obj"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function warn",
    "component_id": "client.components.graph.utils.elk.edgePoints.warn"
  },
  "client.components.graph.utils.elk.edgePoints.add": {
    "id": "client.components.graph.utils.elk.edgePoints.add",
    "name": "add",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/edgePoints.ts",
    "relative_path": "client/components/graph/utils/elk/edgePoints.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.Point"
    ],
    "source_code": "function add(points: Point[], source: Point, target: Point): void {\n  if (source) points.push(source);\n  if (target) points.push(target);\n}",
    "start_line": 9,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "points",
      "source",
      "target"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add",
    "component_id": "client.components.graph.utils.elk.edgePoints.add"
  },
  "client.components.graph.utils.elk.edgePoints.visitContainerEdges": {
    "id": "client.components.graph.utils.elk.edgePoints.visitContainerEdges",
    "name": "visitContainerEdges",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/edgePoints.ts",
    "relative_path": "client/components/graph/utils/elk/edgePoints.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.Point",
      "client.types.graph.ElkGraphNode",
      "client.components.graph.utils.elk.edgePoints.HandleMap",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.components.graph.utils.elk.edgePoints.add"
    ],
    "source_code": "function visitContainerEdges(container: ElkGraphNode, map: HandleMap, points: Point[]): void {\n  if (!container.edges) return;\n  \n  for (const e of container.edges) {\n    if (!map[e.sources[0]]) warn(\"source handle map missing\", e);\n    if (!map[e.targets[0]]) warn(\"target handle map missing\", e);\n    add(points, map[e.sources[0]], map[e.targets[0]]);\n  }\n}",
    "start_line": 14,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "container",
      "map",
      "points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function visitContainerEdges",
    "component_id": "client.components.graph.utils.elk.edgePoints.visitContainerEdges"
  },
  "client.components.graph.utils.elk.ids.ensureIds": {
    "id": "client.components.graph.utils.elk.ids.ensureIds",
    "name": "ensureIds",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/ids.ts",
    "relative_path": "client/components/graph/utils/elk/ids.ts",
    "depends_on": [
      "client.utils.textMeasurement.calculateNodeDimensions"
    ],
    "source_code": "function ensureIds(root: any): any {\n  let counter = 0;\n\n  function recurse(node: any, parentId: string) {\n    if (!node) return;\n\n    // root vs non-root layout options\n    if (!parentId) {\n      Object.assign(node, {\n        ...ROOT_DEFAULT_OPTIONS,\n        layoutOptions: {\n          ...ROOT_DEFAULT_OPTIONS.layoutOptions,\n          ...(node.layoutOptions ?? {}),\n        },\n      });\n    } else {\n      // Apply fixed width for all non-root nodes\n      node.width ??= NON_ROOT_DEFAULT_OPTIONS.width;\n      \n      // Apply dynamic height for leaf nodes, default height for container nodes\n      const isLeafNode = !node.children || node.children.length === 0;\n      \n      if (isLeafNode && node.labels && node.labels[0] && node.labels[0].text) {\n        // Leaf node with label - use dynamic height based on text\n        const labelText = node.labels[0].text;\n        const dimensions = calculateNodeDimensions(labelText);\n        node.height ??= dimensions.height;\n      } else {\n        // Container node or leaf without label - use fallback height\n        node.height ??= 100; // Fallback for containers\n      }\n      \n      node.layoutOptions = {\n        ...NON_ROOT_DEFAULT_OPTIONS.layoutOptions,\n        ...(node.layoutOptions ?? {}),\n      };\n    }\n\n    // assign a new ID only if missing\n    if (!node.id) {\n      node.id = `auto-${counter++}`;  \n    }\n\n    // recurse into children\n    (node.children || []).forEach((child: any) =>\n      recurse(child, node.id)\n    );\n  }\n\n  recurse(root, \"\");\n  return root;\n}",
    "start_line": 25,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensureIds",
    "component_id": "client.components.graph.utils.elk.ids.ensureIds"
  },
  "client.components.graph.utils.elk.processLayoutedGraph.EdgeResult": {
    "id": "client.components.graph.utils.elk.processLayoutedGraph.EdgeResult",
    "name": "EdgeResult",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/processLayoutedGraph.ts",
    "relative_path": "client/components/graph/utils/elk/processLayoutedGraph.ts",
    "depends_on": [],
    "source_code": "interface EdgeResult {\n  edgeId: string;\n  sourceNodeId: string;\n  targetNodeId: string;\n  sourceHandle: string;\n  targetHandle: string;\n}",
    "start_line": 3,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeResult",
    "component_id": "client.components.graph.utils.elk.processLayoutedGraph.EdgeResult"
  },
  "client.components.graph.utils.elk.processLayoutedGraph.processLayoutedGraph": {
    "id": "client.components.graph.utils.elk.processLayoutedGraph.processLayoutedGraph",
    "name": "processLayoutedGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/processLayoutedGraph.ts",
    "relative_path": "client/components/graph/utils/elk/processLayoutedGraph.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.types.graph.ElkGraphNode",
      "client.components.graph.utils.elk.processLayoutedGraph.EdgeResult"
    ],
    "source_code": "function processLayoutedGraph(layoutedGraph: ElkGraphNode): EdgeResult[] {\n  const edges: EdgeResult[] = [];\n  \n  // Process edges from the graph\n  if (layoutedGraph.edges) {\n    for (const edge of layoutedGraph.edges) {\n      const edgeId = edge.id;\n      const sourceNodeId = edge.sources[0] || '';\n      const targetNodeId = edge.targets[0] || '';\n      const sourceHandle = edge.sources[0] || '';\n      const targetHandle = edge.targets[0] || '';\n      \n      if (sourceHandle && targetHandle) {\n        edges.push({\n          edgeId,\n          sourceNodeId,\n          targetNodeId,\n          sourceHandle,\n          targetHandle\n        });\n      } else {\n        console.warn(\"[RF-convert] edge skipped ‚Äì handle not found\", {\n          edgeId,\n          sourceNodeId,\n          targetNodeId,\n          sourceHandle,\n          targetHandle\n        });\n      }\n    }\n  }\n  \n  return edges;\n}",
    "start_line": 11,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layoutedGraph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function processLayoutedGraph",
    "component_id": "client.components.graph.utils.elk.processLayoutedGraph.processLayoutedGraph"
  },
  "client.components.graph.utils.elk.structuralHash.CanonicalNode": {
    "id": "client.components.graph.utils.elk.structuralHash.CanonicalNode",
    "name": "CanonicalNode",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/structuralHash.ts",
    "relative_path": "client/components/graph/utils/elk/structuralHash.ts",
    "depends_on": [
      "client.components.graph.utils.elk.structuralHash.CanonicalEdge",
      "client.components.graph.utils.elk.structuralHash.CanonicalNode"
    ],
    "source_code": "interface CanonicalNode {\n  id: string;\n  children?: CanonicalNode[];\n  edges?: CanonicalEdge[];\n}",
    "start_line": 4,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CanonicalNode",
    "component_id": "client.components.graph.utils.elk.structuralHash.CanonicalNode"
  },
  "client.components.graph.utils.elk.structuralHash.CanonicalEdge": {
    "id": "client.components.graph.utils.elk.structuralHash.CanonicalEdge",
    "name": "CanonicalEdge",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/structuralHash.ts",
    "relative_path": "client/components/graph/utils/elk/structuralHash.ts",
    "depends_on": [],
    "source_code": "interface CanonicalEdge {\n  id: string;\n  sources: string[];\n  targets: string[];\n}",
    "start_line": 10,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CanonicalEdge",
    "component_id": "client.components.graph.utils.elk.structuralHash.CanonicalEdge"
  },
  "client.components.graph.utils.elk.structuralHash.canonical": {
    "id": "client.components.graph.utils.elk.structuralHash.canonical",
    "name": "canonical",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/structuralHash.ts",
    "relative_path": "client/components/graph/utils/elk/structuralHash.ts",
    "depends_on": [
      "client.components.graph.utils.elk.structuralHash.CanonicalEdge",
      "client.components.graph.utils.elk.structuralHash.CanonicalNode"
    ],
    "source_code": "function canonical(n: any): CanonicalNode {\n  return {\n    id: n.id,\n    children: n.children?.map(canonical)\n                        .sort((a: CanonicalNode, b: CanonicalNode) => a.id.localeCompare(b.id)),\n    edges: n.edges?.map((e: any) => ({\n              id: e.id,\n              sources: [...e.sources].sort(),\n              targets: [...e.targets].sort(),\n           }))\n           .sort((a: CanonicalEdge, b: CanonicalEdge) => a.id.localeCompare(b.id)),\n  };\n}",
    "start_line": 16,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "n"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function canonical",
    "component_id": "client.components.graph.utils.elk.structuralHash.canonical"
  },
  "client.components.graph.utils.elk.structuralHash.structuralHash": {
    "id": "client.components.graph.utils.elk.structuralHash.structuralHash",
    "name": "structuralHash",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/elk/structuralHash.ts",
    "relative_path": "client/components/graph/utils/elk/structuralHash.ts",
    "depends_on": [
      "client.components.graph.utils.elk.structuralHash.canonical"
    ],
    "source_code": "function structuralHash(root: any): string {\n  return stringify(canonical(root));                  // deterministic string\n}",
    "start_line": 30,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function structuralHash",
    "component_id": "client.components.graph.utils.elk.structuralHash.structuralHash"
  },
  "client.components.graph.utils.find.findNodeById": {
    "id": "client.components.graph.utils.find.findNodeById",
    "name": "findNodeById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/find.ts",
    "relative_path": "client/components/graph/utils/find.ts",
    "depends_on": [
      "client.components.graph.utils.find.findNodeById"
    ],
    "source_code": "findNodeById = (node: any, id: string): any => {\n  if (!node) return null;\n  if (node.id === id) return node;\n  return (node.children || [])\n    .map((c: any) => findNodeById(c, id))\n    .find(Boolean) ?? null;\n}",
    "start_line": 2,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "id"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function findNodeById",
    "component_id": "client.components.graph.utils.find.findNodeById"
  },
  "client.components.graph.utils.toReactFlow.NodeDimensions": {
    "id": "client.components.graph.utils.toReactFlow.NodeDimensions",
    "name": "NodeDimensions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/toReactFlow.ts",
    "relative_path": "client/components/graph/utils/toReactFlow.ts",
    "depends_on": [],
    "source_code": "interface NodeDimensions {\n  width: number;\n  height: number;\n  groupWidth: number;\n  groupHeight: number;\n  padding: number;\n}",
    "start_line": 7,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeDimensions",
    "component_id": "client.components.graph.utils.toReactFlow.NodeDimensions"
  },
  "client.components.graph.utils.toReactFlow.processLayoutedGraph": {
    "id": "client.components.graph.utils.toReactFlow.processLayoutedGraph",
    "name": "processLayoutedGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/graph/utils/toReactFlow.ts",
    "relative_path": "client/components/graph/utils/toReactFlow.ts",
    "depends_on": [
      "client.types.graph.CustomNode",
      "client.components.graph.utils.toReactFlow.NodeDimensions",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.components.graph.utils.edgePoints.buildNodeEdgePoints",
      "client.components.graph.utils.elk.edgePoints.add",
      "client.components.graph.utils.elk.absPositions.computeAbsolutePositions"
    ],
    "source_code": "function processLayoutedGraph(elkGraph: any, dimensions: NodeDimensions) {\n  // Snap-to-grid configuration (keep in sync with canvas grid)\n  const GRID_SIZE = 16;\n  const snap = (v: number) => Math.round(v / GRID_SIZE) * GRID_SIZE;\n  const snapPos = (p: { x: number; y: number }) => ({ x: snap(p.x), y: snap(p.y) });\n\n  // Calculate absolute positions for all nodes in the graph\n  const absolutePositions = computeAbsolutePositions(elkGraph);\n  \n  // Build a map of edge connection points for each node\n  const edgeConnectionPoints = buildNodeEdgePoints(elkGraph, absolutePositions);\n\n  const nodes: CustomNode[] = [];\n  const edges: Edge[] = [];\n  const processedEdgeIds = new Set<string>();\n\n  /* ---------- helper to create RF nodes -------------------------------- */\n  const createNode = (node: any, parentAbsolutePosition = { x: 0, y: 0 }, parentId?: string) => {\n    const absPosRaw = absolutePositions[node.id];\n    const absPos = snapPos(absPosRaw);\n    const isGroupNode = (node.children?.length ?? 0) > 0;\n\n    // Quantize node sizes to grid so both start and end land on grid\n    const quantizeSize = (v: number) => Math.max(GRID_SIZE, Math.round(v / GRID_SIZE) * GRID_SIZE);\n    const nodeWidth  = quantizeSize(node.width  || dimensions.width);\n    const nodeHeight = quantizeSize(node.height || dimensions.height);\n    const groupWidth  = quantizeSize(node.width  || dimensions.groupWidth);\n    const groupHeight = quantizeSize(node.height || dimensions.groupHeight);\n\n    // Only set parentId if it's not root (root is skipped from rendering)\n    // Nodes that would have root as parent become top-level (no parentId)\n    const validParentId = parentId && parentId !== 'root' ? parentId : undefined;\n\n\n    // Use 'draftGroup' instead of 'group' to avoid ReactFlow's built-in group behavior\n    // which blocks dragging. See docs/FIGJAM_REFACTOR.md section 0.1\n    nodes.push({\n      id: node.id,\n      type: isGroupNode ? \"draftGroup\" : \"custom\",\n      position: validParentId ? snapPos({ x: node.x ?? 0, y: node.y ?? 0 }) : { x: absPos.x, y: absPos.y },\n      ...(validParentId && { parentId: validParentId }),\n      zIndex: isGroupNode ? CANVAS_STYLES.zIndex.groups : CANVAS_STYLES.zIndex.nodes,\n      selectable: true,\n      selected: false,\n      draggable: true,\n      data: {\n        label: node.labels?.[0]?.text || (node.id === 'root' ? '' : node.id),\n        width: nodeWidth,\n        height: nodeHeight,\n        isParent: isGroupNode,\n        // Pass through icon if it exists in the node data\n        ...(node.data?.icon && { icon: node.data.icon }),\n        // Pass through style if it exists in the node data\n        ...(node.data?.style && { style: node.data.style }),\n        // Pass through groupIcon if it exists in the node data\n        ...(node.data?.groupIcon && { groupIcon: node.data.groupIcon }),\n        leftHandles: (edgeConnectionPoints[node.id]?.left ?? []).map(connectionPoint => {\n          const delta = snap(connectionPoint.y) - absPos.y;\n          return delta;\n        }),\n        rightHandles: (edgeConnectionPoints[node.id]?.right ?? []).map(connectionPoint => {\n          const delta = snap(connectionPoint.y) - absPos.y;\n          return delta;\n        }),\n        topHandles: (edgeConnectionPoints[node.id]?.top ?? []).map(connectionPoint => {\n          const delta = snap(connectionPoint.x) - absPos.x;\n          return delta;\n        }),\n        bottomHandles: (edgeConnectionPoints[node.id]?.bottom ?? []).map(connectionPoint => {\n          const delta = snap(connectionPoint.x) - absPos.x;\n          return delta;\n        }),\n        position: { x: absPos.x, y: absPos.y }\n      },\n      style: isGroupNode ? {\n        width: groupWidth,\n        height: groupHeight,\n        backgroundColor: 'transparent',\n        border: 'none',\n        display: 'flex',\n        justifyContent: 'flex-start',\n        alignItems: 'flex-start',\n        padding: '0px',\n        pointerEvents: 'all'\n      } : {\n        pointerEvents: 'all'\n      }\n    } as CustomNode);\n\n    // Process child nodes recursively\n    // Only pass parentId if this node will be in the ReactFlow nodes array (i.e., not root)\n    const nodeIdInReactFlow = node.id !== 'root' ? node.id : undefined;\n    (node.children || []).forEach((childNode: any) => createNode(childNode, absPos, nodeIdInReactFlow));\n  };\n\n  // Start node creation from root's children (skip root itself)\n  // Root represents the entire canvas and should not be rendered as a node\n  \n  (elkGraph.children || []).forEach((childNode: any) => {\n    createNode(childNode);\n  });\n  \n  // Final pass: Remove any invalid parentId references\n  // This ensures no node references a parent that doesn't exist in the nodes array\n  const nodeIdsSet = new Set(nodes.map(n => n.id));\n  nodes.forEach(node => {\n    if ((node as any).parentId && !nodeIdsSet.has((node as any).parentId)) {\n      console.warn(`[toReactFlow] FIXING: Removing invalid parentId '${(node as any).parentId}' from node '${node.id}' - parent does not exist`);\n      delete (node as any).parentId;\n      // Update position to absolute if it was relative\n      if ((node.data as any).position) {\n        node.position = (node.data as any).position;\n      }\n    }\n  });\n\n  /* ---------- helper to create RF edges -------------------------------- */\n  // Create a map of node types for quick lookups\n  const nodeTypeMap = new Map(nodes.map(node => [node.id, node.type]));\n\n  const createEdge = (edge: any, containerAbs: { x: number; y: number }) => {\n    edge.sources?.forEach((sourceNodeId: string) =>\n      edge.targets?.forEach((targetNodeId: string) => {\n        const edgeId = edge.id || `${sourceNodeId}-${targetNodeId}-${Math.random().toString(36).substr(2, 9)}`;\n        if (processedEdgeIds.has(edgeId)) return;\n        processedEdgeIds.add(edgeId);\n\n        // Check if this edge uses connector handles (format: connector-${side}-source/target)\n        // Connector handles are stored in the edge metadata if available\n        let sourceHandle: string | undefined;\n        let targetHandle: string | undefined;\n        \n        // Try to extract connector handles from edge metadata if available\n        // For edges created via connector tool, the handle IDs are in the edge data\n        if (edge.data?.sourceHandle) {\n          sourceHandle = edge.data.sourceHandle;\n        }\n        if (edge.data?.targetHandle) {\n          targetHandle = edge.data.targetHandle;\n        }\n\n        if (!sourceHandle || !targetHandle) {\n          let sourceHandleIndex = -1;\n          let sourceHandleSide = \"right\";\n          let targetHandleIndex = -1;\n          let targetHandleSide = \"left\";\n\n          // Check all sides for the source node\n          for (const side of [\"right\", \"left\", \"top\", \"bottom\"]) {\n            const connectionPoints = edgeConnectionPoints[sourceNodeId]?.[side] ?? [];\n            const index = connectionPoints.findIndex(\n              connectionPoint => connectionPoint.edgeId === edge.id\n            );\n            if (index >= 0) {\n              sourceHandleIndex = index;\n              sourceHandleSide = side;\n              break;\n            }\n          }\n\n          // Check all sides for the target node\n          for (const side of [\"left\", \"right\", \"top\", \"bottom\"]) {\n            const connectionPoints = edgeConnectionPoints[targetNodeId]?.[side] ?? [];\n            const index = connectionPoints.findIndex(\n              connectionPoint => connectionPoint.edgeId === edge.id\n            );\n            if (index >= 0) {\n              targetHandleIndex = index;\n              targetHandleSide = side;\n              break;\n            }\n          }\n\n          const isSourceGroupNode = nodeTypeMap.get(sourceNodeId) === 'group';\n          const isTargetGroupNode = nodeTypeMap.get(targetNodeId) === 'group';\n          \n          // Determine if the handle is a source or target based on the edge's direction\n          // For source handle, prefer \"source\" type, for target handle, prefer \"target\" type\n          const sourceHandleType = \"source\";\n          const targetHandleType = \"target\";\n          \n          sourceHandle = sourceHandleIndex >= 0 ? `${sourceHandleSide}-${sourceHandleIndex}-${sourceHandleType}` : undefined;\n          targetHandle = targetHandleIndex >= 0 ? `${targetHandleSide}-${targetHandleIndex}-${targetHandleType}` : undefined;\n        }\n\n        if (sourceHandle && targetHandle) {\n          /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ turn label position into ABSOLUTE coordinates ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */\n          const elkLbl      = edge.labels?.[0];\n          const labelTxt    = elkLbl?.text ?? \"\";\n          const labelPosAbs = elkLbl\n            ? { x: elkLbl.x + containerAbs.x, y: elkLbl.y + containerAbs.y }\n            : undefined;\n          \n\n\n          edges.push({\n            id: edgeId, \n            source: sourceNodeId, \n            target: targetNodeId,\n            type: edge.sections?.[0]?.bendPoints?.length >= 2 ? \"step\" : \"smoothstep\",\n            zIndex: CANVAS_STYLES.zIndex.edges,\n            sourceHandle: sourceHandle,\n            targetHandle: targetHandle,\n            selectable: true,\n            focusable: true,\n            style: CANVAS_STYLES.edges.default,\n            markerEnd: {\n              type: MarkerType.ArrowClosed,\n              width: CANVAS_STYLES.edges.marker.width,\n              height: CANVAS_STYLES.edges.marker.height,\n              color: CANVAS_STYLES.edges.marker.color\n            },\n            /* put it in BOTH places so every consumer is happy */\n            label: labelTxt,\n            data: {\n              labelText: labelTxt,\n              bendPoints: edge.absoluteBendPoints ?? [],\n              labelPos: labelPosAbs          // ‚Üê now absolute\n            },\n            selected: false,\n            hidden: false,\n          });\n        } else {\n          // Keep essential edge skip warning for debugging\n          console.warn(`‚ö†Ô∏è [EDGE-SKIP] Edge ${edge.id} skipped - handle not found`, {\n            edgeId,\n            sourceNodeId,\n            targetNodeId,\n            sourceHandle,\n            targetHandle,\n            wasConnectorEdge: !!(edge.data?.sourceHandle || edge.data?.targetHandle),\n            edgeData: edge.data,\n            containerAbs: containerAbs\n          });\n        }\n      })\n    );\n  };\n\n  const processEdges = (node: any) => {\n    const absRaw = absolutePositions[node.id];      // abs pos of this container\n    const abs = snapPos(absRaw);\n    (node.edges || []).forEach((e: any) => createEdge(e, abs));\n    (node.children || []).forEach(processEdges);\n  };\n  \n  // Process all edges in the graph\n  processEdges(elkGraph);\n\n  // Final edge creation complete\n\n  return { nodes, edges };\n}",
    "start_line": 15,
    "end_line": 267,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "elkGraph",
      "dimensions"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function processLayoutedGraph",
    "component_id": "client.components.graph.utils.toReactFlow.processLayoutedGraph"
  },
  "client.components.ui.CanvasToolbar.CanvasToolbarProps": {
    "id": "client.components.ui.CanvasToolbar.CanvasToolbarProps",
    "name": "CanvasToolbarProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/CanvasToolbar.tsx",
    "relative_path": "client/components/ui/CanvasToolbar.tsx",
    "depends_on": [
      "client.hooks.useToolSelection.Tool"
    ],
    "source_code": "interface CanvasToolbarProps {\n  selectedTool: Tool;\n  onSelect: (tool: Tool) => void;\n  className?: string;\n}",
    "start_line": 5,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CanvasToolbarProps",
    "component_id": "client.components.ui.CanvasToolbar.CanvasToolbarProps"
  },
  "client.components.ui.CanvasToolbarContainer.CanvasToolbarContainerProps": {
    "id": "client.components.ui.CanvasToolbarContainer.CanvasToolbarContainerProps",
    "name": "CanvasToolbarContainerProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/CanvasToolbarContainer.tsx",
    "relative_path": "client/components/ui/CanvasToolbarContainer.tsx",
    "depends_on": [
      "client.hooks.useToolSelection.Tool"
    ],
    "source_code": "interface CanvasToolbarContainerProps {\n  selectedTool: Tool;\n  onToolSelect: (tool: Tool) => void;\n}",
    "start_line": 5,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CanvasToolbarContainerProps",
    "component_id": "client.components.ui.CanvasToolbarContainer.CanvasToolbarContainerProps"
  },
  "client.components.ui.CanvasToolbarContainer.CanvasToolbarContainer": {
    "id": "client.components.ui.CanvasToolbarContainer.CanvasToolbarContainer",
    "name": "CanvasToolbarContainer",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/CanvasToolbarContainer.tsx",
    "relative_path": "client/components/ui/CanvasToolbarContainer.tsx",
    "depends_on": [
      "client.components.ui.CanvasToolbarContainer.CanvasToolbarContainerProps"
    ],
    "source_code": "CanvasToolbarContainer: React.FC<CanvasToolbarContainerProps> = ({\n  selectedTool,\n  onToolSelect\n}) => {\n  return (\n    <div className=\"absolute bottom-8 left-1/2 -translate-x-1/2 z-[8000]\">\n      <CanvasToolbar selectedTool={selectedTool} onSelect={onToolSelect} />\n    </div>\n  );\n}",
    "start_line": 10,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function CanvasToolbarContainer",
    "component_id": "client.components.ui.CanvasToolbarContainer.CanvasToolbarContainer"
  },
  "client.components.ui.EdgeDebugViewer.EdgeDebugInfo": {
    "id": "client.components.ui.EdgeDebugViewer.EdgeDebugInfo",
    "name": "EdgeDebugInfo",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/EdgeDebugViewer.tsx",
    "relative_path": "client/components/ui/EdgeDebugViewer.tsx",
    "depends_on": [],
    "source_code": "interface EdgeDebugInfo {\n  edgeId: string;\n  sourceNodeId: string;\n  targetNodeId: string;\n  sourceNodeInfo: {\n    id: string;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  targetNodeInfo: {\n    id: string;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  handlePositions: {\n    sourceX: number;\n    sourceY: number;\n    targetX: number;\n    targetY: number;\n  };\n  waypoints: Array<{ x: number; y: number }>;\n  path: string;\n}",
    "start_line": 4,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeDebugInfo",
    "component_id": "client.components.ui.EdgeDebugViewer.EdgeDebugInfo"
  },
  "client.components.ui.EdgeDebugViewer.EdgeDebugViewerProps": {
    "id": "client.components.ui.EdgeDebugViewer.EdgeDebugViewerProps",
    "name": "EdgeDebugViewerProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/EdgeDebugViewer.tsx",
    "relative_path": "client/components/ui/EdgeDebugViewer.tsx",
    "depends_on": [],
    "source_code": "interface EdgeDebugViewerProps {\n  nodes: Node[];\n  edges: Edge[];\n  selectedNodeIds: string[];\n}",
    "start_line": 32,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeDebugViewerProps",
    "component_id": "client.components.ui.EdgeDebugViewer.EdgeDebugViewerProps"
  },
  "client.components.ui.GroupHoverPreview.GroupHoverPreviewProps": {
    "id": "client.components.ui.GroupHoverPreview.GroupHoverPreviewProps",
    "name": "GroupHoverPreviewProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/GroupHoverPreview.tsx",
    "relative_path": "client/components/ui/GroupHoverPreview.tsx",
    "depends_on": [],
    "source_code": "interface GroupHoverPreviewProps {\n  reactFlowRef: React.MutableRefObject<ReactFlowInstance | null>;\n  grid?: number;\n  visible: boolean;\n}",
    "start_line": 4,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GroupHoverPreviewProps",
    "component_id": "client.components.ui.GroupHoverPreview.GroupHoverPreviewProps"
  },
  "client.components.ui.GroupHoverPreview.GroupHoverPreview": {
    "id": "client.components.ui.GroupHoverPreview.GroupHoverPreview",
    "name": "GroupHoverPreview",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/GroupHoverPreview.tsx",
    "relative_path": "client/components/ui/GroupHoverPreview.tsx",
    "depends_on": [
      "client.components.ui.GroupHoverPreview.GroupHoverPreviewProps"
    ],
    "source_code": "GroupHoverPreview: React.FC<GroupHoverPreviewProps> = ({ reactFlowRef, grid = 16, visible }) => {\n  const [pos, setPos] = useState<{ x: number; y: number } | null>(null);\n  const [zoom, setZoom] = useState<number>(1);\n  const lastScreenPosRef = useRef<{ x: number; y: number } | null>(null);\n  \n  // Track mouse position even when not visible, so preview shows immediately when tool is selected\n  useEffect(() => {\n    const pane = document.querySelector('.react-flow__pane');\n    if (!pane || !(pane instanceof HTMLElement)) return;\n    \n    const trackMouse = (e: MouseEvent) => {\n      lastScreenPosRef.current = { x: e.clientX, y: e.clientY };\n    };\n    \n    pane.addEventListener('mousemove', trackMouse);\n    return () => {\n      pane.removeEventListener('mousemove', trackMouse);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!visible) {\n      setPos(null);\n      return;\n    }\n    \n    // Listen on the pane for cursor movement\n    const pane = document.querySelector('.react-flow__pane');\n    if (!pane || !(pane instanceof HTMLElement)) return;\n    \n    let raf = 0;\n    const reproject = (screen: { x: number; y: number }) => {\n      const rf = reactFlowRef.current;\n      if (!rf) return;\n      \n      // Convert screen to flow coordinates\n      const world = (rf as any).screenToFlowPosition\n        ? (rf as any).screenToFlowPosition({ x: screen.x, y: screen.y })\n        : (rf as any).project({ x: screen.x, y: screen.y });\n      \n      // Snap to grid\n      const snap = (v: number) => Math.round(v / grid) * grid;\n      \n      // Center the group on the cursor (like NodeHoverPreview centers the node)\n      const snappedWorld = {\n        x: snap(world.x - GROUP_WIDTH / 2),\n        y: snap(world.y - GROUP_HEIGHT / 2),\n      };\n      \n      // Convert back to screen coordinates for rendering\n      const flowToScreen = (rf as any).flowToScreenPosition\n        ? (rf as any).flowToScreenPosition(snappedWorld)\n        : null;\n      \n      const vp = (rf as any).getViewport ? (rf as any).getViewport() : { zoom: (rf as any).getZoom ? (rf as any).getZoom() : 1 };\n      \n      if (flowToScreen) {\n        const rect = pane.getBoundingClientRect();\n        const left = (flowToScreen as any).x - rect.left;\n        const top = (flowToScreen as any).y - rect.top;\n        setPos({ x: left, y: top });\n        setZoom(vp.zoom || 1);\n      } else {\n        const rect = pane.getBoundingClientRect();\n        const viewport = (rf as any).getViewport ? (rf as any).getViewport() : { x: 0, y: 0, zoom: (rf as any).getZoom ? (rf as any).getZoom() : 1 };\n        const screenX = snappedWorld.x * viewport.zoom + viewport.x - rect.left;\n        const screenY = snappedWorld.y * viewport.zoom + viewport.y - rect.top;\n        setPos({ x: screenX, y: screenY });\n        setZoom(viewport.zoom || 1);\n      }\n    };\n\n    const onMove = (e: MouseEvent) => {\n      cancelAnimationFrame(raf);\n      raf = requestAnimationFrame(() => {\n        const screen = { x: e.clientX, y: e.clientY };\n        lastScreenPosRef.current = screen;\n        reproject(screen);\n      });\n    };\n    \n    const onWheel = () => {\n      if (!lastScreenPosRef.current) return;\n      cancelAnimationFrame(raf);\n      raf = requestAnimationFrame(() => {\n        reproject(lastScreenPosRef.current!);\n      });\n    };\n    \n    // Initialize position immediately when becoming visible\n    if (lastScreenPosRef.current) {\n      reproject(lastScreenPosRef.current);\n    } else {\n      // Fallback to center of viewport\n      const rect = pane.getBoundingClientRect();\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      lastScreenPosRef.current = { x: centerX, y: centerY };\n      reproject(lastScreenPosRef.current);\n    }\n    \n    pane.addEventListener('mousemove', onMove);\n    pane.addEventListener('wheel', onWheel, { passive: true });\n    const onLeave = () => setPos(null);\n    pane.addEventListener('mouseleave', onLeave);\n    \n    return () => {\n      cancelAnimationFrame(raf);\n      pane.removeEventListener('mousemove', onMove);\n      pane.removeEventListener('wheel', onWheel as any);\n      pane.removeEventListener('mouseleave', onLeave);\n    };\n  }, [reactFlowRef, grid, visible]);\n\n  if (!visible || !pos) return null;\n  \n  const width = GROUP_WIDTH * zoom;\n  const height = GROUP_HEIGHT * zoom;\n  \n  return (\n    <div\n      className=\"group-hover-preview\"\n      style={{\n        position: 'absolute',\n        left: pos.x,\n        top: pos.y,\n        width: width,\n        height: height,\n        borderRadius: 8 * zoom,\n        border: `${1 * zoom}px solid #E4E4E4`, // E4E4E4 stroke\n        background: 'rgba(228, 228, 228, 0.5)', // E4E4E4 with 50% opacity\n        boxSizing: 'border-box',\n        pointerEvents: 'none',\n        zIndex: 100,\n        transition: 'none', // No transition for smooth cursor following\n      }}\n    />\n  );\n}",
    "start_line": 13,
    "end_line": 151,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function GroupHoverPreview",
    "component_id": "client.components.ui.GroupHoverPreview.GroupHoverPreview"
  },
  "client.components.ui.NodeStyleSettings.NodeStyleSettings": {
    "id": "client.components.ui.NodeStyleSettings.NodeStyleSettings",
    "name": "NodeStyleSettings",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/NodeStyleSettings.tsx",
    "relative_path": "client/components/ui/NodeStyleSettings.tsx",
    "depends_on": [
      "client.contexts.NodeStyleContext.useNodeStyle"
    ],
    "source_code": "NodeStyleSettings: React.FC = () => {\n  const { settings, updateSettings } = useNodeStyle();\n  const [isOpen, setIsOpen] = useState(false);\n\n  const handleIconSizeChange = (size: number) => {\n    updateSettings({ iconSize: size });\n  };\n\n  const handleNodePaddingVerticalChange = (padding: number) => {\n    updateSettings({ nodePaddingVertical: padding });\n  };\n\n  const handleNodePaddingHorizontalChange = (padding: number) => {\n    updateSettings({ nodePaddingHorizontal: padding });\n  };\n\n  const handleTextPaddingChange = (padding: number) => {\n    updateSettings({ textPadding: padding });\n  };\n\n  if (!isOpen) {\n    return (\n      <button\n        onClick={() => setIsOpen(true)}\n        className=\"fixed bottom-4 right-4 z-[100] p-3 bg-white rounded-lg shadow-lg border border-gray-200 hover:bg-gray-50 transition-all\"\n        title=\"Node Style Settings\"\n      >\n        <Settings className=\"w-5 h-5 text-gray-700\" />\n      </button>\n    );\n  }\n\n  return (\n    <div className=\"fixed bottom-4 right-4 z-[100] bg-white rounded-lg shadow-lg border border-gray-200 p-4 min-w-[280px]\">\n      <div className=\"flex items-center justify-between mb-4\">\n        <h3 className=\"text-sm font-semibold text-gray-700\">Node Style Settings</h3>\n        <button\n          onClick={() => setIsOpen(false)}\n          className=\"text-gray-400 hover:text-gray-600 transition-colors\"\n        >\n          <X className=\"w-4 h-4\" />\n        </button>\n      </div>\n\n      <div className=\"space-y-4\">\n        {/* Icon Size Slider */}\n        <div>\n          <label className=\"block text-xs font-medium text-gray-600 mb-2\">\n            Icon Size: {settings.iconSize}px\n          </label>\n          <input\n            type=\"range\"\n            min=\"16\"\n            max=\"96\"\n            value={settings.iconSize}",
    "start_line": 5,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function NodeStyleSettings",
    "component_id": "client.components.ui.NodeStyleSettings.NodeStyleSettings"
  },
  "client.components.ui.__tests__.canvas-real-behavior.test.createMockCanvasDOM": {
    "id": "client.components.ui.__tests__.canvas-real-behavior.test.createMockCanvasDOM",
    "name": "createMockCanvasDOM",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/__tests__/canvas-real-behavior.test.tsx",
    "relative_path": "client/components/ui/__tests__/canvas-real-behavior.test.tsx",
    "depends_on": [],
    "source_code": "function createMockCanvasDOM() {\n  const canvasContainer = document.createElement('div');\n  canvasContainer.id = 'canvas-container';\n  canvasContainer.style.width = '800px';\n  canvasContainer.style.height = '600px';\n  document.body.appendChild(canvasContainer);\n  \n  return canvasContainer;\n}",
    "start_line": 18,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createMockCanvasDOM",
    "component_id": "client.components.ui.__tests__.canvas-real-behavior.test.createMockCanvasDOM"
  },
  "client.components.ui.__tests__.canvas-real-behavior.test.createNodeElement": {
    "id": "client.components.ui.__tests__.canvas-real-behavior.test.createNodeElement",
    "name": "createNodeElement",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/__tests__/canvas-real-behavior.test.tsx",
    "relative_path": "client/components/ui/__tests__/canvas-real-behavior.test.tsx",
    "depends_on": [],
    "source_code": "function createNodeElement(nodeId: string, x: number, y: number) {\n  const nodeEl = document.createElement('div');\n  nodeEl.className = 'canvas-node';\n  nodeEl.setAttribute('data-node-id', nodeId);\n  nodeEl.style.position = 'absolute';\n  nodeEl.style.left = `${x}px`;\n  nodeEl.style.top = `${y}px`;\n  nodeEl.style.width = '96px';\n  nodeEl.style.height = '96px';\n  nodeEl.style.backgroundColor = '#f0f0f0';\n  nodeEl.style.border = '1px solid #ccc';\n  nodeEl.textContent = nodeId;\n  return nodeEl;\n}",
    "start_line": 28,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "x",
      "y"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createNodeElement",
    "component_id": "client.components.ui.__tests__.canvas-real-behavior.test.createNodeElement"
  },
  "client.components.ui.button.ButtonProps": {
    "id": "client.components.ui.button.ButtonProps",
    "name": "ButtonProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/button.tsx",
    "relative_path": "client/components/ui/button.tsx",
    "depends_on": [],
    "source_code": "interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}",
    "start_line": 33,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ButtonProps",
    "component_id": "client.components.ui.button.ButtonProps"
  },
  "client.components.ui.canvasInteractions.placeNodeOnCanvas": {
    "id": "client.components.ui.canvasInteractions.placeNodeOnCanvas",
    "name": "placeNodeOnCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/canvasInteractions.ts",
    "relative_path": "client/components/ui/canvasInteractions.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function placeNodeOnCanvas(\n  e: MouseEvent,\n  selectedTool: 'select' | 'box' | 'connector' | 'group',\n  reactFlowRef: MutableRefObject<ReactFlowInstance | null>,\n  handleAddNode: (nodeName: string, parentId: string, data?: { label?: string; icon?: string; style?: any }) => void,\n  viewStateRef?: MutableRefObject<any>,\n  onDone?: (nextTool: 'select' | 'box' | 'connector' | 'group') => void,\n  parentId?: string | null,\n  applyOrchestrator?: (intent: any) => Promise<any>,\n) {\n  console.log('[placeNodeOnCanvas] Called with:', { \n    selectedTool, \n    hasReactFlowRef: !!reactFlowRef?.current, \n    hasHandleAddNode: typeof handleAddNode,\n    hasEvent: !!e,\n    eventType: e?.type,\n    clientX: (e as any)?.clientX,\n    clientY: (e as any)?.clientY\n  });\n  \n  if (selectedTool !== 'box') {\n    console.log('[placeNodeOnCanvas] Skipping - not box tool');\n    return;\n  }\n  // Don't require target - we can use clientX/clientY directly\n  const rf = reactFlowRef.current;\n  if (!rf) {\n    console.log('[placeNodeOnCanvas] Skipping - no ReactFlow instance');\n    return;\n  }\n  \n  // Check if we have coordinates\n  if (typeof (e as any)?.clientX !== 'number' || typeof (e as any)?.clientY !== 'number') {\n    console.log('[placeNodeOnCanvas] Skipping - no client coordinates');\n    return;\n  }\n  const projected = (rf as any).screenToFlowPosition\n    ? (rf as any).screenToFlowPosition({ x: (e as any).clientX, y: (e as any).clientY })\n    : rf.project({ x: (e as any).clientX, y: (e as any).clientY });\n  const snap = (v: number) => Math.round(v / 16) * 16; // match canvas grid\n  // Snap cursor in world space as the node center\n  const snappedCenter = { x: snap(projected.x), y: snap(projected.y) };\n  const NODE_SIZE = 96; // align to 16px grid\n  const half = NODE_SIZE / 2;\n  const topLeft = { x: snappedCenter.x - half, y: snappedCenter.y - half };\n  const id = `user-node-${Date.now()}`;\n\n  // Use Orchestrator if provided (proper FREE mode architecture)\n  if (applyOrchestrator) {\n    console.log('[placeNodeOnCanvas] Using Orchestrator:', { id, parentId: parentId || 'root', position: topLeft });\n    applyOrchestrator({\n      source: 'user',\n      kind: 'free-structural',\n      scopeId: parentId || 'root',\n      payload: {\n        action: 'add-node',\n        nodeId: id,\n        parentId: parentId || 'root',\n        position: { x: topLeft.x, y: topLeft.y },\n        size: { w: NODE_SIZE, h: NODE_SIZE },\n        data: {\n          label: '',  // Empty label for \"Add text\" placeholder\n        }\n      }\n    }).catch(error => {\n      console.error('[placeNodeOnCanvas] Orchestrator failed:', error);\n      throw error; // No fallback - fail loudly\n    });\n  } else {\n    // Fallback to old method (should not be used in FREE mode)\n    console.warn('[placeNodeOnCanvas] Using handleAddNode fallback - this should not happen in FREE mode');\n    handleAddNode(id, parentId || 'root', {\n      label: '',  // Empty label for \"Add text\" placeholder\n    });\n    \n    // Write position to ViewState manually (fallback)\n    if (!viewStateRef || !viewStateRef.current) {\n      throw new Error('[placeNodeOnCanvas] viewStateRef required when not using Orchestrator');\n    }\n    const vs = viewStateRef.current;\n    vs.node = vs.node || {};\n    vs.node[id] = { x: topLeft.x, y: topLeft.y, w: NODE_SIZE, h: NODE_SIZE };\n  }\n\n  // Auto-switch to select tool after creating a node so user can interact with it\n  onDone?.('select');\n}",
    "start_line": 4,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "e",
      "selectedTool",
      "reactFlowRef",
      "handleAddNode",
      "viewStateRef",
      "onDone",
      "parentId",
      "applyOrchestrator"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function placeNodeOnCanvas",
    "component_id": "client.components.ui.canvasInteractions.placeNodeOnCanvas"
  },
  "client.components.ui.input.InputProps": {
    "id": "client.components.ui.input.InputProps",
    "name": "InputProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/ui/input.tsx",
    "relative_path": "client/components/ui/input.tsx",
    "depends_on": [],
    "source_code": "interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}",
    "start_line": 5,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InputProps",
    "component_id": "client.components.ui.input.InputProps"
  },
  "client.components.views.AuthView.AuthViewProps": {
    "id": "client.components.views.AuthView.AuthViewProps",
    "name": "AuthViewProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/views/AuthView.tsx",
    "relative_path": "client/components/views/AuthView.tsx",
    "depends_on": [],
    "source_code": "interface AuthViewProps {\n  isSessionActive?: boolean;\n  isConnecting?: boolean;\n  isAgentReady?: boolean;\n  startSession?: () => void;\n  stopSession?: () => void;\n  sendTextMessage?: (message: string) => void;\n  sendClientEvent?: (event: any) => void;\n  events?: any[];\n  apiEndpoint?: string;\n  isPublicMode?: boolean;\n  rightPanelCollapsed?: boolean;\n}",
    "start_line": 4,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AuthViewProps",
    "component_id": "client.components.views.AuthView.AuthViewProps"
  },
  "client.components.views.AuthView.AuthView": {
    "id": "client.components.views.AuthView.AuthView",
    "name": "AuthView",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/views/AuthView.tsx",
    "relative_path": "client/components/views/AuthView.tsx",
    "depends_on": [
      "client.components.views.AuthView.AuthViewProps"
    ],
    "source_code": "AuthView: React.FC<AuthViewProps> = (props) => {\n  return (\n    <InteractiveCanvas\n      {...props}\n      isPublicMode={false}\n    />\n  );\n}",
    "start_line": 18,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "props"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function AuthView",
    "component_id": "client.components.views.AuthView.AuthView"
  },
  "client.components.views.CanvasView.CanvasViewProps": {
    "id": "client.components.views.CanvasView.CanvasViewProps",
    "name": "CanvasViewProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/views/CanvasView.tsx",
    "relative_path": "client/components/views/CanvasView.tsx",
    "depends_on": [],
    "source_code": "interface CanvasViewProps {\n  isSessionActive?: boolean;\n  isConnecting?: boolean;\n  isAgentReady?: boolean;\n  startSession?: () => void;\n  stopSession?: () => void;\n  sendTextMessage?: (message: string) => void;\n  sendClientEvent?: (event: any) => void;\n  events?: any[];\n  apiEndpoint?: string;\n  isPublicMode?: boolean;\n  rightPanelCollapsed?: boolean;\n}",
    "start_line": 4,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CanvasViewProps",
    "component_id": "client.components.views.CanvasView.CanvasViewProps"
  },
  "client.components.views.CanvasView.CanvasView": {
    "id": "client.components.views.CanvasView.CanvasView",
    "name": "CanvasView",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/views/CanvasView.tsx",
    "relative_path": "client/components/views/CanvasView.tsx",
    "depends_on": [
      "client.components.views.CanvasView.CanvasViewProps"
    ],
    "source_code": "CanvasView: React.FC<CanvasViewProps> = (props) => {\n  return (\n    <InteractiveCanvas\n      {...props}\n      isPublicMode={true}\n    />\n  );\n}",
    "start_line": 18,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "props"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function CanvasView",
    "component_id": "client.components.views.CanvasView.CanvasView"
  },
  "client.components.views.EmbedView.EmbedViewProps": {
    "id": "client.components.views.EmbedView.EmbedViewProps",
    "name": "EmbedViewProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/views/EmbedView.tsx",
    "relative_path": "client/components/views/EmbedView.tsx",
    "depends_on": [],
    "source_code": "interface EmbedViewProps {\n  isSessionActive?: boolean;\n  isConnecting?: boolean;\n  isAgentReady?: boolean;\n  startSession?: () => void;\n  stopSession?: () => void;\n  sendTextMessage?: (message: string) => void;\n  sendClientEvent?: (event: any) => void;\n  events?: any[];\n  apiEndpoint?: string;\n  isPublicMode?: boolean;\n  rightPanelCollapsed?: boolean;\n}",
    "start_line": 4,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EmbedViewProps",
    "component_id": "client.components.views.EmbedView.EmbedViewProps"
  },
  "client.components.views.EmbedView.EmbedView": {
    "id": "client.components.views.EmbedView.EmbedView",
    "name": "EmbedView",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/components/views/EmbedView.tsx",
    "relative_path": "client/components/views/EmbedView.tsx",
    "depends_on": [
      "client.components.views.EmbedView.EmbedViewProps"
    ],
    "source_code": "EmbedView: React.FC<EmbedViewProps> = (props) => {\n  return (\n    <InteractiveCanvas\n      {...props}\n      isPublicMode={true}\n    />\n  );\n}",
    "start_line": 18,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "props"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function EmbedView",
    "component_id": "client.components.views.EmbedView.EmbedView"
  },
  "client.contexts.ApiEndpointContext.ApiEndpointContextType": {
    "id": "client.contexts.ApiEndpointContext.ApiEndpointContextType",
    "name": "ApiEndpointContextType",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ApiEndpointContext.tsx",
    "relative_path": "client/contexts/ApiEndpointContext.tsx",
    "depends_on": [],
    "source_code": "interface ApiEndpointContextType {\n  apiEndpoint?: string;\n}",
    "start_line": 3,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ApiEndpointContextType",
    "component_id": "client.contexts.ApiEndpointContext.ApiEndpointContextType"
  },
  "client.contexts.ApiEndpointContext.useApiEndpoint": {
    "id": "client.contexts.ApiEndpointContext.useApiEndpoint",
    "name": "useApiEndpoint",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ApiEndpointContext.tsx",
    "relative_path": "client/contexts/ApiEndpointContext.tsx",
    "depends_on": [],
    "source_code": "useApiEndpoint = () => {\n  const context = useContext(ApiEndpointContext);\n  return context.apiEndpoint;\n}",
    "start_line": 20,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useApiEndpoint",
    "component_id": "client.contexts.ApiEndpointContext.useApiEndpoint"
  },
  "client.contexts.ApiEndpointContext.buildAssetUrl": {
    "id": "client.contexts.ApiEndpointContext.buildAssetUrl",
    "name": "buildAssetUrl",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ApiEndpointContext.tsx",
    "relative_path": "client/contexts/ApiEndpointContext.tsx",
    "depends_on": [],
    "source_code": "buildAssetUrl = (path: string, apiEndpoint?: string): string => {\n  if (!apiEndpoint) {\n    return path; // Fallback to relative URL\n  }\n  \n  // Remove leading slash if present\n  const cleanPath = path.startsWith('/') ? path.slice(1) : path;\n  \n  // Ensure apiEndpoint doesn't end with slash\n  const cleanEndpoint = apiEndpoint.endsWith('/') ? apiEndpoint.slice(0, -1) : apiEndpoint;\n  \n  return `${cleanEndpoint}/${cleanPath}`;\n}",
    "start_line": 26,
    "end_line": 38,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "path",
      "apiEndpoint"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function buildAssetUrl",
    "component_id": "client.contexts.ApiEndpointContext.buildAssetUrl"
  },
  "client.contexts.EdgeRoutingContext.EdgeRoutingContextValue": {
    "id": "client.contexts.EdgeRoutingContext.EdgeRoutingContextValue",
    "name": "EdgeRoutingContextValue",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/EdgeRoutingContext.tsx",
    "relative_path": "client/contexts/EdgeRoutingContext.tsx",
    "depends_on": [
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "interface EdgeRoutingContextValue {\n  rawGraph: RawGraph | null;\n  viewState: ViewState | null;\n}",
    "start_line": 14,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeRoutingContextValue",
    "component_id": "client.contexts.EdgeRoutingContext.EdgeRoutingContextValue"
  },
  "client.contexts.EdgeRoutingContext.useEdgeRouting": {
    "id": "client.contexts.EdgeRoutingContext.useEdgeRouting",
    "name": "useEdgeRouting",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/EdgeRoutingContext.tsx",
    "relative_path": "client/contexts/EdgeRoutingContext.tsx",
    "depends_on": [],
    "source_code": "useEdgeRouting = () => useContext(EdgeRoutingContext)",
    "start_line": 24,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useEdgeRouting",
    "component_id": "client.contexts.EdgeRoutingContext.useEdgeRouting"
  },
  "client.contexts.EdgeRoutingContext.EdgeRoutingProviderProps": {
    "id": "client.contexts.EdgeRoutingContext.EdgeRoutingProviderProps",
    "name": "EdgeRoutingProviderProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/EdgeRoutingContext.tsx",
    "relative_path": "client/contexts/EdgeRoutingContext.tsx",
    "depends_on": [
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "interface EdgeRoutingProviderProps {\n  children: ReactNode;\n  rawGraph: RawGraph | null;\n  viewState: ViewState | null;\n}",
    "start_line": 26,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeRoutingProviderProps",
    "component_id": "client.contexts.EdgeRoutingContext.EdgeRoutingProviderProps"
  },
  "client.contexts.NodeInteractionContext.NodeInteractionContextValue": {
    "id": "client.contexts.NodeInteractionContext.NodeInteractionContextValue",
    "name": "NodeInteractionContextValue",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/NodeInteractionContext.tsx",
    "relative_path": "client/contexts/NodeInteractionContext.tsx",
    "depends_on": [],
    "source_code": "interface NodeInteractionContextValue {\n  selectedTool: string;\n  connectingFrom: string | null;\n  connectingFromHandle: string | null;\n  handleConnectorDotClick: (nodeId: string, handleId: string) => void;\n  handleLabelChange: (id: string, label: string) => void;\n  handleAddNodeToGroup: (groupId: string) => void;\n  handleArrangeGroup?: (groupId: string) => void;\n  selectedNodeIds: string[];\n}",
    "start_line": 3,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeInteractionContextValue",
    "component_id": "client.contexts.NodeInteractionContext.NodeInteractionContextValue"
  },
  "client.contexts.NodeInteractionContext.useNodeInteractions": {
    "id": "client.contexts.NodeInteractionContext.useNodeInteractions",
    "name": "useNodeInteractions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/NodeInteractionContext.tsx",
    "relative_path": "client/contexts/NodeInteractionContext.tsx",
    "depends_on": [
      "client.contexts.NodeInteractionContext.NodeInteractionContextValue"
    ],
    "source_code": "useNodeInteractions = (): NodeInteractionContextValue | null => {\n  return useContext(NodeInteractionContext);\n}",
    "start_line": 16,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useNodeInteractions",
    "component_id": "client.contexts.NodeInteractionContext.useNodeInteractions"
  },
  "client.contexts.NodeStyleContext.NodeStyleSettings": {
    "id": "client.contexts.NodeStyleContext.NodeStyleSettings",
    "name": "NodeStyleSettings",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/NodeStyleContext.tsx",
    "relative_path": "client/contexts/NodeStyleContext.tsx",
    "depends_on": [],
    "source_code": "interface NodeStyleSettings {\n  iconSize: number;\n  nodePaddingVertical: number; // top and bottom\n  nodePaddingHorizontal: number; // left and right\n  textPadding: number;\n}",
    "start_line": 3,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeStyleSettings",
    "component_id": "client.contexts.NodeStyleContext.NodeStyleSettings"
  },
  "client.contexts.NodeStyleContext.NodeStyleContextType": {
    "id": "client.contexts.NodeStyleContext.NodeStyleContextType",
    "name": "NodeStyleContextType",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/NodeStyleContext.tsx",
    "relative_path": "client/contexts/NodeStyleContext.tsx",
    "depends_on": [
      "client.contexts.NodeStyleContext.NodeStyleSettings"
    ],
    "source_code": "interface NodeStyleContextType {\n  settings: NodeStyleSettings;\n  updateSettings: (settings: Partial<NodeStyleSettings>) => void;\n}",
    "start_line": 10,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeStyleContextType",
    "component_id": "client.contexts.NodeStyleContext.NodeStyleContextType"
  },
  "client.contexts.NodeStyleContext.useNodeStyle": {
    "id": "client.contexts.NodeStyleContext.useNodeStyle",
    "name": "useNodeStyle",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/NodeStyleContext.tsx",
    "relative_path": "client/contexts/NodeStyleContext.tsx",
    "depends_on": [],
    "source_code": "useNodeStyle = () => {\n  const context = useContext(NodeStyleContext);\n  if (!context) {\n    return { settings: defaultSettings, updateSettings: () => {} };\n  }\n  return context;\n}",
    "start_line": 38,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useNodeStyle",
    "component_id": "client.contexts.NodeStyleContext.useNodeStyle"
  },
  "client.contexts.ViewModeContext.ViewMode": {
    "id": "client.contexts.ViewModeContext.ViewMode",
    "name": "ViewMode",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [],
    "source_code": "type ViewMode = 'embed' | 'canvas' | 'auth';",
    "start_line": 4,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ViewMode",
    "component_id": "client.contexts.ViewModeContext.ViewMode"
  },
  "client.contexts.ViewModeContext.LibavoidOptions": {
    "id": "client.contexts.ViewModeContext.LibavoidOptions",
    "name": "LibavoidOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [],
    "source_code": "interface LibavoidOptions {\n  shapeBufferDistance: number; // edge-to-node spacing\n  portEdgeSpacing: number; // spacing between edges at the same port (in pixels)\n  routingType: 'orthogonal' | 'polyline';\n  hateCrossings: boolean;\n  nudgeOrthSegments: boolean;\n  nudgeSharedPaths: boolean;\n  nudgeTouchingColinear: boolean;\n  segmentPenalty: number;\n  bendPenalty: number;\n  crossingPenalty: number;\n  sharedPathPenalty: number;\n  // idealNudgingDistance: The PRIMARY parameter for uniform spacing between parallel edges\n  // MUST match portEdgeSpacing for uniform spacing\n  idealNudgingDistance?: number;\n}",
    "start_line": 6,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LibavoidOptions",
    "component_id": "client.contexts.ViewModeContext.LibavoidOptions"
  },
  "client.contexts.ViewModeContext.ViewModeConfig": {
    "id": "client.contexts.ViewModeContext.ViewModeConfig",
    "name": "ViewModeConfig",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.LibavoidOptions",
      "client.contexts.ViewModeContext.ViewMode"
    ],
    "source_code": "interface ViewModeConfig {\n  mode: ViewMode;\n  isEmbedded: boolean;\n  \n  // Authentication & User Features\n  requiresAuth: boolean;\n  showSaveButton: boolean;\n  showEditButton: boolean;\n  showProfileSection: boolean;\n  showSidebar: boolean;\n  \n  // Content & Collaboration Features\n  allowSharing: boolean;\n  allowExporting: boolean;\n  allowArchitectureManagement: boolean;\n  \n  // UI Features\n  showDevPanel: boolean;\n  showSettings: boolean;\n  showChatPanel: boolean;\n  showAgentIcon: boolean;\n  showChatbox: boolean;\n\n  // Libavoid routing defaults (for FREE mode)\n  libavoidDefaults: LibavoidOptions;\n}",
    "start_line": 23,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ViewModeConfig",
    "component_id": "client.contexts.ViewModeContext.ViewModeConfig"
  },
  "client.contexts.ViewModeContext.ViewModeContextValue": {
    "id": "client.contexts.ViewModeContext.ViewModeContextValue",
    "name": "ViewModeContextValue",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.LibavoidOptions",
      "client.contexts.ViewModeContext.ViewModeConfig",
      "client.contexts.ViewModeContext.ViewMode"
    ],
    "source_code": "interface ViewModeContextValue {\n  config: ViewModeConfig;\n  mode: ViewMode;\n  isEmbedded: boolean;\n  libavoidOptions?: LibavoidOptions; // Runtime override for libavoid options\n}",
    "start_line": 140,
    "end_line": 145,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ViewModeContextValue",
    "component_id": "client.contexts.ViewModeContext.ViewModeContextValue"
  },
  "client.contexts.ViewModeContext.useViewMode": {
    "id": "client.contexts.ViewModeContext.useViewMode",
    "name": "useViewMode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.ViewModeContextValue"
    ],
    "source_code": "function useViewMode(): ViewModeContextValue {\n  const context = useContext(ViewModeContext);\n  if (!context) {\n    throw new Error('useViewMode must be used within a ViewModeProvider');\n  }\n  return context;\n}",
    "start_line": 149,
    "end_line": 155,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useViewMode",
    "component_id": "client.contexts.ViewModeContext.useViewMode"
  },
  "client.contexts.ViewModeContext.BooleanKeys": {
    "id": "client.contexts.ViewModeContext.BooleanKeys",
    "name": "BooleanKeys",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [],
    "source_code": "type BooleanKeys<T> = { [K in keyof T]-?: T[K] extends boolean ? K : never }[keyof T];",
    "start_line": 158,
    "end_line": 158,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type BooleanKeys",
    "component_id": "client.contexts.ViewModeContext.BooleanKeys"
  },
  "client.contexts.ViewModeContext.FeatureKey": {
    "id": "client.contexts.ViewModeContext.FeatureKey",
    "name": "FeatureKey",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.ViewModeConfig"
    ],
    "source_code": "type FeatureKey = BooleanKeys<ViewModeConfig>;",
    "start_line": 159,
    "end_line": 159,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type FeatureKey",
    "component_id": "client.contexts.ViewModeContext.FeatureKey"
  },
  "client.contexts.ViewModeContext.useFeature": {
    "id": "client.contexts.ViewModeContext.useFeature",
    "name": "useFeature",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.useViewMode",
      "client.contexts.ViewModeContext.FeatureKey"
    ],
    "source_code": "function useFeature(flag: FeatureKey): boolean {\n  const { config } = useViewMode();\n  return Boolean(config[flag]);\n}",
    "start_line": 161,
    "end_line": 164,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "flag"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useFeature",
    "component_id": "client.contexts.ViewModeContext.useFeature"
  },
  "client.contexts.ViewModeContext.FeatureGate": {
    "id": "client.contexts.ViewModeContext.FeatureGate",
    "name": "FeatureGate",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.useFeature",
      "client.contexts.ViewModeContext.FeatureKey"
    ],
    "source_code": "function FeatureGate(\n  { flag, children, fallback = null }:\n  { flag: FeatureKey; children: React.ReactNode; fallback?: React.ReactNode }\n) {\n  return useFeature(flag) ? <>{children}</> : <>{fallback}</>;\n}",
    "start_line": 167,
    "end_line": 172,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function FeatureGate",
    "component_id": "client.contexts.ViewModeContext.FeatureGate"
  },
  "client.contexts.ViewModeContext.ViewModeProviderProps": {
    "id": "client.contexts.ViewModeContext.ViewModeProviderProps",
    "name": "ViewModeProviderProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.ViewMode"
    ],
    "source_code": "interface ViewModeProviderProps {\n  children: React.ReactNode;\n  fallbackMode?: ViewMode;\n}",
    "start_line": 174,
    "end_line": 177,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ViewModeProviderProps",
    "component_id": "client.contexts.ViewModeContext.ViewModeProviderProps"
  },
  "client.contexts.ViewModeContext.ViewModeProvider": {
    "id": "client.contexts.ViewModeContext.ViewModeProvider",
    "name": "ViewModeProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/contexts/ViewModeContext.tsx",
    "relative_path": "client/contexts/ViewModeContext.tsx",
    "depends_on": [
      "client.contexts.ViewModeContext.ViewModeProviderProps",
      "client.contexts.ViewModeContext.ViewModeConfig",
      "client.contexts.ViewModeContext.ViewMode",
      "client.utils.copyToClipboard.isEmbedded",
      "client.contexts.ViewModeContext.ViewModeContextValue"
    ],
    "source_code": "function ViewModeProvider({ children, fallbackMode = 'canvas' }: ViewModeProviderProps) {\n  const config = useMemo(() => {\n    // Simple path-based routing - no environment complexity\n    const getViewMode = (): { mode: ViewMode; isEmbedded: boolean } => {\n      if (typeof window === 'undefined') {\n        return { mode: fallbackMode, isEmbedded: false };\n      }\n      \n      // Optional: localStorage override for QA (centralized here)\n      const override = localStorage.getItem('viewModeOverride') as ViewMode | null;\n      if (override && ['embed', 'canvas', 'auth'].includes(override)) {\n        return { mode: override, isEmbedded: false };\n      }\n      \n      const path = window.location.pathname;\n      \n      // Simple path-based mode detection\n      if (path === '/embed') {\n        const isEmbedded = window.parent !== window;\n        return { mode: 'embed', isEmbedded };\n      } else if (path === '/canvas') {\n        return { mode: 'canvas', isEmbedded: false };\n      } else if (path === '/auth') {\n        return { mode: 'auth', isEmbedded: false };\n      }\n      \n      // Default: root path (/) - determine mode based on auth state\n      // Check if user is authenticated (Firebase auth)\n      try {\n        const { auth } = require('../lib/firebase');\n        if (auth && auth.currentUser) {\n          // User is authenticated - use auth mode\n          return { mode: 'auth', isEmbedded: false };\n        }\n      } catch (error) {\n        // Firebase not available or error - fall back to canvas\n      }\n      \n      // Not authenticated - use canvas for root path\n      return { mode: 'canvas', isEmbedded: false };\n    };\n    \n    const { mode, isEmbedded } = getViewMode();\n    const baseConfig = VIEW_MODE_CONFIGS[mode];\n    \n    const fullConfig: ViewModeConfig = {\n      mode,\n      isEmbedded,\n      ...baseConfig\n    };\n    \n    return fullConfig;\n  }, [fallbackMode]);\n  \n  const contextValue: ViewModeContextValue = {\n    config,\n    mode: config.mode,\n    isEmbedded: config.isEmbedded\n  };\n  \n  return (\n    <ViewModeContext.Provider value={contextValue}>\n      {children}\n    </ViewModeContext.Provider>\n  );\n}",
    "start_line": 179,
    "end_line": 244,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ViewModeProvider",
    "component_id": "client.contexts.ViewModeContext.ViewModeProvider"
  },
  "client.core.__tests__.layer-sync.test.LayerState": {
    "id": "client.core.__tests__.layer-sync.test.LayerState",
    "name": "LayerState",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/__tests__/layer-sync.test.ts",
    "relative_path": "client/core/__tests__/layer-sync.test.ts",
    "depends_on": [],
    "source_code": "interface LayerState {\n  domainNodeCount: number;\n  domainNodeIds: string[];\n  viewStateNodeCount: number;\n  viewStateNodeIds: string[];\n  viewStateGroupCount: number;\n  viewStateGroupIds: string[];\n  reactFlowNodeCount: number;\n  reactFlowNodeIds: string[];\n}",
    "start_line": 28,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LayerState",
    "component_id": "client.core.__tests__.layer-sync.test.LayerState"
  },
  "client.core.__tests__.layer-sync.test.getLayerState": {
    "id": "client.core.__tests__.layer-sync.test.getLayerState",
    "name": "getLayerState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/__tests__/layer-sync.test.ts",
    "relative_path": "client/core/__tests__/layer-sync.test.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph",
      "client.core.__tests__.layer-sync.test.LayerState",
      "client.viewstate.ViewState.ViewState",
      "client.core.__tests__.layer-sync.test.collectDomainNodeIds"
    ],
    "source_code": "function getLayerState(\n  graph: RawGraph,\n  viewState: ViewState,\n  nodes: Node[]\n): LayerState {\n  const domainNodeIds = collectDomainNodeIds(graph);\n  const viewStateNodeIds = Object.keys(viewState.node || {});\n  const viewStateGroupIds = Object.keys(viewState.group || {});\n  const reactFlowNodeIds = nodes.map(n => n.id);\n\n  return {\n    domainNodeCount: domainNodeIds.length,\n    domainNodeIds,\n    viewStateNodeCount: viewStateNodeIds.length,\n    viewStateNodeIds,\n    viewStateGroupCount: viewStateGroupIds.length,\n    viewStateGroupIds,\n    reactFlowNodeCount: nodes.length,\n    reactFlowNodeIds\n  };\n}",
    "start_line": 39,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "viewState",
      "nodes"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getLayerState",
    "component_id": "client.core.__tests__.layer-sync.test.getLayerState"
  },
  "client.core.__tests__.layer-sync.test.collectDomainNodeIds": {
    "id": "client.core.__tests__.layer-sync.test.collectDomainNodeIds",
    "name": "collectDomainNodeIds",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/__tests__/layer-sync.test.ts",
    "relative_path": "client/core/__tests__/layer-sync.test.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "function collectDomainNodeIds(graph: RawGraph): string[] {\n  const ids: string[] = [];\n  const traverse = (node: any) => {\n    if (node.id && node.id !== 'root') {\n      ids.push(node.id);\n    }\n    if (node.children) {\n      node.children.forEach(traverse);\n    }\n  };\n  if (graph.children) {\n    graph.children.forEach(traverse);\n  }\n  return ids;\n}",
    "start_line": 61,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function collectDomainNodeIds",
    "component_id": "client.core.__tests__.layer-sync.test.collectDomainNodeIds"
  },
  "client.core.__tests__.layer-sync.test.assertLayerSync": {
    "id": "client.core.__tests__.layer-sync.test.assertLayerSync",
    "name": "assertLayerSync",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/__tests__/layer-sync.test.ts",
    "relative_path": "client/core/__tests__/layer-sync.test.ts",
    "depends_on": [
      "scripts.test-vercel-preview.error",
      "client.core.__tests__.layer-sync.test.LayerState"
    ],
    "source_code": "function assertLayerSync(state: LayerState, context: string) {\n  const errors: string[] = [];\n\n  // Combine ViewState nodes and groups for total count\n  // Groups are stored separately but should be counted as \"nodes\" for sync purposes\n  const allViewStateIds = [...state.viewStateNodeIds, ...state.viewStateGroupIds.filter(id => !state.viewStateNodeIds.includes(id))];\n  const totalViewStateCount = allViewStateIds.length;\n\n  // Check counts match (domain vs combined viewstate)\n  if (state.domainNodeCount !== totalViewStateCount) {\n    errors.push(`Domain (${state.domainNodeCount}) !== ViewState (${totalViewStateCount})`);\n  }\n  if (state.domainNodeCount !== state.reactFlowNodeCount) {\n    errors.push(`Domain (${state.domainNodeCount}) !== ReactFlow (${state.reactFlowNodeCount})`);\n  }\n\n  // Check for ghost nodes (in ViewState but not in Domain)\n  const ghostNodes = allViewStateIds.filter(id => !state.domainNodeIds.includes(id));\n  if (ghostNodes.length > 0) {\n    errors.push(`Ghost nodes in ViewState: ${ghostNodes.join(', ')}`);\n  }\n\n  // Check for invisible nodes (in Domain but not in ViewState)\n  const invisibleNodes = state.domainNodeIds.filter(id => !allViewStateIds.includes(id));\n  if (invisibleNodes.length > 0) {\n    errors.push(`Invisible nodes (no ViewState): ${invisibleNodes.join(', ')}`);\n  }\n\n  // Check for orphaned ReactFlow nodes\n  const orphanedRFNodes = state.reactFlowNodeIds.filter(id => !state.domainNodeIds.includes(id));\n  if (orphanedRFNodes.length > 0) {\n    errors.push(`Orphaned ReactFlow nodes: ${orphanedRFNodes.join(', ')}`);\n  }\n\n  if (errors.length > 0) {\n    console.error(`‚ùå [LAYER SYNC FAILURE] ${context}:`, errors);\n    console.error('State:', state);\n  }\n\n  expect(errors).toEqual([]);\n}",
    "start_line": 77,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function assertLayerSync",
    "component_id": "client.core.__tests__.layer-sync.test.assertLayerSync"
  },
  "client.core.drag.GroupDragHandler.snap": {
    "id": "client.core.drag.GroupDragHandler.snap",
    "name": "snap",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/drag/GroupDragHandler.ts",
    "relative_path": "client/core/drag/GroupDragHandler.ts",
    "depends_on": [],
    "source_code": "snap = (v: number) => Math.round(v / GRID_SIZE) * GRID_SIZE",
    "start_line": 24,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "v"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function snap",
    "component_id": "client.core.drag.GroupDragHandler.snap"
  },
  "client.core.drag.GroupDragHandler.findNodeById": {
    "id": "client.core.drag.GroupDragHandler.findNodeById",
    "name": "findNodeById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/drag/GroupDragHandler.ts",
    "relative_path": "client/core/drag/GroupDragHandler.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "function findNodeById(graph: RawGraph, nodeId: string): any | null {\n  const find = (n: any, targetId: string): any => {\n    if (n.id === targetId) return n;\n    if (n.children) {\n      for (const child of n.children) {\n        const result = find(child, targetId);\n        if (result) return result;\n      }\n    }\n    return null;\n  };\n  return find(graph, nodeId);\n}",
    "start_line": 29,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "nodeId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findNodeById",
    "component_id": "client.core.drag.GroupDragHandler.findNodeById"
  },
  "client.core.drag.GroupDragHandler.GroupDragResult": {
    "id": "client.core.drag.GroupDragHandler.GroupDragResult",
    "name": "GroupDragResult",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/drag/GroupDragHandler.ts",
    "relative_path": "client/core/drag/GroupDragHandler.ts",
    "depends_on": [],
    "source_code": "interface GroupDragResult {\n  viewStateUpdated: boolean;\n  groupId: string;\n  newPosition: { x: number; y: number };\n  childrenUpdated: string[];\n}",
    "start_line": 43,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GroupDragResult",
    "component_id": "client.core.drag.GroupDragHandler.GroupDragResult"
  },
  "client.core.drag.GroupDragHandler.handleGroupDrag": {
    "id": "client.core.drag.GroupDragHandler.handleGroupDrag",
    "name": "handleGroupDrag",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/drag/GroupDragHandler.ts",
    "relative_path": "client/core/drag/GroupDragHandler.ts",
    "depends_on": [
      "client.core.drag.GroupDragHandler.snap",
      "scripts.test-vercel-preview.log",
      "client.viewstate.ViewState.ViewState",
      "client.components.graph.types.index.RawGraph",
      "client.core.drag.GroupDragHandler.findNodeById",
      "client.core.drag.GroupDragHandler.GroupDragResult"
    ],
    "source_code": "function handleGroupDrag(\n  changes: NodeChange[],\n  currentNodes: Node[],\n  viewStateRef: { current: ViewState | null },\n  rawGraphRef: { current: RawGraph | null }\n): GroupDragResult[] {\n  const results: GroupDragResult[] = [];\n  \n  // Filter to only position changes\n  const positionChanges = changes.filter(\n    (ch): ch is NodeChange & { type: 'position'; id: string; position: { x: number; y: number } } =>\n      ch.type === 'position' && 'position' in ch && ch.position !== undefined\n  );\n  \n  for (const change of positionChanges) {\n    const changedNode = currentNodes.find((n) => n.id === change.id);\n    if (!changedNode) continue;\n    \n    // Only handle groups - regular nodes are handled in onNodeDragStop\n    const isGroup = changedNode.type === 'group' || changedNode.type === 'draftGroup';\n    if (!isGroup) continue;\n    \n    const existingGeom = viewStateRef.current?.group?.[changedNode.id];\n    const absoluteX = snap(change.position.x);\n    const absoluteY = snap(change.position.y);\n    \n    console.log('[GroupDragHandler] Position change detected:', {\n      groupId: changedNode.id,\n      newPosition: { x: absoluteX, y: absoluteY },\n      oldPosition: existingGeom ? { x: existingGeom.x, y: existingGeom.y } : null,\n    });\n    \n    // Calculate delta from previous position\n    const deltaX = existingGeom ? absoluteX - existingGeom.x : 0;\n    const deltaY = existingGeom ? absoluteY - existingGeom.y : 0;\n    \n    const childrenUpdated: string[] = [];\n    \n    // Update group position in ViewState\n    if (viewStateRef.current) {\n      viewStateRef.current.group[changedNode.id] = {\n        x: absoluteX,\n        y: absoluteY,\n        w: existingGeom?.w ?? (changedNode.data as any)?.width ?? 480,\n        h: existingGeom?.h ?? (changedNode.data as any)?.height ?? 320,\n      };\n      viewStateRef.current.node[changedNode.id] = viewStateRef.current.group[changedNode.id];\n      \n      // Update children's absolute positions by the same delta\n      if ((deltaX !== 0 || deltaY !== 0) && rawGraphRef.current) {\n        const groupNode = findNodeById(rawGraphRef.current, changedNode.id);\n        if (groupNode?.children?.length) {\n          console.log('[GroupDragHandler] Updating children by delta:', {\n            deltaX,\n            deltaY,\n            children: groupNode.children.map((c: any) => c.id)\n          });\n          \n          for (const child of groupNode.children) {\n            const childGeom = viewStateRef.current.node?.[child.id];\n            if (childGeom) {\n              viewStateRef.current.node[child.id] = {\n                ...childGeom,\n                x: childGeom.x + deltaX,\n                y: childGeom.y + deltaY,\n              };\n              childrenUpdated.push(child.id);\n            }\n            \n            // Also update nested groups\n            if (viewStateRef.current.group?.[child.id]) {\n              viewStateRef.current.group[child.id] = {\n                ...viewStateRef.current.group[child.id],\n                x: viewStateRef.current.group[child.id].x + deltaX,\n                y: viewStateRef.current.group[child.id].y + deltaY,\n              };\n            }\n          }\n        }\n      }\n      \n      results.push({\n        viewStateUpdated: true,\n        groupId: changedNode.id,\n        newPosition: { x: absoluteX, y: absoluteY },\n        childrenUpdated,\n      });\n    }\n  }\n  \n  return results;\n}",
    "start_line": 63,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changes",
      "currentNodes",
      "viewStateRef",
      "rawGraphRef"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handleGroupDrag",
    "component_id": "client.core.drag.GroupDragHandler.handleGroupDrag"
  },
  "client.core.drag.GroupDragHandler.hasGroupChanges": {
    "id": "client.core.drag.GroupDragHandler.hasGroupChanges",
    "name": "hasGroupChanges",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/drag/GroupDragHandler.ts",
    "relative_path": "client/core/drag/GroupDragHandler.ts",
    "depends_on": [],
    "source_code": "function hasGroupChanges(changes: NodeChange[], nodes: Node[]): boolean {\n  return changes.some((ch) => {\n    if (ch.type !== 'position') return false;\n    const node = nodes.find((n) => n.id === (ch as any).id);\n    return node?.type === 'group' || node?.type === 'draftGroup';\n  });\n}",
    "start_line": 159,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changes",
      "nodes"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function hasGroupChanges",
    "component_id": "client.core.drag.GroupDragHandler.hasGroupChanges"
  },
  "client.core.layout.ScopedLayoutRunner.extractSubtree": {
    "id": "client.core.layout.ScopedLayoutRunner.extractSubtree",
    "name": "extractSubtree",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/layout/ScopedLayoutRunner.ts",
    "relative_path": "client/core/layout/ScopedLayoutRunner.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.findNodeById",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function extractSubtree(graph: RawGraph, scopeId: string): ElkGraphNode | null {\n  // Find the scope node in the graph\n  const scopeNode = findNodeById(graph, scopeId);\n  if (!scopeNode) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`[ScopedLayoutRunner] Scope node \"${scopeId}\" not found in graph`);\n    }\n    return null;\n  }\n\n  // Deep clone the subtree\n  return JSON.parse(JSON.stringify(scopeNode));\n}",
    "start_line": 29,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "scopeId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractSubtree",
    "component_id": "client.core.layout.ScopedLayoutRunner.extractSubtree"
  },
  "client.core.layout.ScopedLayoutRunner.computeScopeBboxTopLeft": {
    "id": "client.core.layout.ScopedLayoutRunner.computeScopeBboxTopLeft",
    "name": "computeScopeBboxTopLeft",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/layout/ScopedLayoutRunner.ts",
    "relative_path": "client/core/layout/ScopedLayoutRunner.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "client.viewstate.ViewState.ViewState",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function computeScopeBboxTopLeft(\n  scopeId: string,\n  subtree: ElkGraphNode,\n  viewState: ViewState\n): { x: number; y: number } | null {\n  // Collect all IDs in the subtree (including scope itself)\n  const ids = new Set<string>([scopeId]);\n  \n  function collectIds(node: ElkGraphNode): void {\n    if (node.children) {\n      node.children.forEach(child => {\n        ids.add(child.id);\n        collectIds(child);\n      });\n    }\n  }\n  \n  collectIds(subtree);\n\n  // Find minimum x and y from ViewState\n  let minX = Infinity;\n  let minY = Infinity;\n  let foundAny = false;\n\n  for (const id of ids) {\n    const nodeGeom = viewState.node?.[id];\n    const groupGeom = viewState.group?.[id];\n    const geom = nodeGeom || groupGeom;\n\n    if (geom && Number.isFinite(geom.x) && Number.isFinite(geom.y)) {\n      minX = Math.min(minX, geom.x);\n      minY = Math.min(minY, geom.y);\n      foundAny = true;\n    }\n  }\n\n  if (!foundAny) {\n    // No existing geometry - return null (will use ELK's natural position)\n    return null;\n  }\n\n  return { x: minX, y: minY };\n}",
    "start_line": 47,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "scopeId",
      "subtree",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function computeScopeBboxTopLeft",
    "component_id": "client.core.layout.ScopedLayoutRunner.computeScopeBboxTopLeft"
  },
  "client.core.layout.ScopedLayoutRunner.translateLayout": {
    "id": "client.core.layout.ScopedLayoutRunner.translateLayout",
    "name": "translateLayout",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/layout/ScopedLayoutRunner.ts",
    "relative_path": "client/core/layout/ScopedLayoutRunner.ts",
    "depends_on": [
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function translateLayout(\n  layout: ElkGraphNode,\n  anchorTopLeft: { x: number; y: number },\n  elkTopLeft: { x: number; y: number }\n): void {\n  const dx = anchorTopLeft.x - elkTopLeft.x;\n  const dy = anchorTopLeft.y - elkTopLeft.y;\n\n  function translateNode(node: ElkGraphNode): void {\n    if (Number.isFinite(node.x) && Number.isFinite(node.y)) {\n      node.x = (node.x || 0) + dx;\n      node.y = (node.y || 0) + dy;\n    }\n\n    if (node.children) {\n      node.children.forEach(translateNode);\n    }\n  }\n\n  translateNode(layout);\n}",
    "start_line": 94,
    "end_line": 114,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout",
      "anchorTopLeft",
      "elkTopLeft"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function translateLayout",
    "component_id": "client.core.layout.ScopedLayoutRunner.translateLayout"
  },
  "client.core.layout.ScopedLayoutRunner.autoFitGroupFrame": {
    "id": "client.core.layout.ScopedLayoutRunner.autoFitGroupFrame",
    "name": "autoFitGroupFrame",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/layout/ScopedLayoutRunner.ts",
    "relative_path": "client/core/layout/ScopedLayoutRunner.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.findNodeById",
      "client.viewstate.ViewState.ViewState",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function autoFitGroupFrame(\n  groupNode: ElkGraphNode,\n  layout: ElkGraphNode,\n  viewState: ViewState\n): { w: number; h: number } {\n  if (!groupNode.children || groupNode.children.length === 0) {\n    // No children - try to use existing ViewState size, otherwise default\n    const existingGeom = viewState.group?.[groupNode.id];\n    if (existingGeom?.w && existingGeom?.h) {\n      return { w: existingGeom.w, h: existingGeom.h };\n    }\n    return {\n      w: NON_ROOT_DEFAULT_OPTIONS.width * 3,\n      h: 96 * 3\n    };\n  }\n\n  // Find the group in the layout\n  const layoutGroup = findNodeById(layout, groupNode.id);\n  if (!layoutGroup) {\n    // Try to use existing ViewState size\n    const existingGeom = viewState.group?.[groupNode.id];\n    if (existingGeom?.w && existingGeom?.h) {\n      return { w: existingGeom.w, h: existingGeom.h };\n    }\n    return {\n      w: NON_ROOT_DEFAULT_OPTIONS.width * 3,\n      h: 96 * 3\n    };\n  }\n\n  // Compute bounding box of children\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  function computeBbox(node: ElkGraphNode): void {\n    if (node.id === groupNode.id) {\n      // Skip the group itself, process children\n      if (node.children) {\n        node.children.forEach(computeBbox);\n      }\n      return;\n    }\n\n    const x = node.x || 0;\n    const y = node.y || 0;\n    \n    // Check if this is a nested group and use ViewState dimensions if available\n    const isNestedGroup = !!(node.children && node.children.length > 0);\n    let w: number;\n    let h: number;\n    \n    if (isNestedGroup) {\n      // For nested groups, use ViewState dimensions if available\n      const groupGeom = viewState.group?.[node.id];\n      if (groupGeom?.w && groupGeom?.h) {\n        w = groupGeom.w;\n        h = groupGeom.h;\n      } else {\n        // Fallback to ELK output or default\n        w = node.width || NON_ROOT_DEFAULT_OPTIONS.width * 3;\n        h = node.height || 96 * 3;\n      }\n    } else {\n      // Regular nodes: use ViewState or ELK output or default\n      const nodeGeom = viewState.node?.[node.id];\n      if (nodeGeom?.w && nodeGeom?.h) {\n        w = nodeGeom.w;\n        h = nodeGeom.h;\n      } else {\n        w = node.width || NON_ROOT_DEFAULT_OPTIONS.width;\n        h = node.height || 96;\n      }\n    }\n\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x + w);\n    maxY = Math.max(maxY, y + h);\n  }\n\n  computeBbox(layoutGroup);\n\n  if (!Number.isFinite(minX)) {\n    // No valid children - try to use existing ViewState size\n    const existingGeom = viewState.group?.[groupNode.id];\n    if (existingGeom?.w && existingGeom?.h) {\n      return { w: existingGeom.w, h: existingGeom.h };\n    }\n    return {\n      w: NON_ROOT_DEFAULT_OPTIONS.width * 3,\n      h: 96 * 3\n    };\n  }\n\n  // Add padding using centralized constant\n  return {\n    w: Math.max(maxX - minX + GROUP_FRAME_PADDING * 2, NON_ROOT_DEFAULT_OPTIONS.width * 3),\n    h: Math.max(maxY - minY + GROUP_FRAME_PADDING * 2, 96 * 3)\n  };\n}",
    "start_line": 120,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "groupNode",
      "layout",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function autoFitGroupFrame",
    "component_id": "client.core.layout.ScopedLayoutRunner.autoFitGroupFrame"
  },
  "client.core.layout.ScopedLayoutRunner.extractGeometryFromLayout": {
    "id": "client.core.layout.ScopedLayoutRunner.extractGeometryFromLayout",
    "name": "extractGeometryFromLayout",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/layout/ScopedLayoutRunner.ts",
    "relative_path": "client/core/layout/ScopedLayoutRunner.ts",
    "depends_on": [
      "client.layout.types.ViewStateDelta",
      "scripts.test-vercel-preview.log",
      "client.types.graph.ElkGraphNode",
      "client.viewstate.ViewState.ViewState",
      "client.core.viewstate.CoordinateService.toWorldFromRelative"
    ],
    "source_code": "function extractGeometryFromLayout(\n  layout: ElkGraphNode,\n  scopeId: string,\n  viewState: ViewState\n): ViewStateDelta {\n  const delta: ViewStateDelta = {\n    node: {},\n    group: {},\n    edge: {}\n  };\n\n  // CRITICAL: Get scope group's absolute position from ViewState\n  // ELK returns relative positions, we need to convert to absolute\n  const scopeGroupGeom = viewState.group?.[scopeId];\n  const scopeAbsolutePos = scopeGroupGeom \n    ? { x: scopeGroupGeom.x, y: scopeGroupGeom.y }\n    : { x: 0, y: 0 }; // Fallback to origin if scope not found\n\n  console.log('[üéØCOORD] ELK-LAYOUT - START:', {\n    scopeId,\n    scopeAbsolute: `${scopeAbsolutePos.x},${scopeAbsolutePos.y}`,\n    note: 'ELK returns RELATIVE positions, must convert to ABSOLUTE for ViewState',\n  });\n\n  function extractFromNode(node: ElkGraphNode, isGroup: boolean, parentElkPos: { x: number; y: number } = { x: 0, y: 0 }): void {\n    const id = node.id;\n    // ELK gives us relative position within its parent scope\n    const elkRelativePos = { x: node.x || 0, y: node.y || 0 };\n    \n    // Convert to absolute: ELK relative + parent absolute (or scope absolute for root children)\n    // For scope root children, parent is the scope itself\n    const parentAbsolute = parentElkPos.x === 0 && parentElkPos.y === 0 \n      ? scopeAbsolutePos \n      : parentElkPos;\n    \n    const absolutePos = CoordinateService.toWorldFromRelative(elkRelativePos, parentAbsolute);\n    \n    // CRITICAL LOGGING: Always log nested groups to identify Problem 2\n    if (isGroup && (parentElkPos.x !== 0 || parentElkPos.y !== 0)) {\n      console.log('[üéØCOORD] ELK-LAYOUT - nested group conversion:', {\n        nodeId: id,\n        elkRelative: `${elkRelativePos.x},${elkRelativePos.y}`,\n        parentElkPos: `${parentElkPos.x},${parentElkPos.y}`,\n        scopeAbsolute: `${scopeAbsolutePos.x},${scopeAbsolutePos.y}`,\n        chosenParentAbsolute: `${parentAbsolute.x},${parentAbsolute.y}`,\n        calculatedAbsolute: `${absolutePos.x},${absolutePos.y}`,\n        calculation: `${elkRelativePos.x} + ${parentAbsolute.x} = ${absolutePos.x}`,\n        note: 'This absolute will be written to ViewState',\n      });\n    }\n    \n    // Use ViewState dimensions if available, especially for nested groups\n    let w: number;\n    let h: number;\n    \n    if (isGroup) {\n      const groupGeom = viewState.group?.[id];\n      if (groupGeom?.w && groupGeom?.h) {\n        w = groupGeom.w;\n        h = groupGeom.h;\n      } else {\n        w = node.width || NON_ROOT_DEFAULT_OPTIONS.width * 3;\n        h = node.height || 96 * 3;\n      }\n    } else {\n      const nodeGeom = viewState.node?.[id];\n      if (nodeGeom?.w && nodeGeom?.h) {\n        w = nodeGeom.w;\n        h = nodeGeom.h;\n      } else {\n        w = node.width || NON_ROOT_DEFAULT_OPTIONS.width;\n        h = node.height || 96;\n      }\n    }\n\n    if (isGroup) {\n      if (!delta.group) delta.group = {};\n      delta.group[id] = { x: absolutePos.x, y: absolutePos.y, w, h };\n      \n      // PROBLEM 2 FINAL LOG: Log ALL groups being written to ViewState\n      // Check if this is a scope root child by comparing with scopeAbsolutePos\n      const isScopeRootChild = Math.abs(parentElkPos.x - scopeAbsolutePos.x) < 0.01 && \n                               Math.abs(parentElkPos.y - scopeAbsolutePos.y) < 0.01;\n      const isNested = !isScopeRootChild && (parentElkPos.x !== 0 || parentElkPos.y !== 0);\n      \n      console.log('[üéØCOORD] ELK-LAYOUT - WRITING group to ViewState:', {\n        nodeId: id,\n        isScopeRootChild,\n        isNested,\n        elkRelative: `${elkRelativePos.x},${elkRelativePos.y}`,\n        parentElkPos: `${parentElkPos.x},${parentElkPos.y}`,\n        scopeAbsolute: `${scopeAbsolutePos.x},${scopeAbsolutePos.y}`,\n        chosenParentAbsolute: `${parentAbsolute.x},${parentAbsolute.y}`,\n        calculatedAbsolute: `${absolutePos.x},${absolutePos.y}`,\n        calculation: `${elkRelativePos.x} + ${parentAbsolute.x} = ${absolutePos.x}`,\n        writingToViewState: `${absolutePos.x},${absolutePos.y}`,\n        problem2_check: isNested && Math.abs(absolutePos.x - parentAbsolute.x) < 1 && Math.abs(absolutePos.y - parentAbsolute.y) < 1\n          ? '‚ö†Ô∏è PROBLEM 2: Nested group absolute equals parent absolute - ELK relative not added!'\n          : 'OK',\n      });\n    } else {\n      if (!delta.node) delta.node = {};\n      delta.node[id] = { x: absolutePos.x, y: absolutePos.y, w, h };\n    }\n\n    // Process children recursively - pass this node's absolute position as parent\n    if (node.children) {\n      console.log('[üéØCOORD] ELK-LAYOUT - processing nested children:', {\n        parentId: id,\n        parentAbsolute: `${absolutePos.x},${absolutePos.y}`,\n        childCount: node.children.length,\n        childIds: node.children.map(c => c.id),\n        note: 'These children will use parentAbsolute as their parentAbsolute',\n      });\n      \n      node.children.forEach(child => {\n        const childIsGroup = !!(child.children && child.children.length > 0);\n        console.log('[üéØCOORD] ELK-LAYOUT - recursing to nested child:', {\n          parentId: id,\n          parentAbsolute: `${absolutePos.x},${absolutePos.y}`,\n          childId: child.id,\n          childIsGroup,\n          childElkRelative: `${child.x || 0},${child.y || 0}`,\n          willCalculateAbsolute: `${(child.x || 0) + absolutePos.x},${(child.y || 0) + absolutePos.y}`,\n        });\n        extractFromNode(child, childIsGroup, absolutePos);\n      });\n    }\n\n    // Extract edge waypoints if available\n    if (node.edges) {\n      if (!delta.edge) delta.edge = {};\n      node.edges.forEach(edge => {\n        if (edge.sections && edge.sections.length > 0) {\n          const waypoints: Array<{ x: number; y: number }> = [];\n          edge.sections.forEach(section => {\n            if (section.bendPoints) {\n              waypoints.push(...section.bendPoints);\n            }\n          });\n          if (waypoints.length > 0) {\n            delta.edge[edge.id] = { waypoints };\n          }\n        }\n      });\n    }\n  }\n\n  // Start extraction from the scope node\n  // Scope node itself uses its absolute position from ViewState (already stored)\n  const scopeIsGroup = !!(layout.children && layout.children.length > 0);\n  \n  // For scope node, use its absolute position directly (don't convert)\n  const scopeX = layout.x || 0;\n  const scopeY = layout.y || 0;\n  // After anchoring, scope position might be different - use anchored position\n  const scopeAbsoluteAfterAnchor = scopeGroupGeom\n    ? { x: scopeGroupGeom.x, y: scopeGroupGeom.y } // Keep existing absolute position\n    : { x: scopeX, y: scopeY }; // Use ELK position if no ViewState\n  \n  // Extract children (they will be converted relative to scope)\n  if (layout.children) {\n    console.log('[üéØCOORD] ELK-LAYOUT - extracting scope root children:', {\n      scopeId,\n      scopeAbsolute: `${scopeAbsoluteAfterAnchor.x},${scopeAbsoluteAfterAnchor.y}`,\n      childCount: layout.children.length,\n      childIds: layout.children.map(c => c.id),\n      note: 'These children will use scopeAbsolute as parentAbsolute',\n    });\n    \n    layout.children.forEach(child => {\n      const childIsGroup = !!(child.children && child.children.length > 0);\n      console.log('[üéØCOORD] ELK-LAYOUT - extracting scope root child:', {\n        scopeId,\n        childId: child.id,\n        childIsGroup,\n        childElkRelative: `${child.x || 0},${child.y || 0}`,\n        parentAbsolute: `${scopeAbsoluteAfterAnchor.x},${scopeAbsoluteAfterAnchor.y}`,\n        willCalculateAbsolute: `${(child.x || 0) + scopeAbsoluteAfterAnchor.x},${(child.y || 0) + scopeAbsoluteAfterAnchor.y}`,\n      });\n      extractFromNode(child, childIsGroup, scopeAbsoluteAfterAnchor);\n    });\n  }\n\n  return delta;\n}",
    "start_line": 228,
    "end_line": 413,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout",
      "scopeId",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractGeometryFromLayout",
    "component_id": "client.core.layout.ScopedLayoutRunner.extractGeometryFromLayout"
  },
  "client.core.layout.ScopedLayoutRunner.runScopeLayout": {
    "id": "client.core.layout.ScopedLayoutRunner.runScopeLayout",
    "name": "runScopeLayout",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/layout/ScopedLayoutRunner.ts",
    "relative_path": "client/core/layout/ScopedLayoutRunner.ts",
    "depends_on": [
      "client.layout.types.ViewStateDelta",
      "client.core.layout.ScopedLayoutRunner.computeScopeBboxTopLeft",
      "scripts.test-vercel-preview.log",
      "client.types.graph.ElkGraphNode",
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.layout.types.LayoutOptions",
      "client.core.layout.ScopedLayoutRunner.translateLayout",
      "client.components.graph.utils.elk.ids.ensureIds",
      "client.core.layout.ScopedLayoutRunner.extractGeometryFromLayout",
      "scripts.test-vercel-preview.error",
      "client.core.layout.ScopedLayoutRunner.extractSubtree",
      "client.core.layout.ScopedLayoutRunner.autoFitGroupFrame"
    ],
    "source_code": "async function runScopeLayout(\n  scopeId: string,\n  domainGraph: RawGraph,\n  currentViewState: ViewState,\n  opts?: LayoutOptions\n): Promise<ViewStateDelta> {\n  // 1. Extract subtree for scopeId from Domain graph\n  const subtree = extractSubtree(domainGraph, scopeId);\n  if (!subtree) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`[ScopedLayoutRunner] Failed to extract subtree for scope \"${scopeId}\"`);\n    }\n    return {};\n  }\n\n  // 2. Compute pre-layout bbox top-left for anchoring\n  const anchorTopLeft = computeScopeBboxTopLeft(scopeId, subtree, currentViewState);\n\n  // 3. Prepare subtree for ELK (ensure IDs and options)\n  const prepared = ensureIds(JSON.parse(JSON.stringify(subtree)));\n\n  // 3b. Inject ViewState dimensions into prepared subtree before ELK layout\n  // This ensures ELK knows the actual sizes of nodes/groups (especially nested groups)\n  function injectViewStateDimensions(node: ElkGraphNode): void {\n    const id = node.id;\n    const isGroup = !!(node.children && node.children.length > 0);\n    \n    // Get dimensions from ViewState\n    if (isGroup) {\n      const groupGeom = currentViewState.group?.[id];\n      if (groupGeom?.w && groupGeom?.h) {\n        node.width = groupGeom.w;\n        node.height = groupGeom.h;\n        if (process.env.NODE_ENV !== 'production') {\n          console.log(`[ScopedLayoutRunner] Injected ViewState dimensions for group ${id}: ${groupGeom.w}x${groupGeom.h}`);\n        }\n      }\n    } else {\n      const nodeGeom = currentViewState.node?.[id];\n      if (nodeGeom?.w && nodeGeom?.h) {\n        node.width = nodeGeom.w;\n        node.height = nodeGeom.h;\n      }\n    }\n    \n    // Recursively process children\n    if (node.children) {\n      node.children.forEach(child => injectViewStateDimensions(child));\n    }\n  }\n  \n  injectViewStateDimensions(prepared);\n\n  // 4. Run ELK on scope subtree\n  let layout: ElkGraphNode;\n  try {\n    const elkResult = await elk.layout(prepared);\n    layout = elkResult as ElkGraphNode;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(`[ScopedLayoutRunner] ELK layout failed for scope \"${scopeId}\":`, error);\n    }\n    throw new Error(`ELK layout failed for scope \"${scopeId}\": ${error}`);\n  }\n\n  // 5. Translate output to preserve anchor top-left (if anchor exists)\n  if (anchorTopLeft && layout.x !== undefined && layout.y !== undefined) {\n    const elkTopLeft = { x: layout.x, y: layout.y };\n    translateLayout(layout, anchorTopLeft, elkTopLeft);\n  }\n\n  // 6. Auto-fit group frame to children (use ViewState dimensions for nested groups)\n  const frameSize = autoFitGroupFrame(subtree, layout, currentViewState);\n  if (layout.width !== undefined) layout.width = frameSize.w;\n  if (layout.height !== undefined) layout.height = frameSize.h;\n\n  // 7. Convert ELK positions to ViewStateDelta format (use ViewState dimensions for nested groups)\n  const delta = extractGeometryFromLayout(layout, scopeId, currentViewState);\n\n  // Ensure the scope group itself is included in the delta\n  if (!delta.group) delta.group = {};\n  delta.group[scopeId] = {\n    x: layout.x || 0,\n    y: layout.y || 0,\n    w: frameSize.w,\n    h: frameSize.h\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.log(`[ScopedLayoutRunner] Layout complete for scope \"${scopeId}\":`, {\n      nodeCount: Object.keys(delta.node || {}).length,\n      groupCount: Object.keys(delta.group || {}).length,\n      edgeCount: Object.keys(delta.edge || {}).length,\n      anchored: !!anchorTopLeft\n    });\n  }\n\n  return delta;\n}",
    "start_line": 430,
    "end_line": 528,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "scopeId",
      "domainGraph",
      "currentViewState",
      "opts"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function runScopeLayout",
    "component_id": "client.core.layout.ScopedLayoutRunner.runScopeLayout"
  },
  "client.core.orchestration.Orchestrator.initializeOrchestrator": {
    "id": "client.core.orchestration.Orchestrator.initializeOrchestrator",
    "name": "initializeOrchestrator",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Orchestrator.ts",
    "relative_path": "client/core/orchestration/Orchestrator.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState",
      "client.core.renderer.ViewStateToReactFlow.convertViewStateToReactFlow",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "function initializeOrchestrator(\n  graphRef: { current: RawGraph | null },\n  vsRef: { current: ViewState },\n  renderTrigger: () => void,\n  setGraph?: (graph: RawGraph, source?: 'ai' | 'user' | 'free-structural') => void,\n  setNodes?: (nodes: any[]) => void,\n  setEdges?: (edges: any[]) => void\n) {\n  console.log('[üîÑ INIT] Orchestrator initialized synchronously (handles both FREE and AI/LOCK modes)');\n  \n  graphStateRef = graphRef;\n  viewStateRef = vsRef;\n  renderTriggerRef.current = renderTrigger;\n  setGraphRef.current = setGraph || null;\n  setNodesRef.current = setNodes || null;\n  setEdgesRef.current = setEdges || null;\n\n  // üîß FIX: If initialized with existing data, trigger immediate render\n  // This fixes persistence - restored nodes should appear immediately\n  if (graphRef.current?.children?.length > 0 && setNodes) {\n    console.log('[üîÑ INIT] Found existing data - triggering immediate render:', {\n      graphChildren: graphRef.current.children.length,\n      viewStateNodes: Object.keys(vsRef.current?.node || {}).length,\n      viewStateGroups: Object.keys(vsRef.current?.group || {}).length\n    });\n\n    // Use the same rendering logic as add-node action\n    const domainStructure = graphRef.current;\n    const dimensions = { width: 96, height: 96, groupWidth: 200, groupHeight: 150, padding: 16 };\n\n    // Import and render using ViewStateToReactFlow (same as regular flow)\n    import('../renderer/ViewStateToReactFlow').then(({ convertViewStateToReactFlow }) => {\n      try {\n        const { nodes, edges } = convertViewStateToReactFlow(\n          domainStructure,\n          vsRef.current,\n          dimensions\n        );\n\n        console.log('[üîÑ INIT] Initial render complete:', {\n          nodes: nodes.length,\n          edges: edges.length,\n          nodeIds: nodes.map(n => n.id)\n        });\n\n        if (setNodesRef.current) setNodesRef.current(nodes);\n        if (setEdgesRef.current) setEdgesRef.current(edges);\n      } catch (error) {\n        console.error('[üîÑ INIT] Initial render failed:', error);\n      }\n    });\n  }\n}",
    "start_line": 43,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graphRef",
      "vsRef",
      "renderTrigger",
      "setGraph",
      "setNodes",
      "setEdges"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function initializeOrchestrator",
    "component_id": "client.core.orchestration.Orchestrator.initializeOrchestrator"
  },
  "client.core.orchestration.Orchestrator.triggerRestorationRender": {
    "id": "client.core.orchestration.Orchestrator.triggerRestorationRender",
    "name": "triggerRestorationRender",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Orchestrator.ts",
    "relative_path": "client/core/orchestration/Orchestrator.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState",
      "client.core.renderer.ViewStateToReactFlow.convertViewStateToReactFlow",
      "scripts.test-vercel-preview.error",
      "client.core.viewstate.ViewStateCleanup.cleanViewState"
    ],
    "source_code": "function triggerRestorationRender(graphRef: { current: RawGraph | null }, vsRef: { current: ViewState }) {\n  if (!setNodesRef.current || !setEdgesRef.current) return;\n  \n  const hasGraphData = graphRef.current?.children?.length > 0;\n  const hasViewStateData = Object.keys(vsRef.current?.node || {}).length > 0 || Object.keys(vsRef.current?.group || {}).length > 0;\n  \n  if (hasGraphData && hasViewStateData) {\n    console.log('[üîÑ RESTORATION] Triggering restoration render from setRawGraph:', {\n      graphChildren: graphRef.current?.children?.length || 0,\n      viewStateNodes: Object.keys(vsRef.current?.node || {}).length,\n    });\n\n    const domainStructure = graphRef.current;\n    const dimensions = { width: 96, height: 96, groupWidth: 200, groupHeight: 150, padding: 16 };\n\n    // Clean ViewState before rendering to remove stale entries\n    import('../viewstate/ViewStateCleanup').then(({ cleanViewState }) => {\n      const cleanedViewState = cleanViewState(domainStructure!, vsRef.current);\n      \n      // Update the ViewState ref with cleaned version\n      vsRef.current = cleanedViewState;\n      \n      import('../renderer/ViewStateToReactFlow').then(({ convertViewStateToReactFlow }) => {\n        try {\n          const { nodes, edges } = convertViewStateToReactFlow(domainStructure!, cleanedViewState, dimensions);\n          \n          if (setNodesRef.current) setNodesRef.current(nodes);\n          if (setEdgesRef.current) setEdgesRef.current(edges);\n\n          console.log('[üîÑ RESTORATION] setRawGraph restoration render complete:', {\n            nodes: nodes.length,\n            edges: edges.length,\n            nodeIds: nodes.map(n => n.id),\n          });\n        } catch (error) {\n          console.error('[üîÑ RESTORATION] setRawGraph restoration render failed:', error);\n        }\n      });\n    });\n  }\n}",
    "start_line": 100,
    "end_line": 140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graphRef",
      "vsRef"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function triggerRestorationRender",
    "component_id": "client.core.orchestration.Orchestrator.triggerRestorationRender"
  },
  "client.core.orchestration.Orchestrator.apply": {
    "id": "client.core.orchestration.Orchestrator.apply",
    "name": "apply",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Orchestrator.ts",
    "relative_path": "client/core/orchestration/Orchestrator.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.core.viewstate.ViewStateCleanup.cleanViewState",
      "client.orchestration.types.EditIntent",
      "client.utils.graph_helper_functions.moveNode",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.graph_helper_functions.findNodeById",
      "client.utils.graph_helper_functions.addNode",
      "client.core.renderer.ViewStateToReactFlow.convertViewStateToReactFlow",
      "scripts.test-vercel-preview.error",
      "client.viewstate.adjust.adjustForReparent",
      "client.utils.graph_helper_functions.deleteEdge",
      "client.utils.graph_helper_functions.deleteNode"
    ],
    "source_code": "async function apply(intent: EditIntent): Promise<void> {\n  if (process.env.NODE_ENV !== 'production') {\n    console.log('[Orchestrator] apply called', intent);\n  }\n\n  if (!graphStateRef.current) {\n    throw new Error('[Orchestrator] Graph state not available');\n  }\n\n  switch (intent.kind) {\n    case 'geo-only': {\n      // FREE geo-only: ViewState.write ‚Üí emit render\n      console.warn('[Orchestrator] geo-only path not yet implemented');\n      break;\n    }\n\n    case 'free-structural': {\n      // FREE structural: Domain.mutate ‚Üí ViewState.adjust ‚Üí emit render\n      const { payload } = intent;\n      let updatedGraph = graphStateRef.current;\n      \n      if (payload.action === 'add-node') {\n        // 0. Write position to ViewState FIRST (before domain mutation)\n        // CRITICAL: ALWAYS write geometry to ViewState BEFORE domain mutation\n        // This ensures ViewState-first contract is maintained\n        \n          // Ensure ViewState structure exists\n          if (!viewStateRef.current) {\n            viewStateRef.current = { node: {}, group: {}, edge: {} };\n          }\n          if (!viewStateRef.current.node) {\n            viewStateRef.current.node = {};\n          }\n        if (!viewStateRef.current.group) {\n          viewStateRef.current.group = {};\n        }\n        \n        // STRICT: Position MUST be provided for FREE mode - no fallbacks\n        const x = payload.position?.x ?? payload.x;\n        const y = payload.position?.y ?? payload.y;\n        \n        if (x === undefined || y === undefined) {\n          throw new Error(`[Orchestrator] add-node requires position (x, y). Got: ${JSON.stringify({ x, y, payload })}`);\n        }\n        \n        const newNodeGeometry = {\n          x,\n          y,\n          w: payload.size?.w ?? (payload.data?.isGroup ? 288 : 96),\n          h: payload.size?.h ?? (payload.data?.isGroup ? 192 : 96),\n        };\n          \n        // STRICT: Use the SAME ID as domain graph (no normalization)\n        // Domain graph uses payload.nodeId directly, so ViewState must match\n        const nodeId = payload.nodeId;\n        \n        // Write to appropriate ViewState collection using same ID as domain\n        if (payload.data?.isGroup) {\n          // Groups need both group and node entries for ReactFlow conversion\n          viewStateRef.current.group[nodeId] = newNodeGeometry;\n          viewStateRef.current.node[nodeId] = newNodeGeometry;\n        } else {\n          viewStateRef.current.node[nodeId] = newNodeGeometry;\n        }\n        \n        // 1. Domain.mutate (add node structure)\n        updatedGraph = addNode(\n          payload.nodeId,\n          payload.parentId,\n          updatedGraph,\n          payload.data || {}\n        );\n        \n        // Update graph ref only - do NOT touch React state for FREE mode\n        graphStateRef.current = updatedGraph;\n        \n        // Clean ViewState to remove stale entries\n        const { cleanViewState } = await import('../viewstate/ViewStateCleanup');\n        const cleanedViewState = cleanViewState(updatedGraph, viewStateRef.current);\n        \n        if (!cleanedViewState.node[nodeId]) {\n          throw new Error(`[Orchestrator] cleanViewState removed geometry for node ${nodeId}`);\n        }\n        \n        viewStateRef.current = cleanedViewState;\n        \n        // Render directly via setNodesRef/setEdgesRef (bypasses ELK)\n        if (setNodesRef.current && setEdgesRef.current) {\n          const { convertViewStateToReactFlow } = await import('../renderer/ViewStateToReactFlow');\n          const { nodes, edges } = convertViewStateToReactFlow(updatedGraph, cleanedViewState);\n          setNodesRef.current(nodes);\n          setEdgesRef.current(edges);\n        }\n        \n      } else if (payload.action === 'delete-node') {\n        // CRITICAL: Use the CURRENT graph state, not the stale updatedGraph\n        // The updatedGraph might be stale if multiple operations happened\n        const currentGraph = graphStateRef.current || updatedGraph;\n        const graphToDelete = JSON.parse(JSON.stringify(currentGraph));\n        \n        console.log('[Orchestrator] DELETE-NODE - using current graph:', {\n          nodeId: payload.nodeId,\n          currentGraphChildren: currentGraph?.children?.length || 0,\n          targetNodeExists: !!findNodeById(currentGraph, payload.nodeId!)\n        });\n        \n        // 1. Domain.mutate (delete node structure)\n        updatedGraph = deleteNode(payload.nodeId!, graphToDelete);\n        \n        // 2. Clean up ViewState using cleanViewState to remove ALL stale entries\n        // This handles both the deleted node AND any children (for groups)\n        const { cleanViewState } = await import('../viewstate/ViewStateCleanup');\n        const cleanedViewState = cleanViewState(updatedGraph, viewStateRef.current);\n        viewStateRef.current = cleanedViewState;\n        \n        // 3. Update graph state ref AND React state\n        // CRITICAL: Must update React state to prevent useEffect sync from overwriting our changes\n        // Update graph ref only - do NOT touch React state for FREE mode\n        const clonedGraph = JSON.parse(JSON.stringify(updatedGraph));\n        clonedGraph.viewState = cleanedViewState;\n        graphStateRef.current = clonedGraph;\n        \n        // 4. FREE mode: Direct render (same as add-node)\n        if (setNodesRef.current && setEdgesRef.current) {\n          import('../renderer/ViewStateToReactFlow').then(({ convertViewStateToReactFlow }) => {\n            try {\n              const dimensions = { width: 96, height: 96, groupWidth: 200, groupHeight: 150, padding: 16 };\n              const { nodes, edges } = convertViewStateToReactFlow(clonedGraph, cleanedViewState, dimensions);\n              \n              setNodesRef.current!(nodes);\n              setEdgesRef.current!(edges);\n              \n              console.log('[Orchestrator] FREE mode delete-node rendered directly:', {\n                nodeCount: nodes.length,\n                domainChildren: clonedGraph?.children?.length || 0,\n                viewStateNodes: Object.keys(cleanedViewState.node || {}).length,\n              });\n            } catch (error) {\n              console.error('[Orchestrator] FREE mode delete-node render failed:', error);\n            }\n          });\n        } else if (renderTriggerRef.current) {\n          // Fallback: trigger render via renderTriggerRef\n          renderTriggerRef.current();\n        }\n        \n        // Verify node was actually removed\n        const nodeStillInChildren = clonedGraph?.children?.some((c: any) => c.id === payload.nodeId);\n        if (nodeStillInChildren) {\n          console.error(`‚ùå [DELETE] Node ${payload.nodeId} still exists in root children after deletion!`);\n        }\n        \n        console.log('[Orchestrator] Completed FREE structural delete-node', {\n          nodeId: payload.nodeId,\n          graphChildrenCount: clonedGraph?.children?.length || 0,\n          beforeDeleteCount: graphToDelete?.children?.length || 0,\n          nodeStillInGraph: nodeStillInChildren,\n          graphNodeIds: clonedGraph?.children?.map((c: any) => c.id) || []\n        });\n        \n      } else if (payload.action === 'delete-edge') {\n        // CRITICAL: Clone graph first since deleteEdge might mutate in place\n        const graphToDelete = JSON.parse(JSON.stringify(updatedGraph));\n        \n        // 1. Domain.mutate (delete edge structure)\n        updatedGraph = deleteEdge(payload.edgeId!, graphToDelete);\n        \n        // 2. Clean up ViewState (remove edge waypoints)\n        if (viewStateRef.current.edge?.[payload.edgeId!]) {\n          delete viewStateRef.current.edge[payload.edgeId!];\n        }\n        \n        // Update graph state ref (NOT React state)\n        // CRITICAL: In FREE mode, we only update the ref, NOT call setRawGraph\n        const clonedGraph = JSON.parse(JSON.stringify(updatedGraph));\n        graphStateRef.current = clonedGraph;\n        \n        // DO NOT call setGraphRef.current() - it causes double rendering\n        // Render directly via setNodesRef/setEdgesRef\n        if (setNodesRef.current && setEdgesRef.current) {\n          const { convertViewStateToReactFlow } = await import('../renderer/ViewStateToReactFlow');\n          const { nodes, edges } = convertViewStateToReactFlow(clonedGraph, viewStateRef.current);\n          setNodesRef.current(nodes);\n          setEdgesRef.current(edges);\n        }\n        \n        console.log('[Orchestrator] Completed FREE structural delete-edge', {\n          edgeId: payload.edgeId\n        });\n        \n      } else if (payload.action === 'move-node') {\n        // 1. Domain.mutate (reparent node)\n        updatedGraph = moveNode(\n          payload.nodeId!,\n          payload.newParentId!,\n          updatedGraph\n        );\n        \n        // Update graph state\n        graphStateRef.current = updatedGraph;\n        \n        // 2. ViewState.adjust (preserve world position)\n        const getGroupWorldPos = (groupId: string) => {\n          const groupGeom = viewStateRef.current.group?.[groupId];\n          return groupGeom ? { x: groupGeom.x, y: groupGeom.y } : undefined;\n        };\n        \n        viewStateRef.current = adjustForReparent({\n          nodeId: payload.nodeId,\n          oldParentId: payload.oldParentId,\n          newParentId: payload.newParentId,\n          viewState: viewStateRef.current,\n          getGroupWorldPos\n        });\n        \n        // 3. Emit render\n        if (renderTriggerRef.current) {\n          renderTriggerRef.current();\n        }\n        \n        console.log('[Orchestrator] Completed FREE structural move-node', {\n          nodeId: payload.nodeId,\n          oldParent: payload.oldParentId,\n          newParent: payload.newParentId\n        });\n        \n      } else {\n        console.warn(`[Orchestrator] Unknown FREE structural action: ${(payload as any).action}`);\n      }\n      break;\n    }\n\n    case 'ai-lock-structural': {\n      // AI/LOCK structural: Domain.mutate ‚Üí Layout.run ‚Üí merge ViewStateDelta ‚Üí emit render\n      console.warn('[Orchestrator] ai-lock-structural path not yet implemented');\n      break;\n    }\n\n    default: {\n      const _exhaustive: never = intent as never;\n      throw new Error(`[Orchestrator] Unknown edit kind: ${(intent as any).kind}`);\n    }\n  }\n}",
    "start_line": 153,
    "end_line": 396,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "intent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function apply",
    "component_id": "client.core.orchestration.Orchestrator.apply"
  },
  "client.core.orchestration.Orchestrator.classifyEdit": {
    "id": "client.core.orchestration.Orchestrator.classifyEdit",
    "name": "classifyEdit",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Orchestrator.ts",
    "relative_path": "client/core/orchestration/Orchestrator.ts",
    "depends_on": [
      "client.orchestration.types.EditIntent",
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState",
      "client.core.orchestration.Policy.buildParentOf",
      "client.core.orchestration.Policy.buildModeMap",
      "client.orchestration.Policy.findHighestLockedAncestor",
      "client.orchestration.Policy.decideLayout",
      "client.orchestration.types.Source"
    ],
    "source_code": "function classifyEdit(\n  source: Source,\n  graph: RawGraph,\n  viewState: ViewState,\n  scopeId: string = 'root'\n): {\n  kind: EditIntent['kind'];\n  shouldRunELK: boolean;\n  resolvedScope: string | null;\n} {\n  // Build mode map from ViewState\n  const modeMap = buildModeMap(viewState);\n  const parentOf = buildParentOf(graph);\n  \n  // Check if edit requires ELK using Policy\n  const shouldRunELK = decideLayout({\n    source,\n    scopeId,\n    modeMap,\n    parentOf\n  });\n  \n  // Resolve scope (highest locked ancestor if needed)\n  const resolvedScope = shouldRunELK \n    ? findHighestLockedAncestor(scopeId, modeMap, parentOf) || scopeId\n    : null;\n  \n  // Classify edit kind\n  let kind: EditIntent['kind'];\n  if (shouldRunELK) {\n    kind = 'ai-lock-structural';\n  } else if (source === 'user') {\n    // User edits that don't need ELK are either geo-only or free-structural\n    // For now, assume structural (can be refined later)\n    kind = 'free-structural';\n  } else {\n    // Shouldn't happen (AI always needs ELK), but handle gracefully\n    kind = 'ai-lock-structural';\n  }\n  \n  return {\n    kind,\n    shouldRunELK,\n    resolvedScope\n  };\n}",
    "start_line": 408,
    "end_line": 453,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "source",
      "graph",
      "viewState",
      "scopeId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function classifyEdit",
    "component_id": "client.core.orchestration.Orchestrator.classifyEdit"
  },
  "client.core.orchestration.Orchestrator.resolveElkScope": {
    "id": "client.core.orchestration.Orchestrator.resolveElkScope",
    "name": "resolveElkScope",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Orchestrator.ts",
    "relative_path": "client/core/orchestration/Orchestrator.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState",
      "client.core.orchestration.Policy.buildParentOf",
      "client.core.orchestration.Policy.buildModeMap",
      "client.orchestration.Policy.findHighestLockedAncestor"
    ],
    "source_code": "function resolveElkScope(scopeId: string, graph: RawGraph, viewState?: ViewState): string | null {\n  if (!graph) {\n    return null;\n  }\n\n  // Build mode map from ViewState\n  const modeMap = viewState ? buildModeMap(viewState) : {};\n  const parentOf = buildParentOf(graph);\n  \n  // Find highest locked ancestor using Policy\n  const highestLocked = findHighestLockedAncestor(scopeId, modeMap, parentOf);\n  \n  if (process.env.NODE_ENV !== 'production') {\n    console.log('[Orchestrator] resolveElkScope:', {\n      originalScope: scopeId,\n      resolvedScope: highestLocked || scopeId,\n      modeMap,\n      isRerouted: !!highestLocked\n    });\n  }\n  \n  // Return highest locked ancestor if found, otherwise original scope\n  return highestLocked || scopeId;\n}",
    "start_line": 464,
    "end_line": 487,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "scopeId",
      "graph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function resolveElkScope",
    "component_id": "client.core.orchestration.Orchestrator.resolveElkScope"
  },
  "client.core.orchestration.Policy.DecideLayoutInput": {
    "id": "client.core.orchestration.Policy.DecideLayoutInput",
    "name": "DecideLayoutInput",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Policy.ts",
    "relative_path": "client/core/orchestration/Policy.ts",
    "depends_on": [
      "client.orchestration.types.Source",
      "client.orchestration.types.ModeMap"
    ],
    "source_code": "interface DecideLayoutInput {\n  source: Source;\n  scopeId: string;\n  modeMap: ModeMap;\n  parentOf: (id: string) => string | null;\n}",
    "start_line": 18,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DecideLayoutInput",
    "component_id": "client.core.orchestration.Policy.DecideLayoutInput"
  },
  "client.core.orchestration.Policy.decideLayout": {
    "id": "client.core.orchestration.Policy.decideLayout",
    "name": "decideLayout",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Policy.ts",
    "relative_path": "client/core/orchestration/Policy.ts",
    "depends_on": [
      "client.core.orchestration.Policy.findHighestLockedAncestor",
      "client.core.orchestration.Policy.DecideLayoutInput"
    ],
    "source_code": "function decideLayout(input: DecideLayoutInput): boolean {\n  const { source, scopeId, modeMap, parentOf } = input;\n\n  // AI edits always trigger ELK\n  if (source === 'ai') {\n    return true;\n  }\n\n  // User edits: check if scope or any ancestor is LOCK\n  const highestLocked = findHighestLockedAncestor(scopeId, modeMap, parentOf);\n  return highestLocked !== null;\n}",
    "start_line": 36,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "input"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function decideLayout",
    "component_id": "client.core.orchestration.Policy.decideLayout"
  },
  "client.core.orchestration.Policy.findHighestLockedAncestor": {
    "id": "client.core.orchestration.Policy.findHighestLockedAncestor",
    "name": "findHighestLockedAncestor",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Policy.ts",
    "relative_path": "client/core/orchestration/Policy.ts",
    "depends_on": [
      "client.orchestration.types.ModeMap"
    ],
    "source_code": "function findHighestLockedAncestor(\n  id: string,\n  modeMap: ModeMap,\n  parentOf: (id: string) => string | null\n): string | null {\n  let current: string | null = id;\n\n  // Walk up the parent chain\n  while (current !== null) {\n    // Check if current node/group is locked\n    if (modeMap[current] === 'LOCK') {\n      return current;\n    }\n\n    // Move to parent\n    current = parentOf(current);\n  }\n\n  // Reached root without finding LOCK\n  return null;\n}",
    "start_line": 52,
    "end_line": 72,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id",
      "modeMap",
      "parentOf"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findHighestLockedAncestor",
    "component_id": "client.core.orchestration.Policy.findHighestLockedAncestor"
  },
  "client.core.orchestration.Policy.buildModeMap": {
    "id": "client.core.orchestration.Policy.buildModeMap",
    "name": "buildModeMap",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Policy.ts",
    "relative_path": "client/core/orchestration/Policy.ts",
    "depends_on": [
      "client.orchestration.types.ModeMap"
    ],
    "source_code": "function buildModeMap(viewState: any): ModeMap {\n  const modeMap: ModeMap = {};\n  \n  if (viewState?.layout) {\n    for (const [groupId, { mode }] of Object.entries(viewState.layout)) {\n      modeMap[groupId] = mode as 'FREE' | 'LOCK';\n    }\n  }\n  \n  return modeMap;\n}",
    "start_line": 77,
    "end_line": 87,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function buildModeMap",
    "component_id": "client.core.orchestration.Policy.buildModeMap"
  },
  "client.core.orchestration.Policy.buildParentOf": {
    "id": "client.core.orchestration.Policy.buildParentOf",
    "name": "buildParentOf",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/Policy.ts",
    "relative_path": "client/core/orchestration/Policy.ts",
    "depends_on": [
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function buildParentOf(graph: ElkGraphNode): (id: string) => string | null {\n  // Build a parent map for efficient lookup\n  const parentMap = new Map<string, string>();\n  \n  const traverse = (node: ElkGraphNode, parentId: string | null = null) => {\n    if (parentId !== null) {\n      parentMap.set(node.id, parentId);\n    }\n    \n    if (node.children) {\n      for (const child of node.children) {\n        traverse(child, node.id);\n      }\n    }\n  };\n  \n  traverse(graph);\n  \n  // Return lookup function\n  return (id: string): string | null => {\n    // Root has no parent\n    if (id === graph.id || id === 'root') {\n      return null;\n    }\n    return parentMap.get(id) || null;\n  };\n}",
    "start_line": 92,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function buildParentOf",
    "component_id": "client.core.orchestration.Policy.buildParentOf"
  },
  "client.core.orchestration.types.Source": {
    "id": "client.core.orchestration.types.Source",
    "name": "Source",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/types.ts",
    "relative_path": "client/core/orchestration/types.ts",
    "depends_on": [],
    "source_code": "type Source = 'ai' | 'user';",
    "start_line": 9,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Source",
    "component_id": "client.core.orchestration.types.Source"
  },
  "client.core.orchestration.types.EditKind": {
    "id": "client.core.orchestration.types.EditKind",
    "name": "EditKind",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/types.ts",
    "relative_path": "client/core/orchestration/types.ts",
    "depends_on": [],
    "source_code": "type EditKind = \n  | 'geo-only'           // FREE: drag/resize within same parent (no structure change)\n  | 'free-structural'    // FREE: reparent/group/edge ops (structure changes, no ELK)\n  | 'ai-lock-structural';",
    "start_line": 14,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EditKind",
    "component_id": "client.core.orchestration.types.EditKind"
  },
  "client.core.orchestration.types.EditIntent": {
    "id": "client.core.orchestration.types.EditIntent",
    "name": "EditIntent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/types.ts",
    "relative_path": "client/core/orchestration/types.ts",
    "depends_on": [
      "client.core.orchestration.types.Source",
      "client.core.orchestration.types.EditKind"
    ],
    "source_code": "interface EditIntent {\n  source: Source;\n  kind: EditKind;\n  scopeId: string;\n  /**\n   * Optional payload for specific operations\n   */\n  payload?: {\n    action?: 'add-node' | 'move-node' | 'group-nodes' | 'delete-node' | 'delete-edge' | 'select-nodes' | 'deselect-all';\n    nodeId?: string;\n    nodeIds?: string[];  // For selection actions\n    edgeId?: string;\n    parentId?: string;\n    oldParentId?: string;\n    newParentId?: string;\n    position?: { x: number; y: number };\n    size?: { w: number; h: number };\n    data?: any;\n    [key: string]: unknown;\n  };\n}",
    "start_line": 22,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EditIntent",
    "component_id": "client.core.orchestration.types.EditIntent"
  },
  "client.core.orchestration.types.ModeMap": {
    "id": "client.core.orchestration.types.ModeMap",
    "name": "ModeMap",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/orchestration/types.ts",
    "relative_path": "client/core/orchestration/types.ts",
    "depends_on": [],
    "source_code": "type ModeMap = Record<string, 'FREE' | 'LOCK'>;",
    "start_line": 47,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ModeMap",
    "component_id": "client.core.orchestration.types.ModeMap"
  },
  "client.core.renderer.ReactFlowAdapter.toReactFlowWithViewState": {
    "id": "client.core.renderer.ReactFlowAdapter.toReactFlowWithViewState",
    "name": "toReactFlowWithViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/renderer/ReactFlowAdapter.ts",
    "relative_path": "client/core/renderer/ReactFlowAdapter.ts",
    "depends_on": [
      "client.viewstate.ViewState.requireGeometry",
      "scripts.test-vercel-preview.log",
      "client.viewstate.ViewState.ViewState",
      "client.core.viewstate.CoordinateService.toRelativeFromWorld",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.renderer.types.NodeDimensions",
      "client.components.graph.utils.toReactFlow.processLayoutedGraph",
      "client.components.graph.utils.elk.edgePoints.add",
      "client.renderer.types.ReactFlowAdapterOptions"
    ],
    "source_code": "function toReactFlowWithViewState(\n  elkGraph: any,\n  dimensions: NodeDimensions,\n  viewState: ViewState,\n  options?: ReactFlowAdapterOptions\n): { nodes: Node[]; edges: Edge[] } {\n  const strictGeometry = options?.strictGeometry ?? true;\n\n  // First, get ReactFlow nodes/edges from ELK (for structure, handles, edge routing)\n  const { nodes: elkNodes, edges: elkEdges } = processLayoutedGraph(elkGraph, dimensions);\n\n  // Build a map of all node positions for parent lookup\n  const nodePositionMap = new Map<string, { x: number; y: number }>();\n  elkNodes.forEach((n) => {\n    const isGroupNode = n.type === 'group';\n    const geom = isGroupNode ? viewState.group?.[n.id] : viewState.node?.[n.id];\n    if (geom) {\n      nodePositionMap.set(n.id, { x: geom.x, y: geom.y });\n    }\n  });\n\n  // Build parent chain map for debugging nested groups\n  const parentChainMap = new Map<string, string[]>();\n  const buildParentChain = (nodeId: string, visited = new Set<string>()): string[] => {\n    if (visited.has(nodeId)) return []; // Prevent cycles\n    visited.add(nodeId);\n    \n    const node = elkNodes.find(n => n.id === nodeId);\n    if (!node) return [];\n    \n    const parentId = (node as any).parentId;\n    if (!parentId || parentId === 'root') return [];\n    \n    const chain = buildParentChain(parentId, visited);\n    return [...chain, parentId];\n  };\n  \n  elkNodes.forEach(n => {\n    const chain = buildParentChain(n.id);\n    parentChainMap.set(n.id, chain);\n  });\n\n  // Override all node positions from ViewState (enforce contract)\n  const nodes = elkNodes.map((node) => {\n    const nodeId = node.id;\n    const isGroup = node.type === 'group';\n\n    if (strictGeometry && process.env.NODE_ENV !== 'production') {\n      // Enforce: geometry must exist in ViewState\n      try {\n        requireGeometry(isGroup ? 'group' : 'node', nodeId, viewState);\n      } catch (error: any) {\n        // Re-throw with more context\n        const message = `[ReactFlowAdapter] Missing ViewState geometry for ${isGroup ? 'group' : 'node'} \"${nodeId}\". ` +\n          `This violates the ViewState-first contract. ` +\n          `Ensure Layout or Orchestration has written geometry before rendering.`;\n        const enhancedError = new Error(message);\n        if (error) {\n          (enhancedError as any).cause = error;\n        }\n        throw enhancedError;\n      }\n    }\n\n    // Get geometry from ViewState (source of truth)\n    const geometry = isGroup\n      ? viewState.group?.[nodeId]\n      : viewState.node?.[nodeId];\n\n    const parentId = (node as any).parentId;\n    const parentChain = parentChainMap.get(nodeId) || [];\n\n    if (geometry) {\n      // CRITICAL: If node has a parent, convert absolute position to relative\n      // ReactFlow requires relative positions for child nodes\n      // CP1 Update: Use CoordinateService for coordinate transformations\n      const worldPos = { x: geometry.x, y: geometry.y };\n      \n      let position = worldPos;\n      \n      if (parentId && parentId !== 'root') {\n        const parentGeometry = viewState.group?.[parentId];\n        if (parentGeometry) {\n          const parentWorldPos = { x: parentGeometry.x, y: parentGeometry.y };\n          \n          // Use CoordinateService for world ‚Üí relative conversion\n          position = CoordinateService.toRelativeFromWorld(worldPos, parentWorldPos);\n          \n          // CRITICAL LOGGING: Always log nested groups to identify Problem 2\n          if (parentChain.length > 0) {\n            console.log('[üéØCOORD] RENDERER - nested group rendering:', {\n            nodeId,\n            parentId,\n              nodeViewStateAbsolute: `${worldPos.x},${worldPos.y}`,\n              parentViewStateAbsolute: `${parentWorldPos.x},${parentWorldPos.y}`,\n              calculatedRelative: `${position.x},${position.y}`,\n              parentChain: parentChain.join(' ‚Üí '),\n              calculation: `${worldPos.x} - ${parentWorldPos.x} = ${position.x}`,\n              note: 'If node absolute equals parent absolute, ViewState was written incorrectly by ELK',\n              problem2Check: Math.abs(worldPos.x - parentWorldPos.x) < 1 && Math.abs(worldPos.y - parentWorldPos.y) < 1\n                ? '‚ö†Ô∏è PROBLEM 2: Node absolute equals parent absolute - ELK wrote wrong absolute!'\n                : 'OK',\n          });\n          }\n        } else {\n          console.warn('[üéØCOORD] RENDERER - missing parent geometry:', {\n            nodeId,\n            parentId,\n            availableGroups: Object.keys(viewState.group || {}),\n          });\n        }\n      }\n      \n      // Override position AND dimensions from ViewState (now correctly relative if has parent)\n      const width = geometry.w ?? node.data?.width ?? (node.style as any)?.width ?? (isGroup ? 480 : 96);\n      const height = geometry.h ?? node.data?.height ?? (node.style as any)?.height ?? (isGroup ? 320 : 96);\n      \n      const result = {\n        ...node,\n        position,\n        draggable: true, // CRITICAL: Ensure all nodes (including groups) are draggable\n        // Update data.position and dimensions\n        data: {\n          ...node.data,\n          width,\n          height,\n          position: { x: geometry.x, y: geometry.y }, // Keep absolute in data for reference\n        },\n        // Update style dimensions for groups\n        style: isGroup ? {\n          ...(node.style || {}),\n          width,\n          height,\n        } : node.style,\n      };\n      \n      // Only log when there's a mismatch (relative equals absolute for child nodes)\n      if ((node as any).parentId && Math.abs(position.x - geometry.x) < 0.01 && Math.abs(position.y - geometry.y) < 0.01) {\n        console.warn('[üéØCOORD] RENDERER - MISMATCH: Relative equals absolute:', {\n          nodeId,\n          parentId: (node as any).parentId,\n          reactFlowPos: `${position.x},${position.y}`,\n          viewStateAbsolute: `${geometry.x},${geometry.y}`,\n          issue: '‚ö†Ô∏è Parent conversion failed - using absolute as relative!',\n        });\n      }\n      \n      return result;\n    }\n\n    // Fallback: use ELK position (only if strictGeometry is false)\n    if (!strictGeometry) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          `[üéØCOORD] ReactFlowAdapter using ELK position for ${isGroup ? 'group' : 'node'} \"${nodeId}\" ` +\n          `(ViewState missing, strictGeometry=false)`\n        );\n      }\n      return node;\n    }\n\n    // Strict mode: should have thrown above, but if we get here, use safe default\n    return {\n      ...node,\n      position: { x: 0, y: 0 },\n    };\n  });\n\n  // Override edge waypoints from ViewState if available\n  const edges = elkEdges.map((edge) => {\n    const edgeId = edge.id;\n    const edgeGeom = viewState.edge?.[edgeId];\n\n    if (edgeGeom?.waypoints && Array.isArray(edgeGeom.waypoints)) {\n      // Use ViewState waypoints (manual routing in FREE mode)\n      return {\n        ...edge,\n        data: {\n          ...edge.data,\n          bendPoints: edgeGeom.waypoints,\n        },\n      };\n    }\n\n    // Use ELK waypoints (from processLayoutedGraph)\n    return edge;\n  });\n\n  return { nodes, edges };\n}",
    "start_line": 33,
    "end_line": 222,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "elkGraph",
      "dimensions",
      "viewState",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toReactFlowWithViewState",
    "component_id": "client.core.renderer.ReactFlowAdapter.toReactFlowWithViewState"
  },
  "client.core.renderer.ViewStateToReactFlow.ReactFlowOutput": {
    "id": "client.core.renderer.ViewStateToReactFlow.ReactFlowOutput",
    "name": "ReactFlowOutput",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/renderer/ViewStateToReactFlow.ts",
    "relative_path": "client/core/renderer/ViewStateToReactFlow.ts",
    "depends_on": [],
    "source_code": "interface ReactFlowOutput {\n  nodes: Node[];\n  edges: Edge[];\n}",
    "start_line": 30,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ReactFlowOutput",
    "component_id": "client.core.renderer.ViewStateToReactFlow.ReactFlowOutput"
  },
  "client.core.renderer.ViewStateToReactFlow.convertViewStateToReactFlow": {
    "id": "client.core.renderer.ViewStateToReactFlow.convertViewStateToReactFlow",
    "name": "convertViewStateToReactFlow",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/renderer/ViewStateToReactFlow.ts",
    "relative_path": "client/core/renderer/ViewStateToReactFlow.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.core.renderer.ViewStateToReactFlow.ReactFlowOutput"
    ],
    "source_code": "function convertViewStateToReactFlow(\n  domainGraph: RawGraph,\n  viewState: ViewState\n): ReactFlowOutput {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  console.log('[üéØCOORD] ViewState ‚Üí ReactFlow (Universal, ABSOLUTE coords)', {\n    domainChildren: domainGraph.children?.length || 0,\n    viewStateNodeKeys: Object.keys(viewState.node || {}),\n    viewStateGroupKeys: Object.keys(viewState.group || {})\n  });\n\n  // Process all domain nodes - NO parentId, all ABSOLUTE positions\n  const processNode = (domainNode: any) => {\n    const nodeId = domainNode.id;\n    \n    // Standard group detection\n    const hasChildren = Array.isArray(domainNode.children) && domainNode.children.length > 0;\n    const isGroup = \n      domainNode.data?.isGroup === true || \n      hasChildren ||\n      (Array.isArray(domainNode.edges) && domainNode.edges.length > 0);\n\n    // Read ABSOLUTE geometry from ViewState\n    const geometry = isGroup\n      ? viewState.group?.[nodeId]\n      : viewState.node?.[nodeId];\n\n    if (!geometry) {\n      console.warn(`[üéØCOORD] Missing ViewState geometry for ${isGroup ? 'group' : 'node'} \"${nodeId}\" - skipping`);\n      return;\n    }\n\n    // ABSOLUTE position - no conversion, no parentId\n    const position = { x: geometry.x, y: geometry.y };\n\n    console.log(`[üéØCOORD] Converting ${nodeId}: ABSOLUTE (${position.x},${position.y}), size ${geometry.w}√ó${geometry.h}`);\n    \n    // Use 'draftGroup' instead of 'group' to avoid ReactFlow's built-in group behavior\n    // The built-in 'group' type has special non-draggable behavior we don't want\n    const reactFlowNode: Node = {\n      id: nodeId,\n      type: isGroup ? 'draftGroup' : 'custom',\n      position, // ABSOLUTE - never relative\n      draggable: true,\n      // NO parentId - we handle group membership ourselves\n      data: {\n        ...domainNode.data,\n        width: geometry.w,\n        height: geometry.h,\n        isGroup, // Pass flag for component to know it's a group\n      },\n      style: {\n        width: geometry.w,\n        height: geometry.h,\n      },\n    };\n\n    nodes.push(reactFlowNode);\n\n    // Process children recursively (still no parentId passed)\n    if (domainNode.children?.length > 0) {\n      for (const child of domainNode.children) {\n        processNode(child);\n      }\n    }\n  };\n\n  // Process all nodes from root\n  if (domainGraph.children?.length > 0) {\n    for (const child of domainGraph.children) {\n      processNode(child);\n    }\n  }\n\n  // Process edges\n  if (domainGraph.edges?.length > 0) {\n    domainGraph.edges.forEach((edge: any, index: number) => {\n      const edgeId = edge.id || `edge-${index}`;\n      \n      const reactFlowEdge: Edge = {\n        id: edgeId,\n        source: edge.sources?.[0] || edge.source,\n        target: edge.targets?.[0] || edge.target,\n        type: 'step', // Use 'step' for libavoid routing (StepEdge handles both 'step' and 'smoothstep')\n      };\n\n      edges.push(reactFlowEdge);\n    });\n  }\n\n  console.log('[üéØCOORD] ViewState ‚Üí ReactFlow result:', {\n    nodes: nodes.length,\n    edges: edges.length,\n    samplePosition: nodes[0]?.position\n  });\n\n  return { nodes, edges };\n}",
    "start_line": 45,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "domainGraph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convertViewStateToReactFlow",
    "component_id": "client.core.renderer.ViewStateToReactFlow.convertViewStateToReactFlow"
  },
  "client.core.viewstate.CoordinateService.Point": {
    "id": "client.core.viewstate.CoordinateService.Point",
    "name": "Point",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/CoordinateService.ts",
    "relative_path": "client/core/viewstate/CoordinateService.ts",
    "depends_on": [],
    "source_code": "type Point = { x: number; y: number };",
    "start_line": 1,
    "end_line": 1,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Point",
    "component_id": "client.core.viewstate.CoordinateService.Point"
  },
  "client.core.viewstate.CoordinateService.Bounds": {
    "id": "client.core.viewstate.CoordinateService.Bounds",
    "name": "Bounds",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/CoordinateService.ts",
    "relative_path": "client/core/viewstate/CoordinateService.ts",
    "depends_on": [],
    "source_code": "type Bounds = { x: number; y: number; w: number; h: number };",
    "start_line": 2,
    "end_line": 2,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Bounds",
    "component_id": "client.core.viewstate.CoordinateService.Bounds"
  },
  "client.core.viewstate.CoordinateService.CoordinateService": {
    "id": "client.core.viewstate.CoordinateService.CoordinateService",
    "name": "CoordinateService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/CoordinateService.ts",
    "relative_path": "client/core/viewstate/CoordinateService.ts",
    "depends_on": [
      "client.core.viewstate.CoordinateService.Point"
    ],
    "source_code": "class CoordinateService {\n  static toRelativeFromWorld(childWorldPos: Point, parentWorldPos: Point): Point {\n    return {\n      x: childWorldPos.x - parentWorldPos.x,\n      y: childWorldPos.y - parentWorldPos.y,\n    };\n  }\n\n  static toWorldFromRelative(childRelativePos: Point, parentWorldPos: Point): Point {\n    return {\n      x: childRelativePos.x + parentWorldPos.x,\n      y: childRelativePos.y + parentWorldPos.y,\n    };\n  }\n\n  static snapPoint(point: Point, gridSize: number): Point {\n    return {\n      x: Math.round(point.x / gridSize) * gridSize,\n      y: Math.round(point.y / gridSize) * gridSize,\n    };\n  }\n}",
    "start_line": 8,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CoordinateService",
    "component_id": "client.core.viewstate.CoordinateService.CoordinateService"
  },
  "client.core.viewstate.CoordinateService.toRelativeFromWorld": {
    "id": "client.core.viewstate.CoordinateService.toRelativeFromWorld",
    "name": "toRelativeFromWorld",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/CoordinateService.ts",
    "relative_path": "client/core/viewstate/CoordinateService.ts",
    "depends_on": [],
    "source_code": "static toRelativeFromWorld(childWorldPos: Point, parentWorldPos: Point): Point {\n    return {\n      x: childWorldPos.x - parentWorldPos.x,\n      y: childWorldPos.y - parentWorldPos.y,\n    };\n  }",
    "start_line": 9,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "childWorldPos",
      "parentWorldPos"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method toRelativeFromWorld",
    "component_id": "client.core.viewstate.CoordinateService.toRelativeFromWorld"
  },
  "client.core.viewstate.CoordinateService.toWorldFromRelative": {
    "id": "client.core.viewstate.CoordinateService.toWorldFromRelative",
    "name": "toWorldFromRelative",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/CoordinateService.ts",
    "relative_path": "client/core/viewstate/CoordinateService.ts",
    "depends_on": [],
    "source_code": "static toWorldFromRelative(childRelativePos: Point, parentWorldPos: Point): Point {\n    return {\n      x: childRelativePos.x + parentWorldPos.x,\n      y: childRelativePos.y + parentWorldPos.y,\n    };\n  }",
    "start_line": 16,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "childRelativePos",
      "parentWorldPos"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method toWorldFromRelative",
    "component_id": "client.core.viewstate.CoordinateService.toWorldFromRelative"
  },
  "client.core.viewstate.CoordinateService.snapPoint": {
    "id": "client.core.viewstate.CoordinateService.snapPoint",
    "name": "snapPoint",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/CoordinateService.ts",
    "relative_path": "client/core/viewstate/CoordinateService.ts",
    "depends_on": [],
    "source_code": "static snapPoint(point: Point, gridSize: number): Point {\n    return {\n      x: Math.round(point.x / gridSize) * gridSize,\n      y: Math.round(point.y / gridSize) * gridSize,\n    };\n  }",
    "start_line": 23,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "point",
      "gridSize"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method snapPoint",
    "component_id": "client.core.viewstate.CoordinateService.snapPoint"
  },
  "client.core.viewstate.ViewState.ViewState": {
    "id": "client.core.viewstate.ViewState.ViewState",
    "name": "ViewState",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/ViewState.ts",
    "relative_path": "client/core/viewstate/ViewState.ts",
    "depends_on": [],
    "source_code": "type ViewState = {\n  node?: Record<string, { x: number; y: number; w?: number; h?: number }>;\n  group?: Record<string, { x: number; y: number; w?: number; h?: number }>;\n  edge?: Record<string, { waypoints?: Array<{ x: number; y: number }> }>;\n  layout?: Record<string, { mode?: 'FREE' | 'LOCK' }>;\n};",
    "start_line": 1,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ViewState",
    "component_id": "client.core.viewstate.ViewState.ViewState"
  },
  "client.core.viewstate.ViewState.Geometry": {
    "id": "client.core.viewstate.ViewState.Geometry",
    "name": "Geometry",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/ViewState.ts",
    "relative_path": "client/core/viewstate/ViewState.ts",
    "depends_on": [],
    "source_code": "type Geometry = { x: number; y: number; w?: number; h?: number };",
    "start_line": 8,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Geometry",
    "component_id": "client.core.viewstate.ViewState.Geometry"
  },
  "client.core.viewstate.ViewState.createEmptyViewState": {
    "id": "client.core.viewstate.ViewState.createEmptyViewState",
    "name": "createEmptyViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/ViewState.ts",
    "relative_path": "client/core/viewstate/ViewState.ts",
    "depends_on": [
      "client.core.viewstate.ViewState.ViewState"
    ],
    "source_code": "function createEmptyViewState(): ViewState {\n  return {\n    node: {},\n    group: {},\n    edge: {},\n    layout: {},\n  };\n}",
    "start_line": 13,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createEmptyViewState",
    "component_id": "client.core.viewstate.ViewState.createEmptyViewState"
  },
  "client.core.viewstate.ViewStateCleanup.collectAllIds": {
    "id": "client.core.viewstate.ViewStateCleanup.collectAllIds",
    "name": "collectAllIds",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/ViewStateCleanup.ts",
    "relative_path": "client/core/viewstate/ViewStateCleanup.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "client.components.graph.types.index.RawGraph",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function collectAllIds(graph: RawGraph): { nodeIds: Set<string>, groupIds: Set<string> } {\n  const nodeIds = new Set<string>();\n  const groupIds = new Set<string>();\n\n  function traverse(node: any) {\n    if (node.id) {\n      // Check if this is a group - must have children WITH at least one element, not just an empty array\n      const hasChildren = Array.isArray(node.children) && node.children.length > 0;\n      const isGroup = node.type === 'group' || node.data?.isGroup || node.mode || hasChildren;\n      if (isGroup) {\n        groupIds.add(node.id);\n      } else {\n        nodeIds.add(node.id);\n      }\n    }\n    \n    if (node.children) {\n      node.children.forEach((child: any) => traverse(child));\n    }\n  }\n\n  // Include root\n  if (graph.id) {\n    groupIds.add(graph.id);\n  }\n  \n  if (graph.children) {\n    console.log(`[üßπ CLEANUP] Processing ${graph.children.length} children of root`);\n    graph.children.forEach(child => traverse(child));\n  }\n\n  return { nodeIds, groupIds };\n}",
    "start_line": 12,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function collectAllIds",
    "component_id": "client.core.viewstate.ViewStateCleanup.collectAllIds"
  },
  "client.core.viewstate.ViewStateCleanup.cleanViewState": {
    "id": "client.core.viewstate.ViewStateCleanup.cleanViewState",
    "name": "cleanViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/ViewStateCleanup.ts",
    "relative_path": "client/core/viewstate/ViewStateCleanup.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.types.index.RawGraph",
      "client.core.viewstate.ViewStateCleanup.collectAllIds",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function cleanViewState(domainGraph: RawGraph, viewState: ViewState): ViewState {\n  const { nodeIds, groupIds } = collectAllIds(domainGraph);\n  \n  console.log('[üßπ CLEANUP] collectAllIds result:', {\n    nodeIds: Array.from(nodeIds),\n    groupIds: Array.from(groupIds),\n    domainChildren: domainGraph.children?.length || 0,\n    domainChildIds: domainGraph.children?.map(c => c.id) || []\n  });\n  \n  const cleanedViewState: ViewState = {\n    node: {},\n    group: {},\n    edge: { ...viewState.edge } // Keep edges as-is for now\n  };\n\n  // Only keep ViewState entries for nodes that exist in domain\n  Object.entries(viewState.node || {}).forEach(([nodeId, geometry]) => {\n    if (nodeIds.has(nodeId)) {\n      cleanedViewState.node[nodeId] = geometry;\n    } else {\n      console.log(`[üßπ CLEANUP] Removing stale node ViewState: ${nodeId}`);\n    }\n  });\n\n  // Only keep ViewState entries for groups that exist in domain\n  Object.entries(viewState.group || {}).forEach(([groupId, geometry]) => {\n    if (groupIds.has(groupId)) {\n      cleanedViewState.group[groupId] = geometry;\n    } else {\n      console.log(`[üßπ CLEANUP] Removing stale group ViewState: ${groupId}`);\n    }\n  });\n\n  const removedNodes = Object.keys(viewState.node || {}).length - Object.keys(cleanedViewState.node).length;\n  const removedGroups = Object.keys(viewState.group || {}).length - Object.keys(cleanedViewState.group).length;\n  \n  if (removedNodes > 0 || removedGroups > 0) {\n    console.log(`[üßπ CLEANUP] Cleaned ViewState: removed ${removedNodes} stale nodes, ${removedGroups} stale groups`);\n  }\n\n  return cleanedViewState;\n}",
    "start_line": 50,
    "end_line": 92,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "domainGraph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cleanViewState",
    "component_id": "client.core.viewstate.ViewStateCleanup.cleanViewState"
  },
  "client.core.viewstate.adjust.AdjustForReparentOptions": {
    "id": "client.core.viewstate.adjust.AdjustForReparentOptions",
    "name": "AdjustForReparentOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/adjust.ts",
    "relative_path": "client/core/viewstate/adjust.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "interface AdjustForReparentOptions {\n  nodeId: string;\n  oldParentId: string;\n  newParentId: string;\n  viewState: ViewState;\n  /**\n   * Function to get the world position of a group (for computing relative positions)\n   */\n  getGroupWorldPos: (groupId: string) => { x: number; y: number } | undefined;\n}",
    "start_line": 11,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AdjustForReparentOptions",
    "component_id": "client.core.viewstate.adjust.AdjustForReparentOptions"
  },
  "client.core.viewstate.adjust.adjustForReparent": {
    "id": "client.core.viewstate.adjust.adjustForReparent",
    "name": "adjustForReparent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/adjust.ts",
    "relative_path": "client/core/viewstate/adjust.ts",
    "depends_on": [
      "client.core.viewstate.adjust.AdjustForReparentOptions",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function adjustForReparent(options: AdjustForReparentOptions): ViewState {\n  const { nodeId, oldParentId, newParentId, viewState, getGroupWorldPos } = options;\n\n  // Get current node geometry\n  const nodeGeom = viewState.node?.[nodeId];\n  if (!nodeGeom) {\n    return viewState;\n  }\n\n  // Get world positions of old and new parents\n  const oldParentWorldPos = oldParentId === 'root' \n    ? { x: 0, y: 0 } \n    : getGroupWorldPos(oldParentId);\n  \n  const newParentWorldPos = newParentId === 'root'\n    ? { x: 0, y: 0 }\n    : getGroupWorldPos(newParentId);\n\n  if (!oldParentWorldPos || !newParentWorldPos) {\n    console.warn('[üéØCOORD] adjustForReparent - missing parent positions:', {\n      nodeId,\n      oldParent: oldParentId,\n      newParent: newParentId,\n    });\n    return viewState;\n  }\n\n  // Compute node's world position\n  const nodeWorldX = oldParentWorldPos.x + nodeGeom.x;\n  const nodeWorldY = oldParentWorldPos.y + nodeGeom.y;\n\n  // Compute new relative position\n  const newRelativeX = nodeWorldX - newParentWorldPos.x;\n  const newRelativeY = nodeWorldY - newParentWorldPos.y;\n\n  // Update ViewState\n  const updated = {\n    ...viewState,\n    node: {\n      ...viewState.node,\n      [nodeId]: {\n        ...nodeGeom,\n        x: newRelativeX,\n        y: newRelativeY,\n      },\n    },\n  };\n\n  return updated;\n}",
    "start_line": 35,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function adjustForReparent",
    "component_id": "client.core.viewstate.adjust.adjustForReparent"
  },
  "client.core.viewstate.migrateModeToViewState.MigrationResult": {
    "id": "client.core.viewstate.migrateModeToViewState.MigrationResult",
    "name": "MigrationResult",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/migrateModeToViewState.ts",
    "relative_path": "client/core/viewstate/migrateModeToViewState.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "interface MigrationResult {\n  migratedGraph: RawGraph;\n  migratedViewState: ViewState;\n  changed: boolean;\n  migratedGroups: string[];\n}",
    "start_line": 13,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MigrationResult",
    "component_id": "client.core.viewstate.migrateModeToViewState.MigrationResult"
  },
  "client.core.viewstate.migrateModeToViewState.migrateModeToViewState": {
    "id": "client.core.viewstate.migrateModeToViewState.migrateModeToViewState",
    "name": "migrateModeToViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/migrateModeToViewState.ts",
    "relative_path": "client/core/viewstate/migrateModeToViewState.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "client.components.graph.types.index.RawGraph",
      "client.core.viewstate.migrateModeToViewState.MigrationResult",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function migrateModeToViewState(\n  rawGraph: RawGraph,\n  viewState: ViewState\n): MigrationResult {\n  // Deep clone to avoid mutating input\n  const migratedGraph = JSON.parse(JSON.stringify(rawGraph));\n  const migratedViewState = JSON.parse(JSON.stringify(viewState));\n  \n  // Collect all group IDs and their modes from Domain\n  const domainModes: Record<string, 'FREE' | 'LOCK'> = {};\n  const allGroupIds = new Set<string>();\n  \n  const traverse = (node: any) => {\n    // Groups are nodes with children\n    if (node.children && node.children.length > 0) {\n      allGroupIds.add(node.id);\n      \n      // Extract mode from Domain if present\n      if (node.mode === 'FREE' || node.mode === 'LOCK') {\n        domainModes[node.id] = node.mode;\n      }\n    }\n    \n    // Recurse into children\n    if (node.children) {\n      for (const child of node.children) {\n        traverse(child);\n      }\n    }\n  };\n  \n  traverse(migratedGraph);\n  \n  // Initialize ViewState.layout if missing\n  if (!migratedViewState.layout) {\n    migratedViewState.layout = {};\n  }\n  \n  // Migrate modes from Domain to ViewState.layout\n  const migratedGroups: string[] = [];\n  let changed = false;\n  \n  for (const [groupId, mode] of Object.entries(domainModes)) {\n    // Only migrate if ViewState doesn't already have this mode\n    if (!migratedViewState.layout[groupId]) {\n      migratedViewState.layout[groupId] = { mode };\n      migratedGroups.push(groupId);\n      changed = true;\n    }\n  }\n  \n  // Ensure all groups have a mode (default to FREE)\n  for (const groupId of allGroupIds) {\n    if (!migratedViewState.layout[groupId]) {\n      migratedViewState.layout[groupId] = { mode: 'FREE' };\n      changed = true;\n    }\n  }\n  \n  // Remove .mode from Domain Graph (clean up)\n  const removeModeFromGraph = (node: any) => {\n    if ('mode' in node) {\n      delete node.mode;\n      changed = true;\n    }\n    if (node.children) {\n      for (const child of node.children) {\n        removeModeFromGraph(child);\n      }\n    }\n  };\n  \n  removeModeFromGraph(migratedGraph);\n  \n  return {\n    migratedGraph,\n    migratedViewState,\n    changed,\n    migratedGroups\n  };\n}",
    "start_line": 33,
    "end_line": 113,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawGraph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function migrateModeToViewState",
    "component_id": "client.core.viewstate.migrateModeToViewState.migrateModeToViewState"
  },
  "client.core.viewstate.migrateModeToViewState.needsMigration": {
    "id": "client.core.viewstate.migrateModeToViewState.needsMigration",
    "name": "needsMigration",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/migrateModeToViewState.ts",
    "relative_path": "client/core/viewstate/migrateModeToViewState.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function needsMigration(rawGraph: RawGraph, viewState: ViewState): boolean {\n  // Check if Domain has any .mode properties\n  let hasDomainModes = false;\n  \n  const checkForModes = (node: any) => {\n    if (node.mode === 'FREE' || node.mode === 'LOCK') {\n      hasDomainModes = true;\n      return; // Early exit\n    }\n    if (node.children) {\n      for (const child of node.children) {\n        checkForModes(child);\n      }\n    }\n  };\n  \n  checkForModes(rawGraph);\n  \n  if (!hasDomainModes) {\n    return false; // No modes in Domain, no migration needed\n  }\n  \n  // Check if ViewState.layout has all the modes\n  const domainModes: Record<string, 'FREE' | 'LOCK'> = {};\n  const collectDomainModes = (node: any) => {\n    if (node.children && node.children.length > 0) {\n      if (node.mode === 'FREE' || node.mode === 'LOCK') {\n        domainModes[node.id] = node.mode;\n      }\n    }\n    if (node.children) {\n      for (const child of node.children) {\n        collectDomainModes(child);\n      }\n    }\n  };\n  \n  collectDomainModes(rawGraph);\n  \n  // Check if ViewState.layout has all these modes\n  for (const groupId of Object.keys(domainModes)) {\n    if (!viewState.layout?.[groupId]) {\n      return true; // Missing in ViewState, needs migration\n    }\n  }\n  \n  return false;\n}",
    "start_line": 118,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawGraph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function needsMigration",
    "component_id": "client.core.viewstate.migrateModeToViewState.needsMigration"
  },
  "client.core.viewstate.modeHelpers.extractModeFromDomain": {
    "id": "client.core.viewstate.modeHelpers.extractModeFromDomain",
    "name": "extractModeFromDomain",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/modeHelpers.ts",
    "relative_path": "client/core/viewstate/modeHelpers.ts",
    "depends_on": [
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function extractModeFromDomain(graph: ElkGraphNode): Record<string, 'FREE' | 'LOCK'> {\n  const modeMap: Record<string, 'FREE' | 'LOCK'> = {};\n  \n  const traverse = (node: ElkGraphNode) => {\n    if (node.children && node.children.length > 0) {\n      modeMap[node.id] = (node as any).mode || 'FREE';\n    }\n    if (node.children) {\n      for (const child of node.children) {\n        traverse(child);\n      }\n    }\n  };\n  \n  traverse(graph);\n  return modeMap;\n}",
    "start_line": 4,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractModeFromDomain",
    "component_id": "client.core.viewstate.modeHelpers.extractModeFromDomain"
  },
  "client.core.viewstate.modeHelpers.getModeFromViewState": {
    "id": "client.core.viewstate.modeHelpers.getModeFromViewState",
    "name": "getModeFromViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/modeHelpers.ts",
    "relative_path": "client/core/viewstate/modeHelpers.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function getModeFromViewState(viewState: ViewState, groupId: string): 'FREE' | 'LOCK' {\n  return viewState.layout?.[groupId]?.mode || 'FREE';\n}",
    "start_line": 22,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "viewState",
      "groupId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getModeFromViewState",
    "component_id": "client.core.viewstate.modeHelpers.getModeFromViewState"
  },
  "client.core.viewstate.modeHelpers.setModeInViewState": {
    "id": "client.core.viewstate.modeHelpers.setModeInViewState",
    "name": "setModeInViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/modeHelpers.ts",
    "relative_path": "client/core/viewstate/modeHelpers.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function setModeInViewState(viewState: ViewState, groupId: string, mode: 'FREE' | 'LOCK'): ViewState {\n  return {\n    ...viewState,\n    layout: {\n      ...viewState.layout,\n      [groupId]: {\n        ...viewState.layout?.[groupId],\n        mode,\n      },\n    },\n  };\n}",
    "start_line": 26,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "viewState",
      "groupId",
      "mode"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setModeInViewState",
    "component_id": "client.core.viewstate.modeHelpers.setModeInViewState"
  },
  "client.core.viewstate.modeHelpers.migrateModeDomainToViewState": {
    "id": "client.core.viewstate.modeHelpers.migrateModeDomainToViewState",
    "name": "migrateModeDomainToViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/modeHelpers.ts",
    "relative_path": "client/core/viewstate/modeHelpers.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "client.viewstate.ViewState.ViewState",
      "client.core.viewstate.modeHelpers.extractModeFromDomain",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function migrateModeDomainToViewState(\n  graph: ElkGraphNode, \n  viewState: ViewState\n): ViewState {\n  const domainModes = extractModeFromDomain(graph);\n  \n  // Get all group IDs from graph\n  const allGroupIds = new Set<string>();\n  const collectGroupIds = (node: ElkGraphNode) => {\n    if (node.children && node.children.length > 0) {\n      allGroupIds.add(node.id);\n    }\n    if (node.children) {\n      node.children.forEach(collectGroupIds);\n    }\n  };\n  collectGroupIds(graph);\n  \n  // Start with existing ViewState.layout or empty\n  const layoutSection: Record<string, { mode: 'FREE' | 'LOCK' }> = { ...viewState.layout || {} };\n  \n  // Migrate modes from Domain (if any)\n  for (const [groupId, mode] of Object.entries(domainModes)) {\n    if (!layoutSection[groupId]) {\n      layoutSection[groupId] = { mode };\n    }\n  }\n  \n  // Ensure all groups have a mode (default to FREE if missing)\n  for (const groupId of allGroupIds) {\n    if (!layoutSection[groupId]) {\n      layoutSection[groupId] = { mode: 'FREE' };\n    }\n  }\n  \n  return {\n    ...viewState,\n    layout: layoutSection\n  };\n}",
    "start_line": 45,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function migrateModeDomainToViewState",
    "component_id": "client.core.viewstate.modeHelpers.migrateModeDomainToViewState"
  },
  "client.core.viewstate.modeHelpers.syncViewStateLayoutWithGraph": {
    "id": "client.core.viewstate.modeHelpers.syncViewStateLayoutWithGraph",
    "name": "syncViewStateLayoutWithGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/core/viewstate/modeHelpers.ts",
    "relative_path": "client/core/viewstate/modeHelpers.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "client.viewstate.ViewState.ViewState",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function syncViewStateLayoutWithGraph(\n  graph: ElkGraphNode,\n  viewState: ViewState\n): ViewState {\n  const allGroupIds = new Set<string>();\n  const collectGroupIds = (node: ElkGraphNode) => {\n    if (node.children && node.children.length > 0) {\n      allGroupIds.add(node.id);\n    }\n    if (node.children) {\n      node.children.forEach(collectGroupIds);\n    }\n  };\n  collectGroupIds(graph);\n  \n  const layoutSection: Record<string, { mode: 'FREE' | 'LOCK' }> = { ...viewState.layout || {} };\n  \n  // Ensure all groups have a mode (default to FREE if missing)\n  for (const groupId of allGroupIds) {\n    if (!layoutSection[groupId]) {\n      layoutSection[groupId] = { mode: 'FREE' };\n    }\n  }\n  \n  return {\n    ...viewState,\n    layout: layoutSection\n  };\n}",
    "start_line": 90,
    "end_line": 118,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function syncViewStateLayoutWithGraph",
    "component_id": "client.core.viewstate.modeHelpers.syncViewStateLayoutWithGraph"
  },
  "client.entry-server.render": {
    "id": "client.entry-server.render",
    "name": "render",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/entry-server.jsx",
    "relative_path": "client/entry-server.jsx",
    "depends_on": [],
    "source_code": "function render() {\n  const html = renderToString(\n    <StrictMode>\n      <App />\n    </StrictMode>,\n  );\n  return { html };\n}",
    "start_line": 5,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function render",
    "component_id": "client.entry-server.render"
  },
  "client.events.graphEvents.ElkGraphEventDetail": {
    "id": "client.events.graphEvents.ElkGraphEventDetail",
    "name": "ElkGraphEventDetail",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/events/graphEvents.ts",
    "relative_path": "client/events/graphEvents.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "type ElkGraphEventDetail = {\n  elkGraph: RawGraph;\n  source?: string;        // e.g., 'FunctionExecutor', 'HistoryRestore', 'UserAction'\n  reason?: string;        // e.g., 'agent-update', 'history-restore', 'architecture-load'\n  targetArchitectureId?: string; // ID of the architecture being updated\n  version?: number;       // schema version for future compatibility\n  ts?: number;            // Date.now() timestamp\n};",
    "start_line": 5,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ElkGraphEventDetail",
    "component_id": "client.events.graphEvents.ElkGraphEventDetail"
  },
  "client.events.graphEvents.dispatchElkGraph": {
    "id": "client.events.graphEvents.dispatchElkGraph",
    "name": "dispatchElkGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/events/graphEvents.ts",
    "relative_path": "client/events/graphEvents.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.events.graphEvents.ElkGraphEventDetail"
    ],
    "source_code": "function dispatchElkGraph(detail: ElkGraphEventDetail): void {\n  const eventDetail: ElkGraphEventDetail = {\n    ...detail,\n    version: detail.version ?? 1,\n    ts: detail.ts ?? Date.now()\n  };\n  \n  console.log('üì° Dispatching elkGraph:set event:', {\n    source: eventDetail.source,\n    reason: eventDetail.reason,\n    targetArchitectureId: eventDetail.targetArchitectureId,\n    nodeCount: eventDetail.elkGraph?.children?.length || 0,\n    edgeCount: eventDetail.elkGraph?.edges?.length || 0,\n    timestamp: new Date(eventDetail.ts).toISOString()\n  });\n  \n  window.dispatchEvent(new CustomEvent<ElkGraphEventDetail>(ELK_GRAPH_SET, { \n    detail: eventDetail \n  }));\n}",
    "start_line": 18,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "detail"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function dispatchElkGraph",
    "component_id": "client.events.graphEvents.dispatchElkGraph"
  },
  "client.events.graphEvents.onElkGraph": {
    "id": "client.events.graphEvents.onElkGraph",
    "name": "onElkGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/events/graphEvents.ts",
    "relative_path": "client/events/graphEvents.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "api.stream.handler",
      "client.events.graphEvents.ElkGraphEventDetail"
    ],
    "source_code": "function onElkGraph(\n  handler: (detail: ElkGraphEventDetail) => void\n): () => void {\n  const wrapped = (e: Event) => {\n    const ce = e as CustomEvent<ElkGraphEventDetail>;\n    console.log('üëÇ Received elkGraph:set event:', {\n      source: ce.detail.source,\n      reason: ce.detail.reason,\n      targetArchitectureId: ce.detail.targetArchitectureId,\n      nodeCount: ce.detail.elkGraph?.children?.length || 0,\n      version: ce.detail.version\n    });\n    handler(ce.detail);\n  };\n  \n  window.addEventListener(ELK_GRAPH_SET, wrapped);\n  \n  return () => {\n    window.removeEventListener(ELK_GRAPH_SET, wrapped);\n  };\n}",
    "start_line": 44,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "handler"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function onElkGraph",
    "component_id": "client.events.graphEvents.onElkGraph"
  },
  "client.events.graphEvents.isElkGraphEvent": {
    "id": "client.events.graphEvents.isElkGraphEvent",
    "name": "isElkGraphEvent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/events/graphEvents.ts",
    "relative_path": "client/events/graphEvents.ts",
    "depends_on": [
      "client.events.graphEvents.ElkGraphEventDetail"
    ],
    "source_code": "function isElkGraphEvent(event: Event): event is CustomEvent<ElkGraphEventDetail> {\n  return event instanceof CustomEvent && event.type === ELK_GRAPH_SET;\n}",
    "start_line": 69,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isElkGraphEvent",
    "component_id": "client.events.graphEvents.isElkGraphEvent"
  },
  "client.events.graphSchema.validateRawGraph": {
    "id": "client.events.graphSchema.validateRawGraph",
    "name": "validateRawGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/events/graphSchema.ts",
    "relative_path": "client/events/graphSchema.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "function validateRawGraph(graph: unknown): RawGraph {\n  if (!graph || typeof graph !== 'object') {\n    throw new Error('Graph must be an object');\n  }\n\n  const g = graph as Record<string, unknown>;\n\n  // Check required fields\n  if (typeof g.id !== 'string') {\n    throw new Error('Graph.id must be a string');\n  }\n\n  if (!Array.isArray(g.children)) {\n    throw new Error('Graph.children must be an array');\n  }\n\n  if (!Array.isArray(g.edges)) {\n    throw new Error('Graph.edges must be an array');\n  }\n\n  // Validate children structure (basic checks)\n  for (let i = 0; i < g.children.length; i++) {\n    const child = g.children[i];\n    if (!child || typeof child !== 'object') {\n      throw new Error(`Graph.children[${i}] must be an object`);\n    }\n    const childObj = child as Record<string, unknown>;\n    if (typeof childObj.id !== 'string') {\n      throw new Error(`Graph.children[${i}].id must be a string`);\n    }\n  }\n\n  // Validate edges structure (basic checks)\n  for (let i = 0; i < g.edges.length; i++) {\n    const edge = g.edges[i];\n    if (!edge || typeof edge !== 'object') {\n      throw new Error(`Graph.edges[${i}] must be an object`);\n    }\n    const edgeObj = edge as Record<string, unknown>;\n    if (typeof edgeObj.id !== 'string') {\n      throw new Error(`Graph.edges[${i}].id must be a string`);\n    }\n  }\n\n  return g as RawGraph;\n}",
    "start_line": 12,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validateRawGraph",
    "component_id": "client.events.graphSchema.validateRawGraph"
  },
  "client.events.graphSchema.assertRawGraph": {
    "id": "client.events.graphSchema.assertRawGraph",
    "name": "assertRawGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/events/graphSchema.ts",
    "relative_path": "client/events/graphSchema.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph",
      "client.events.graphSchema.validateRawGraph",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "function assertRawGraph(graph: unknown, context?: string): RawGraph {\n  try {\n    return validateRawGraph(graph);\n  } catch (error) {\n    const contextMsg = context ? ` (context: ${context})` : '';\n    console.error(`‚ùå Invalid RawGraph${contextMsg}:`, error);\n    console.error('Graph data:', graph);\n    throw new Error(`Invalid RawGraph${contextMsg}: ${error}`);\n  }\n}",
    "start_line": 63,
    "end_line": 72,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "context"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function assertRawGraph",
    "component_id": "client.events.graphSchema.assertRawGraph"
  },
  "client.events.graphSchema.safeValidateRawGraph": {
    "id": "client.events.graphSchema.safeValidateRawGraph",
    "name": "safeValidateRawGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/events/graphSchema.ts",
    "relative_path": "client/events/graphSchema.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph",
      "client.events.graphSchema.validateRawGraph"
    ],
    "source_code": "function safeValidateRawGraph(graph: unknown): { \n  success: true; \n  data: RawGraph; \n} | { \n  success: false; \n  error: string; \n} {\n  try {\n    const validGraph = validateRawGraph(graph);\n    return { success: true, data: validGraph };\n  } catch (error) {\n    return { \n      success: false, \n      error: error instanceof Error ? error.message : String(error)\n    };\n  }\n}",
    "start_line": 78,
    "end_line": 94,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function safeValidateRawGraph",
    "component_id": "client.events.graphSchema.safeValidateRawGraph"
  },
  "client.generated.dynamicAgentResources.DynamicAgentResources": {
    "id": "client.generated.dynamicAgentResources.DynamicAgentResources",
    "name": "DynamicAgentResources",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/dynamicAgentResources.ts",
    "relative_path": "client/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "interface DynamicAgentResources {\n  groupIcons: {\n    all: string[];\n    aws: string[];\n    gcp: string[];\n    azure: string[];\n  };\n  regularIcons: {\n    aws: string[];\n    gcp: string[];\n    azure: string[];\n    generic: string[];\n  };\n  totalCounts: {\n    groupIcons: number;\n    regularIcons: number;\n  };\n}",
    "start_line": 4,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DynamicAgentResources",
    "component_id": "client.generated.dynamicAgentResources.DynamicAgentResources"
  },
  "client.generated.dynamicAgentResources.getGroupIconsByProvider": {
    "id": "client.generated.dynamicAgentResources.getGroupIconsByProvider",
    "name": "getGroupIconsByProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/dynamicAgentResources.ts",
    "relative_path": "client/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function getGroupIconsByProvider(provider: 'aws' | 'gcp' | 'azure'): string[] {\n  return dynamicAgentResources.groupIcons[provider];\n}",
    "start_line": 1820,
    "end_line": 1822,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getGroupIconsByProvider",
    "component_id": "client.generated.dynamicAgentResources.getGroupIconsByProvider"
  },
  "client.generated.dynamicAgentResources.getRegularIconsByProvider": {
    "id": "client.generated.dynamicAgentResources.getRegularIconsByProvider",
    "name": "getRegularIconsByProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/dynamicAgentResources.ts",
    "relative_path": "client/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function getRegularIconsByProvider(provider: 'aws' | 'gcp' | 'azure' | 'generic'): string[] {\n  return dynamicAgentResources.regularIcons[provider];\n}",
    "start_line": 1824,
    "end_line": 1826,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getRegularIconsByProvider",
    "component_id": "client.generated.dynamicAgentResources.getRegularIconsByProvider"
  },
  "client.generated.dynamicAgentResources.isGroupIcon": {
    "id": "client.generated.dynamicAgentResources.isGroupIcon",
    "name": "isGroupIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/dynamicAgentResources.ts",
    "relative_path": "client/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function isGroupIcon(iconName: string): boolean {\n  return availableGroupIcons.includes(iconName);\n}",
    "start_line": 1828,
    "end_line": 1830,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isGroupIcon",
    "component_id": "client.generated.dynamicAgentResources.isGroupIcon"
  },
  "client.generated.dynamicAgentResources.isRegularIcon": {
    "id": "client.generated.dynamicAgentResources.isRegularIcon",
    "name": "isRegularIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/dynamicAgentResources.ts",
    "relative_path": "client/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function isRegularIcon(iconName: string): boolean {\n  return Object.values(availableRegularIcons).flat().includes(iconName);\n}",
    "start_line": 1832,
    "end_line": 1834,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isRegularIcon",
    "component_id": "client.generated.dynamicAgentResources.isRegularIcon"
  },
  "client.generated.dynamicAgentResources.getIconProvider": {
    "id": "client.generated.dynamicAgentResources.getIconProvider",
    "name": "getIconProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/dynamicAgentResources.ts",
    "relative_path": "client/generated/dynamicAgentResources.ts",
    "depends_on": [],
    "source_code": "function getIconProvider(iconName: string): 'aws' | 'gcp' | 'azure' | null {\n  if (iconName.startsWith('aws_')) return 'aws';\n  if (iconName.startsWith('gcp_')) return 'gcp';\n  if (iconName.startsWith('azure_')) return 'azure';\n  return null;\n}",
    "start_line": 1836,
    "end_line": 1841,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getIconProvider",
    "component_id": "client.generated.dynamicAgentResources.getIconProvider"
  },
  "client.generated.groupIconColors.GroupIcon": {
    "id": "client.generated.groupIconColors.GroupIcon",
    "name": "GroupIcon",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/groupIconColors.ts",
    "relative_path": "client/generated/groupIconColors.ts",
    "depends_on": [],
    "source_code": "interface GroupIcon {\n  name: string;   // Provider-prefixed name (aws_account, aws_cloud, etc.)\n  hex: string;    // Primary hex color (#E7157B, #242F3E, etc.)\n  fill: boolean;  // true = filled with color, false = border only\n}",
    "start_line": 4,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GroupIcon",
    "component_id": "client.generated.groupIconColors.GroupIcon"
  },
  "client.generated.groupIconColors.getGroupIconHex": {
    "id": "client.generated.groupIconColors.getGroupIconHex",
    "name": "getGroupIconHex",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/groupIconColors.ts",
    "relative_path": "client/generated/groupIconColors.ts",
    "depends_on": [],
    "source_code": "function getGroupIconHex(iconName: string): string | null {\n  return groupIconHexMap[iconName] || null;\n}",
    "start_line": 407,
    "end_line": 409,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getGroupIconHex",
    "component_id": "client.generated.groupIconColors.getGroupIconHex"
  },
  "client.generated.groupIconColors.isGroupIcon": {
    "id": "client.generated.groupIconColors.isGroupIcon",
    "name": "isGroupIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/groupIconColors.ts",
    "relative_path": "client/generated/groupIconColors.ts",
    "depends_on": [],
    "source_code": "function isGroupIcon(iconName: string): boolean {\n  return availableGroupIcons.includes(iconName);\n}",
    "start_line": 412,
    "end_line": 414,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isGroupIcon",
    "component_id": "client.generated.groupIconColors.isGroupIcon"
  },
  "client.generated.groupIconColors.getGroupIconsByProvider": {
    "id": "client.generated.groupIconColors.getGroupIconsByProvider",
    "name": "getGroupIconsByProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/groupIconColors.ts",
    "relative_path": "client/generated/groupIconColors.ts",
    "depends_on": [
      "client.generated.groupIconColors.GroupIcon"
    ],
    "source_code": "function getGroupIconsByProvider(provider: 'aws' | 'gcp' | 'azure'): GroupIcon[] {\n  if (provider === 'aws') return awsGroupIcons;\n  if (provider === 'gcp') return gcpGroupIcons;\n  return azureGroupIcons;\n}",
    "start_line": 417,
    "end_line": 421,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getGroupIconsByProvider",
    "component_id": "client.generated.groupIconColors.getGroupIconsByProvider"
  },
  "client.generated.iconLists.IconLists": {
    "id": "client.generated.iconLists.IconLists",
    "name": "IconLists",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/iconLists.ts",
    "relative_path": "client/generated/iconLists.ts",
    "depends_on": [],
    "source_code": "interface IconLists {\n  aws: { [category: string]: string[] };\n  gcp: { [category: string]: string[] };\n  azure: { [category: string]: string[] };\n  generic: string[];\n  all: string[];\n}",
    "start_line": 4,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IconLists",
    "component_id": "client.generated.iconLists.IconLists"
  },
  "client.generated.iconLists.getIconsByProvider": {
    "id": "client.generated.iconLists.getIconsByProvider",
    "name": "getIconsByProvider",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/iconLists.ts",
    "relative_path": "client/generated/iconLists.ts",
    "depends_on": [],
    "source_code": "function getIconsByProvider(provider: 'aws' | 'gcp' | 'azure'): { [category: string]: string[] } {\n  return iconLists[provider];\n}",
    "start_line": 2638,
    "end_line": 2640,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getIconsByProvider",
    "component_id": "client.generated.iconLists.getIconsByProvider"
  },
  "client.generated.iconLists.getIconsByCategory": {
    "id": "client.generated.iconLists.getIconsByCategory",
    "name": "getIconsByCategory",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/iconLists.ts",
    "relative_path": "client/generated/iconLists.ts",
    "depends_on": [],
    "source_code": "function getIconsByCategory(category: string): string[] {\n  const icons: string[] = [];\n  \n  for (const provider of ['aws', 'gcp', 'azure'] as const) {\n    if (iconLists[provider][category]) {\n      icons.push(...iconLists[provider][category]);\n    }\n  }\n  \n  return Array.from(new Set(icons)).sort();\n}",
    "start_line": 2643,
    "end_line": 2653,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "category"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getIconsByCategory",
    "component_id": "client.generated.iconLists.getIconsByCategory"
  },
  "client.generated.iconLists.searchIcons": {
    "id": "client.generated.iconLists.searchIcons",
    "name": "searchIcons",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/iconLists.ts",
    "relative_path": "client/generated/iconLists.ts",
    "depends_on": [],
    "source_code": "function searchIcons(query: string): string[] {\n  return iconLists.all.filter(icon => \n    icon.toLowerCase().includes(query.toLowerCase())\n  );\n}",
    "start_line": 2656,
    "end_line": 2660,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "query"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function searchIcons",
    "component_id": "client.generated.iconLists.searchIcons"
  },
  "client.generated.iconLists.getProviderPrefixedIcons": {
    "id": "client.generated.iconLists.getProviderPrefixedIcons",
    "name": "getProviderPrefixedIcons",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/iconLists.ts",
    "relative_path": "client/generated/iconLists.ts",
    "depends_on": [],
    "source_code": "function getProviderPrefixedIcons(provider: 'aws' | 'gcp' | 'azure'): string[] {\n  const providerIcons = Object.values(iconLists[provider]).flat();\n  return providerIcons.map(icon => `${provider}_${icon}`).sort();\n}",
    "start_line": 2663,
    "end_line": 2666,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "provider"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getProviderPrefixedIcons",
    "component_id": "client.generated.iconLists.getProviderPrefixedIcons"
  },
  "client.generated.iconLists.parseIconName": {
    "id": "client.generated.iconLists.parseIconName",
    "name": "parseIconName",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/generated/iconLists.ts",
    "relative_path": "client/generated/iconLists.ts",
    "depends_on": [],
    "source_code": "function parseIconName(prefixedIcon: string): { provider: string; icon: string } | null {\n  const match = prefixedIcon.match(/^(aws|gcp|azure)_(.+)$/);\n  return match ? { provider: match[1], icon: match[2] } : null;\n}",
    "start_line": 2669,
    "end_line": 2672,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "prefixedIcon"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseIconName",
    "component_id": "client.generated.iconLists.parseIconName"
  },
  "client.hooks.canvas.useCanvasEdgeInteractions.useCanvasEdgeInteractions": {
    "id": "client.hooks.canvas.useCanvasEdgeInteractions.useCanvasEdgeInteractions",
    "name": "useCanvasEdgeInteractions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/canvas/useCanvasEdgeInteractions.ts",
    "relative_path": "client/hooks/canvas/useCanvasEdgeInteractions.ts",
    "depends_on": [],
    "source_code": "function useCanvasEdgeInteractions(...args: any[]) {\n  return {};\n}",
    "start_line": 1,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useCanvasEdgeInteractions",
    "component_id": "client.hooks.canvas.useCanvasEdgeInteractions.useCanvasEdgeInteractions"
  },
  "client.hooks.canvas.useCanvasEdgeInteractions.EdgeInteractionParams": {
    "id": "client.hooks.canvas.useCanvasEdgeInteractions.EdgeInteractionParams",
    "name": "EdgeInteractionParams",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/canvas/useCanvasEdgeInteractions.tsx",
    "relative_path": "client/hooks/canvas/useCanvasEdgeInteractions.tsx",
    "depends_on": [],
    "source_code": "interface EdgeInteractionParams {\n  selectedTool: string;\n  setSelectedTool: (tool: string) => void;\n  selectedNodes: Node[];\n  setSelectedNodes: React.Dispatch<React.SetStateAction<Node[]>>;\n  connectingFrom: string | null;\n  connectingFromHandle: string | null;\n  setConnectingFrom: React.Dispatch<React.SetStateAction<string | null>>;\n  setConnectingFromHandle: React.Dispatch<React.SetStateAction<string | null>>;\n  connectionMousePos: Coordinate | null;\n  setConnectionMousePos: React.Dispatch<React.SetStateAction<Coordinate | null>>;\n  reactFlowRef: MutableRefObject<ReactFlowInstance | null>;\n  onConnect: (connection: Connection) => void;\n  nodes: Node[];\n}",
    "start_line": 11,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeInteractionParams",
    "component_id": "client.hooks.canvas.useCanvasEdgeInteractions.EdgeInteractionParams"
  },
  "client.hooks.canvas.useCanvasInitialization.UseCanvasStateParams": {
    "id": "client.hooks.canvas.useCanvasInitialization.UseCanvasStateParams",
    "name": "UseCanvasStateParams",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/canvas/useCanvasInitialization.ts",
    "relative_path": "client/hooks/canvas/useCanvasInitialization.ts",
    "depends_on": [
      "client.services.architectureService.SavedArchitecture"
    ],
    "source_code": "interface UseCanvasStateParams {\n  selectedTool: string;\n  user: User | null;\n  savedArchitectures: SavedArchitecture[];\n  setSavedArchitectures: (architectures: SavedArchitecture[]) => void;\n  selectedArchitectureId: string;\n  setSelectedArchitectureId: (id: string) => void;\n  setCurrentChatName: (name: string) => void;\n  showNotification: (message: string, type?: string) => void;\n  hideNotification: () => void;\n  setDeleteOverlay: (overlay: any) => void;\n  setInputOverlay: (overlay: any) => void;\n  setShareOverlay: (overlay: any) => void;\n  isPublicMode: boolean;\n}",
    "start_line": 22,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseCanvasStateParams",
    "component_id": "client.hooks.canvas.useCanvasInitialization.UseCanvasStateParams"
  },
  "client.hooks.canvas.useCanvasInitialization.UseCanvasStateReturn": {
    "id": "client.hooks.canvas.useCanvasInitialization.UseCanvasStateReturn",
    "name": "UseCanvasStateReturn",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/canvas/useCanvasInitialization.ts",
    "relative_path": "client/hooks/canvas/useCanvasInitialization.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState",
      "client.services.canvasSaveService.CanvasSaveService",
      "client.services.canvasArchitectureService.CanvasArchitectureService"
    ],
    "source_code": "interface UseCanvasStateReturn {\n  // Graph state\n  rawGraph: any;\n  nodes: any[];\n  edges: any[];\n  layoutVersion: number;\n  \n  // Setters\n  setRawGraph: (newGraph: any, overrideSource?: 'ai' | 'user') => void;\n  setNodes: any;\n  setEdges: any;\n  \n  // Handlers\n  onNodesChange: any;\n  onEdgesChange: any;\n  onConnect: any;\n  handleLabelChange: any;\n  handleAddNode: any;\n  handleDeleteNode: any;\n  handleMoveNode: any;\n  handleAddEdge: any;\n  handleDeleteEdge: any;\n  handleGroupNodes: any;\n  handleRemoveGroup: any;\n  handleBatchUpdate: any;\n  \n  // ViewState\n  viewStateRef: React.RefObject<ViewState>;\n  shouldSkipFitViewRef: any;\n  getViewStateSnapshot: () => ViewState | undefined;\n  \n  // Refs for Orchestrator\n  rawGraphRef: React.MutableRefObject<any>;\n  \n  // Services\n  architectureService: CanvasArchitectureService;\n  saveService: CanvasSaveService;\n  \n  // Handlers from services\n  handleDeleteArchitecture: any;\n  handleShareArchitecture: any;\n  handleEditArchitecture: any;\n  \n  // Persistence\n  skipPersistenceRef: React.MutableRefObject<boolean>;\n  restoredFromSnapshotRef: React.MutableRefObject<boolean>;\n}",
    "start_line": 38,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseCanvasStateReturn",
    "component_id": "client.hooks.canvas.useCanvasInitialization.UseCanvasStateReturn"
  },
  "client.hooks.canvas.useCanvasInitialization.useCanvasInitialization": {
    "id": "client.hooks.canvas.useCanvasInitialization.useCanvasInitialization",
    "name": "useCanvasInitialization",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/canvas/useCanvasInitialization.ts",
    "relative_path": "client/hooks/canvas/useCanvasInitialization.ts",
    "depends_on": [
      "client.services.canvasSaveService.CanvasSaveService",
      "client.utils.migrationTestHelpers.setupWindowHelpers",
      "client.hooks.useElkToReactflowGraphConverter.useElkToReactflowGraphConverter",
      "client.hooks.canvas.useCanvasInitialization.UseCanvasStateParams",
      "client.utils.canvasPersistence.createViewStateSnapshot",
      "client.viewstate.ViewState.createEmptyViewState",
      "client.services.canvasArchitectureService.CanvasArchitectureService",
      "client.hooks.canvas.useCanvasInitialization.UseCanvasStateReturn"
    ],
    "source_code": "function useCanvasInitialization(params: UseCanvasStateParams): UseCanvasStateReturn {\n  const {\n    selectedTool,\n    user,\n    savedArchitectures,\n    setSavedArchitectures,\n    selectedArchitectureId,\n    setSelectedArchitectureId,\n    setCurrentChatName,\n    showNotification,\n    hideNotification,\n    setDeleteOverlay,\n    setInputOverlay,\n    setShareOverlay,\n    isPublicMode\n  } = params;\n\n  // Add persistence skip ref and restoration tracking\n  const skipPersistenceRef = useRef<boolean>(false);\n  const restoredFromSnapshotRef = useRef<boolean>(false);\n\n  // Use existing infrastructure - the ELK hook now properly bypasses ELK for FREE mode\n  const {\n    rawGraph,\n    nodes,\n    edges,\n    layoutVersion,\n    \n    // Setters\n    setRawGraph: originalSetRawGraph,\n    setNodes,\n    setEdges,\n    \n    // Handlers\n    onNodesChange,\n    onEdgesChange,\n    onConnect,\n    handleLabelChange,\n    handleAddNode,\n    handleDeleteNode,\n    handleMoveNode,\n    handleAddEdge,\n    handleDeleteEdge,\n    handleGroupNodes,\n    handleRemoveGroup,\n    handleBatchUpdate,\n    \n    viewStateRef,\n    shouldSkipFitViewRef,\n    rawGraphRef,\n  } = useElkToReactflowGraphConverter({\n    id: \"root\",\n    children: [],\n    edges: []\n  }, selectedTool);\n\n  // Wrap setRawGraph (removed arbitrary guards per user feedback)\n  const setRawGraph = useCallback((newGraph: any, overrideSource?: 'ai' | 'user') => {\n    // CRITICAL: Pass through overrideSource so AI graphs trigger ELK\n    originalSetRawGraph(newGraph, overrideSource);\n  }, [originalSetRawGraph]);\n\n  // ViewState snapshot utility\n  const getViewStateSnapshot = useCallback(() => {\n    return createViewStateSnapshot(nodes, viewStateRef, { current: false }); // isHydratingRef placeholder\n  }, [nodes, viewStateRef]);\n\n  // Setup migration test helpers for browser console (dev only)\n  // CRITICAL: Use rawGraphRef.current instead of rawGraph React state\n  // because FREE mode Orchestrator updates the ref directly without React state\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      setupWindowHelpers(\n        () => viewStateRef.current || createEmptyViewState(),\n        () => rawGraphRef.current || rawGraph  // Prefer ref, fallback to state\n      );\n    }\n  }, [rawGraph, viewStateRef, rawGraphRef]);\n\n  // RESTORATION LOGIC MOVED TO ORCHESTRATOR\n  // This hook should NOT handle restoration - that's the Orchestrator's job\n  // The Orchestrator will handle restoration during its initialization\n\n  // Initialize architecture service\n  const architectureService = useMemo(() => new CanvasArchitectureService({\n    user,\n    savedArchitectures,\n    setSavedArchitectures,\n    selectedArchitectureId,\n    setSelectedArchitectureId,\n    setCurrentChatName,\n    setRawGraph,\n    viewStateRef,\n    getViewStateSnapshot,\n    showNotification,\n    hideNotification,\n    setDeleteOverlay,\n    setInputOverlay,\n    setShareOverlay\n  }), [\n    user, \n    savedArchitectures, \n    setSavedArchitectures, \n    selectedArchitectureId, \n    setSelectedArchitectureId, \n    setCurrentChatName, \n    setRawGraph, \n    viewStateRef, \n    getViewStateSnapshot, \n    showNotification, \n    hideNotification, \n    setDeleteOverlay, \n    setInputOverlay, \n    setShareOverlay\n  ]);\n\n  // Extract handlers from architecture service\n  const handleDeleteArchitecture = architectureService.handleDeleteArchitecture;\n  const handleShareArchitecture = architectureService.handleShareArchitecture;\n  const handleEditArchitecture = architectureService.handleEditArchitecture;\n\n  // Initialize save service  \n  const saveService = useMemo(() => new CanvasSaveService({\n    user,\n    selectedArchitectureId,\n    savedArchitectures,\n    setSavedArchitectures,\n    rawGraph,\n    isPublicMode,\n    getViewStateSnapshot,\n    isHydratingRef: { current: false }, // placeholder\n    dirtySinceRef: { current: false }, // placeholder\n    remoteSaveTimeoutRef: { current: null } // placeholder\n  }), [\n    user,\n    selectedArchitectureId,\n    savedArchitectures,\n    setSavedArchitectures,\n    rawGraph,\n    isPublicMode,\n    getViewStateSnapshot\n  ]);\n\n  return {\n    // Graph state\n    rawGraph,\n    nodes,\n    edges,\n    layoutVersion,\n    \n    // Setters\n    setRawGraph,\n    setNodes,\n    setEdges,\n    \n    // Handlers\n    onNodesChange,\n    onEdgesChange,\n    onConnect,\n    handleLabelChange,\n    handleAddNode,\n    handleDeleteNode,\n    handleMoveNode,\n    handleAddEdge,\n    handleDeleteEdge,\n    handleGroupNodes,\n    handleRemoveGroup,\n    handleBatchUpdate,\n    \n    // ViewState\n    viewStateRef,\n    shouldSkipFitViewRef,\n    getViewStateSnapshot,\n    \n    // Refs for Orchestrator\n    rawGraphRef,\n    \n    // Services\n    architectureService,\n    saveService,\n    \n    // Handlers from services\n    handleDeleteArchitecture,\n    handleShareArchitecture,\n    handleEditArchitecture,\n    \n    // Persistence\n    skipPersistenceRef,\n    restoredFromSnapshotRef,\n  };\n}",
    "start_line": 86,
    "end_line": 276,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useCanvasInitialization",
    "component_id": "client.hooks.canvas.useCanvasInitialization.useCanvasInitialization"
  },
  "client.hooks.canvas.useCanvasPersistence.useCanvasPersistenceEffect": {
    "id": "client.hooks.canvas.useCanvasPersistence.useCanvasPersistenceEffect",
    "name": "useCanvasPersistenceEffect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/canvas/useCanvasPersistence.ts",
    "relative_path": "client/hooks/canvas/useCanvasPersistence.ts",
    "depends_on": [],
    "source_code": "function useCanvasPersistenceEffect(...args: any[]) {}",
    "start_line": 1,
    "end_line": 1,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useCanvasPersistenceEffect",
    "component_id": "client.hooks.canvas.useCanvasPersistence.useCanvasPersistenceEffect"
  },
  "client.hooks.useArchitectureManager.ArchitectureTab": {
    "id": "client.hooks.useArchitectureManager.ArchitectureTab",
    "name": "ArchitectureTab",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useArchitectureManager.ts",
    "relative_path": "client/hooks/useArchitectureManager.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "interface ArchitectureTab {\n  id: string;\n  name: string;\n  timestamp: Date;\n  rawGraph?: RawGraph | null;\n  firebaseId?: string;\n  userPrompt?: string;\n  isFromFirebase?: boolean;\n  isNew?: boolean;\n  isShared?: boolean;\n}",
    "start_line": 7,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ArchitectureTab",
    "component_id": "client.hooks.useArchitectureManager.ArchitectureTab"
  },
  "client.hooks.useArchitectureManager.useArchitectureState": {
    "id": "client.hooks.useArchitectureManager.useArchitectureState",
    "name": "useArchitectureState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useArchitectureManager.ts",
    "relative_path": "client/hooks/useArchitectureManager.ts",
    "depends_on": [],
    "source_code": "function useArchitectureState() {\n  // Architecture state\n  const [savedArchitectures, setSavedArchitectures] = useState<ArchitectureTab[]>(() => {\n    // Start with \"New Architecture\" as first tab\n    const newArchTab = {\n      id: 'new-architecture',\n      name: 'New Architecture',\n      timestamp: new Date(),\n      rawGraph: { id: \"root\", children: [], edges: [] },\n      isNew: true\n    };\n    // Only show the \"New Architecture\" tab initially - no mock architectures\n    return [newArchTab];\n  });\n\n  const [selectedArchitectureId, setSelectedArchitectureId] = useState<string>('new-architecture');\n  const [currentChatName, setCurrentChatName] = useState<string>('New Architecture');\n\n  return {\n    savedArchitectures,\n    setSavedArchitectures,\n    selectedArchitectureId,\n    setSelectedArchitectureId,\n    currentChatName,\n    setCurrentChatName,\n  };\n}",
    "start_line": 19,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useArchitectureState",
    "component_id": "client.hooks.useArchitectureManager.useArchitectureState"
  },
  "client.hooks.useAuthListener.UseAuthListenerProps": {
    "id": "client.hooks.useAuthListener.UseAuthListenerProps",
    "name": "UseAuthListenerProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useAuthListener.ts",
    "relative_path": "client/hooks/useAuthListener.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "interface UseAuthListenerProps {\n  config: {\n    requiresAuth: boolean;\n    mode: string;\n  };\n  setUser: (user: User | null) => void;\n  setSidebarCollapsed: (collapsed: boolean) => void;\n  setRawGraph: React.Dispatch<React.SetStateAction<RawGraph | null>>;\n  setSavedArchitectures: React.Dispatch<React.SetStateAction<any[]>>;\n  setSelectedArchitectureId: (id: string) => void;\n  setCurrentChatName: (name: string) => void;\n  setUrlArchitectureProcessed: (processed: boolean) => void;\n  setHasInitialSync: (synced: boolean) => void;\n  hasInitialSync: boolean;\n  user: User | null;\n}",
    "start_line": 10,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseAuthListenerProps",
    "component_id": "client.hooks.useAuthListener.UseAuthListenerProps"
  },
  "client.hooks.useAuthListener.useAuthListener": {
    "id": "client.hooks.useAuthListener.useAuthListener",
    "name": "useAuthListener",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useAuthListener.ts",
    "relative_path": "client/hooks/useAuthListener.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.chatPersistence.isEmbedToCanvasTransition",
      "client.utils.chatPersistence.clearEmbedToCanvasFlag",
      "client.services.anonymousArchitectureService.getArchitectureIdFromUrl",
      "client.services.architectureService.saveArchitecture",
      "client.services.anonymousArchitectureService.loadAnonymousArchitectureById",
      "client.hooks.useAuthListener.UseAuthListenerProps",
      "client.utils.chatPersistence.getChatMessages",
      "client.utils.chatUtils.generateChatName",
      "scripts.test-vercel-preview.error",
      "client.services.architectureService.loadUserArchitectures"
    ],
    "source_code": "function useAuthListener({\n  config,\n  setUser,\n  setSidebarCollapsed,\n  setRawGraph,\n  setSavedArchitectures,\n  setSelectedArchitectureId,\n  setCurrentChatName,\n  setUrlArchitectureProcessed,\n  setHasInitialSync,\n  hasInitialSync,\n  user\n}: UseAuthListenerProps) {\n  const [isPublicMode] = useState(config.mode === 'canvas');\n\n  useEffect(() => {\n    if (!auth) return;\n\n    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {\n      \n      // Canvas mode: redirect to auth if user signs in, preserving architecture URL parameter\n      if (!config.requiresAuth && currentUser) {\n        \n        // Preserve the architecture ID from the current URL\n        const currentParams = new URLSearchParams(window.location.search);\n        const archId = currentParams.get('arch');\n        \n        let authUrl = window.location.origin + '/auth';\n        if (archId) {\n          authUrl += `?arch=${archId}`;\n        }\n        \n        window.location.href = authUrl;\n        return;\n      }\n      \n      // Auth mode: use actual auth state\n      if (config.requiresAuth) {\n        setUser(currentUser);\n        \n        // Auto-open sidebar when user signs in, close when they sign out\n        if (currentUser) {\n          setSidebarCollapsed(false);\n          \n          // Check if user is coming from embed view (Edit button transition)\n          const isFromEmbed = isEmbedToCanvasTransition();\n          if (isFromEmbed) {\n            console.log('üîÑ Detected embed-to-auth transition, clearing flag and ensuring sync');\n            clearEmbedToCanvasFlag();\n            \n            // Force Firebase sync if user is already authenticated but coming from embed\n            if (!hasInitialSync) {\n              console.log('üîÑ Forcing Firebase sync for embed-to-auth transition');\n              // Note: syncWithFirebase function would need to be passed in or implemented here\n              setHasInitialSync(true);\n            }\n          }\n          \n          // Check if there's a URL architecture that needs to be processed\n          const urlArchId = anonymousArchitectureService.getArchitectureIdFromUrl();\n          console.log('üîç [URL-ARCH] Checking for URL architecture ID:', urlArchId);\n          if (urlArchId) {\n            // Set flag immediately to prevent Firebase sync\n            setUrlArchitectureProcessed(true);\n            \n            // Process URL architecture immediately\n            (async () => {\n              try {\n                const urlArch = await anonymousArchitectureService.loadAnonymousArchitectureById(urlArchId);\n                if (urlArch) {\n                  // Set the architecture content\n                  setRawGraph(urlArch.rawGraph);\n                  \n                  // Generate name and save as user architecture\n                  // Get user prompt from chat persistence (more reliable than window globals)\n                  const persistedMessages = getChatMessages();\n                  const lastUserMessage = persistedMessages.filter(msg => msg.sender === 'user').pop();\n                  const userPrompt = lastUserMessage?.content || (window as any).originalChatTextInput || (window as any).chatTextInput || '';\n                  \n                  console.log('üîç [URL-ARCH] User prompt sources:', {\n                    fromPersistence: lastUserMessage?.content || 'none',\n                    fromWindow: (window as any).originalChatTextInput || 'none',\n                    finalPrompt: userPrompt\n                  });\n                  \n                  let baseChatName;\n                  if (userPrompt) {\n                    baseChatName = await generateChatName(userPrompt, urlArch.rawGraph);\n                    console.log('‚úÖ [URL-ARCH] Generated name from prompt:', baseChatName);\n                  } else {\n                    // Fallback: generate name from architecture content\n                    const nodeLabels = urlArch.rawGraph?.children?.map((node: any) => node.data?.label || node.id).filter(Boolean) || [];\n                    const fallbackPrompt = nodeLabels.length > 0 ? `Architecture with: ${nodeLabels.slice(0, 3).join(', ')}` : 'Cloud Architecture';\n                    baseChatName = await generateChatName(fallbackPrompt, urlArch.rawGraph);\n                    console.log('üîÑ [URL-ARCH] Generated name from architecture content:', baseChatName);\n                  }\n                  \n                  // Save as new user architecture\n                  const savedArchId = await ArchitectureService.saveArchitecture({\n                    name: baseChatName,\n                    userId: currentUser.uid,\n                    userEmail: currentUser.email || '',\n                    rawGraph: urlArch.rawGraph,\n                    userPrompt: userPrompt,\n                    nodes: [],\n                    edges: []\n                  });\n                  \n                  // ALWAYS load existing user architectures to ensure sidebar shows all saved architectures\n                  console.log('üîÑ Loading all Firebase architectures for authenticated user');\n                  const firebaseArchs = await ArchitectureService.loadUserArchitectures(currentUser.uid);\n                  const validArchs = firebaseArchs.filter(arch => arch && arch.id && arch.name && arch.rawGraph);\n                  \n                  // Create the new tab for URL architecture\n                  const newUrlArchTab = {\n                    id: savedArchId,\n                    name: baseChatName,\n                    timestamp: new Date(),\n                    rawGraph: urlArch.rawGraph,\n                    firebaseId: savedArchId,\n                    userPrompt: userPrompt,\n                    isFromFirebase: true,\n                    isShared: false\n                  };\n                  \n                  // Combine with existing architectures and set as current\n                  const updatedArchitectures = [...validArchs, newUrlArchTab];\n                  setSavedArchitectures(updatedArchitectures);\n                  setSelectedArchitectureId(savedArchId);\n                  setCurrentChatName(baseChatName);\n                  \n                  console.log('‚úÖ [URL-ARCH] Successfully processed URL architecture:', {\n                    savedArchId,\n                    baseChatName,\n                    totalArchitectures: updatedArchitectures.length\n                  });\n                }\n              } catch (error) {\n                console.error('‚ùå [URL-ARCH] Failed to process URL architecture:', error);\n                // Fallback: load shared architecture normally\n                // Note: loadSharedAnonymousArchitecture function would need to be passed in\n              }\n            })();\n          } else if (!hasInitialSync) {\n            // No URL architecture - load user's Firebase architectures\n            console.log('üîÑ No URL architecture found, loading Firebase architectures for authenticated user');\n            (async () => {\n              try {\n                const firebaseArchs = await ArchitectureService.loadUserArchitectures(currentUser.uid);\n                const validArchs = firebaseArchs.filter(arch => arch && arch.id && arch.name && arch.rawGraph);\n                \n                if (validArchs.length > 0) {\n                  // Add to saved architectures, preserving \"New Architecture\" tab\n                  setSavedArchitectures(prev => {\n                    const existingArchs = prev.filter(arch => arch.id !== 'new-architecture');\n                    return [...existingArchs, ...validArchs];\n                  });\n                  \n                  // Select the most recent architecture\n                  const mostRecent = validArchs.sort((a, b) => \n                    new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n                  )[0];\n                  \n                  setSelectedArchitectureId(mostRecent.id);\n                  setCurrentChatName(mostRecent.name);\n                  setRawGraph(mostRecent.rawGraph);\n                  \n                  console.log('‚úÖ [FIREBASE] Loaded user architectures:', {\n                    count: validArchs.length,\n                    selected: mostRecent.name\n                  });\n                }\n                \n                setHasInitialSync(true);\n              } catch (error) {\n                console.error('‚ùå [FIREBASE] Failed to load user architectures:', error);\n                setHasInitialSync(true); // Prevent retry loops\n              }\n            })();\n          }\n        } else {\n          // User signed out\n          setSidebarCollapsed(true);\n          setHasInitialSync(false);\n          \n          // Check if there's a shared architecture to load after sign out\n          const urlArchId = anonymousArchitectureService.getArchitectureIdFromUrl();\n          if (urlArchId) {\n            console.log('üîÑ User signed out, loading shared architecture from URL:', urlArchId);\n            // Note: loadSharedAnonymousArchitecture function would need to be passed in\n          }\n        }\n      }\n    });\n    return () => unsubscribe();\n  }, [isPublicMode, config.mode, config.requiresAuth, hasInitialSync, user]);\n}",
    "start_line": 27,
    "end_line": 223,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useAuthListener",
    "component_id": "client.hooks.useAuthListener.useAuthListener"
  },
  "client.hooks.useCanvasInteractions.UseCanvasInteractionsProps": {
    "id": "client.hooks.useCanvasInteractions.UseCanvasInteractionsProps",
    "name": "UseCanvasInteractionsProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useCanvasInteractions.ts",
    "relative_path": "client/hooks/useCanvasInteractions.ts",
    "depends_on": [
      "client.hooks.useToolSelection.Tool"
    ],
    "source_code": "interface UseCanvasInteractionsProps {\n  selectedTool: Tool;\n  reactFlowRef: React.RefObject<ReactFlowInstance>;\n  handleAddNode: (id: string, parentId: string, data: { label: string }) => void;\n  viewStateRef: React.RefObject<any>;\n  handleToolSelect: (tool: Tool) => void;\n}",
    "start_line": 6,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseCanvasInteractionsProps",
    "component_id": "client.hooks.useCanvasInteractions.UseCanvasInteractionsProps"
  },
  "client.hooks.useCanvasInteractions.useCanvasInteractions": {
    "id": "client.hooks.useCanvasInteractions.useCanvasInteractions",
    "name": "useCanvasInteractions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useCanvasInteractions.ts",
    "relative_path": "client/hooks/useCanvasInteractions.ts",
    "depends_on": [
      "client.hooks.useCanvasInteractions.UseCanvasInteractionsProps",
      "scripts.test-vercel-preview.log",
      "client.utils.canvas.canvasInteractions.placeNodeOnCanvas",
      "client.hooks.useToolSelection.Tool"
    ],
    "source_code": "useCanvasInteractions = ({\n  selectedTool,\n  reactFlowRef,\n  handleAddNode,\n  viewStateRef,\n  handleToolSelect\n}: UseCanvasInteractionsProps) => {\n  \n  const onPaneClick = useCallback((event: React.MouseEvent) => {\n    console.log('üñ±Ô∏è [Canvas onClick] Tool:', selectedTool, 'Target:', event.target);\n    \n    // Only handle pane clicks for certain tools\n    switch (selectedTool) {\n      case 'box':\n        // Place a new node when clicking on the canvas with box tool\n        if (reactFlowRef.current) {\n          placeNodeOnCanvas(\n            event,\n            reactFlowRef.current,\n            selectedTool,\n            handleAddNode,\n            viewStateRef,\n            (newTool: Tool) => handleToolSelect(newTool)\n          );\n        }\n        break;\n      \n      case 'select':\n        // Deselect all nodes and edges when clicking on empty canvas\n        // This is handled by ReactFlow's onSelectionChange\n        break;\n        \n      default:\n        // For other tools, do nothing on pane click\n        break;\n    }\n  }, [selectedTool, reactFlowRef, handleAddNode, viewStateRef, handleToolSelect]);\n\n  return {\n    onPaneClick\n  };\n}",
    "start_line": 14,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useCanvasInteractions",
    "component_id": "client.hooks.useCanvasInteractions.useCanvasInteractions"
  },
  "client.hooks.useCanvasState.Tool": {
    "id": "client.hooks.useCanvasState.Tool",
    "name": "Tool",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useCanvasState.ts",
    "relative_path": "client/hooks/useCanvasState.ts",
    "depends_on": [],
    "source_code": "type Tool = 'select' | 'box' | 'connector' | 'group' | 'arrow' | 'hand';",
    "start_line": 4,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Tool",
    "component_id": "client.hooks.useCanvasState.Tool"
  },
  "client.hooks.useCanvasState.useCanvasState": {
    "id": "client.hooks.useCanvasState.useCanvasState",
    "name": "useCanvasState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useCanvasState.ts",
    "relative_path": "client/hooks/useCanvasState.ts",
    "depends_on": [
      "client.hooks.useCanvasState.Tool"
    ],
    "source_code": "function useCanvasState(params?: any): any {\n  const [svgPan, setSvgPan] = useState({ x: 0, y: 0 });\n  const [svgZoom, setSvgZoom] = useState(1);\n  const [svgContent, setSvgContent] = useState<string | null>(null);\n  const [showDev, setShowDev] = useState(false);\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n  const [savedArchitectures, setSavedArchitectures] = useState<any[]>([]);\n  const [selectedArchitectureId, setSelectedArchitectureId] = useState<string | null>(null);\n  const [pendingArchitectureSelection, setPendingArchitectureSelection] = useState<string | null>(null);\n  const [agentLockedArchitectureId, setAgentLockedArchitectureId] = useState<string | null>(null);\n  const [user, setUser] = useState<any>(null);\n  const [isLoadingArchitectures, setIsLoadingArchitectures] = useState(false);\n  const [urlArchitectureProcessed, setUrlArchitectureProcessed] = useState(false);\n  const [justCreatedArchId, setJustCreatedArchId] = useState<string | null>(null);\n  const [hasInitialSync, setHasInitialSync] = useState(false);\n  const [isSaving, setIsSaving] = useState(false);\n  const [saveSuccess, setSaveSuccess] = useState(false);\n  const [realtimeSyncId, setRealtimeSyncId] = useState<string | null>(null);\n  const [isRealtimeSyncing, setIsRealtimeSyncing] = useState(false);\n  const [isSyncing, setIsSyncing] = useState(false);\n  const [currentChatName, setCurrentChatName] = useState('');\n  const [agentBusy, setAgentBusy] = useState(false);\n  const [shareOverlay, setShareOverlay] = useState<any>(null);\n  const [copyButtonState, setCopyButtonState] = useState({ copied: false });\n  const [inputOverlay, setInputOverlay] = useState<any>(null);\n  const [deleteOverlay, setDeleteOverlay] = useState<any>(null);\n  const [notification, setNotification] = useState<any>(null);\n  const [architectureOperations, setArchitectureOperations] = useState<any>({});\n  const [selectedTool, setSelectedTool] = useState<Tool>('arrow');\n  const [selectedNodes, setSelectedNodes] = useState<Node[]>([]);\n  const [selectedEdges, setSelectedEdges] = useState<Edge[]>([]);\n  const [selectedNodeIds, setSelectedNodeIds] = useState<string[]>([]);\n  const [useReactFlow, setUseReactFlow] = useState(true);\n  const [showElkDebug, setShowElkDebug] = useState(false);\n  const [connectingFrom, setConnectingFrom] = useState<string | null>(null);\n  const [connectingFromHandle, setConnectingFromHandle] = useState<string | null>(null);\n  const [connectionMousePos, setConnectionMousePos] = useState<{ x: number; y: number } | null>(null);\n  \n  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const isHydratingRef = useRef(false);\n  const expectedHydratedNodeCountRef = useRef(0);\n  const hydratedArchitectureIdRef = useRef<string | null>(null);\n  const dirtySinceRef = useRef(false);\n  const remoteSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const restoredFromSnapshotRef = useRef(false);\n  const skipPersistenceRef = useRef(false);\n  const pendingSelectionRef = useRef<string[] | null>(null);\n\n  return {\n    svgPan, setSvgPan,\n    svgZoom, setSvgZoom,\n    svgContent, setSvgContent,\n    showDev, setShowDev,\n    sidebarCollapsed, setSidebarCollapsed,\n    savedArchitectures, setSavedArchitectures,\n    selectedArchitectureId, setSelectedArchitectureId,\n    pendingArchitectureSelection, setPendingArchitectureSelection,\n    agentLockedArchitectureId, setAgentLockedArchitectureId,\n    user, setUser,\n    isLoadingArchitectures, setIsLoadingArchitectures,\n    urlArchitectureProcessed, setUrlArchitectureProcessed,\n    justCreatedArchId, setJustCreatedArchId,\n    hasInitialSync, setHasInitialSync,\n    isSaving, setIsSaving,\n    saveSuccess, setSaveSuccess,\n    realtimeSyncId, setRealtimeSyncId,\n    isRealtimeSyncing, setIsRealtimeSyncing,\n    isSyncing, setIsSyncing,\n    currentChatName, setCurrentChatName,\n    agentBusy, setAgentBusy,\n    shareOverlay, setShareOverlay,\n    copyButtonState, setCopyButtonState,\n    inputOverlay, setInputOverlay,\n    deleteOverlay, setDeleteOverlay,\n    notification, setNotification,\n    architectureOperations, setArchitectureOperations,\n    selectedTool, setSelectedTool,\n    selectedNodes, setSelectedNodes,\n    selectedEdges, setSelectedEdges,\n    selectedNodeIds, setSelectedNodeIds,\n    useReactFlow, setUseReactFlow,\n    showElkDebug, setShowElkDebug,\n    connectingFrom, setConnectingFrom,\n    connectingFromHandle, setConnectingFromHandle,\n    connectionMousePos, setConnectionMousePos,\n    syncTimeoutRef,\n    isHydratingRef,\n    expectedHydratedNodeCountRef,\n    hydratedArchitectureIdRef,\n    dirtySinceRef,\n    remoteSaveTimeoutRef,\n    restoredFromSnapshotRef,\n    skipPersistenceRef,\n    pendingSelectionRef,\n  };\n}",
    "start_line": 6,
    "end_line": 101,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useCanvasState",
    "component_id": "client.hooks.useCanvasState.useCanvasState"
  },
  "client.hooks.useChatSession.isValidTextContent": {
    "id": "client.hooks.useChatSession.isValidTextContent",
    "name": "isValidTextContent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useChatSession.ts",
    "relative_path": "client/hooks/useChatSession.ts",
    "depends_on": [],
    "source_code": "function isValidTextContent(content: any): content is TextContent {\n  return content && content.type === 'text' && typeof content.text === 'string';\n}",
    "start_line": 14,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "content"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidTextContent",
    "component_id": "client.hooks.useChatSession.isValidTextContent"
  },
  "client.hooks.useChatSession.UseChatSessionProps": {
    "id": "client.hooks.useChatSession.UseChatSessionProps",
    "name": "UseChatSessionProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useChatSession.ts",
    "relative_path": "client/hooks/useChatSession.ts",
    "depends_on": [],
    "source_code": "interface UseChatSessionProps {\n  isSessionActive: boolean;\n  sendTextMessage?: (message: string) => void;\n  sendClientEvent?: (event: any) => void;\n  events?: any[];\n  elkGraph?: any;\n  setElkGraph?: (graph: any) => void;\n  elkGraphDescription?: string;\n  agentInstruction?: string;\n  // For use with mutations\n  addNode?: (nodeName: string, parentId: string, graph: any, data?: { label?: string; icon?: string }) => any;\n  deleteNode?: (nodeId: string, graph: any) => any;\n  moveNode?: (nodeId: string, newParentId: string, graph: any) => any;\n  addEdge?: (edgeId: string, sourceId: string, targetId: string, graph: any) => any;\n  deleteEdge?: (edgeId: string, graph: any) => any;\n  groupNodes?: (nodeIds: string[], parentId: string, groupId: string, graph: any, style?: any) => any;\n  removeGroup?: (groupId: string, graph: any) => any;\n  batchUpdate?: (operations: any[], graph: any) => any;\n  process_user_requirements?: () => string;\n}",
    "start_line": 18,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseChatSessionProps",
    "component_id": "client.hooks.useChatSession.UseChatSessionProps"
  },
  "client.hooks.useChatSession.useChatSession": {
    "id": "client.hooks.useChatSession.useChatSession",
    "name": "useChatSession",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useChatSession.ts",
    "relative_path": "client/hooks/useChatSession.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.realtime.eventSelectors.functionCallEvents",
      "client.hooks.useChatSession.isValidTextContent",
      "client.types.chat.Message",
      "client.components.App.sendTextMessage",
      "client.hooks.useChatSession.UseChatSessionProps",
      "client.realtime.initSession.initSession",
      "client.realtime.handleFunctionCall.handleFunctionCall",
      "client.components.App.sendClientEvent",
      "client.components.graph.utils.elk.edgePoints.add",
      "scripts.test-vercel-preview.error",
      "client.realtime.eventSelectors.latestAssistantText",
      "client.realtime.types.ClientEvent"
    ],
    "source_code": "useChatSession = ({\n  isSessionActive,\n  sendTextMessage,\n  sendClientEvent,\n  events,\n  elkGraph,\n  setElkGraph,\n  elkGraphDescription,\n  agentInstruction,\n  addNode,\n  deleteNode,\n  moveNode,\n  addEdge,\n  deleteEdge,\n  groupNodes,\n  removeGroup,\n  batchUpdate,\n  process_user_requirements\n}: UseChatSessionProps) => {\n  // Use a Map as the single source of truth for messages\n  const messagesMap = useRef<Map<string, Message>>(new Map());\n  const processed = useRef<Set<string>>(new Set());\n  const initSent = useRef(false);\n  const lastSessionId = useRef<string | null>(null);\n  const [forceUpdate, setForceUpdate] = useState(0);\n\n  // Reset initialization state when session becomes inactive\n  useEffect(() => {\n    if (!isSessionActive) {\n      initSent.current = false;\n      lastSessionId.current = null;\n    }\n  }, [isSessionActive]);\n\n  // Derive messages array from Map\n  const messages = useMemo(() => \n    Array.from(messagesMap.current.values()),\n    [forceUpdate]\n  );\n\n  // Force update function to trigger re-render when messages change\n  const triggerUpdate = useCallback(() => {\n    setForceUpdate(prev => prev + 1);\n  }, []);\n\n  // Listen for custom chat events\n  useEffect(() => {\n    const handleAddChatMessage = (event: CustomEvent) => {\n      const { message } = event.detail;\n\n      \n      // Add message to the Map\n      messagesMap.current.set(message.id, message);\n      triggerUpdate();\n    };\n\n    // Add event listener for custom chat messages\n    document.addEventListener('addChatMessage', handleAddChatMessage as EventListener);\n\n    return () => {\n      document.removeEventListener('addChatMessage', handleAddChatMessage as EventListener);\n    };\n  }, [triggerUpdate]);\n\n  // Safe wrapper for sending client events\n  const safeSendClientEvent = useCallback((event: ClientEvent) => {\n    if (sendClientEvent) {\n      sendClientEvent(event);\n    }\n  }, [sendClientEvent]);\n\n  // Process events from the server\n  const processEvents = useCallback(() => {\n    if (!isSessionActive || !events || events.length === 0) return;\n\n    // Handle text messages from the assistant\n    const latestServerEvent = latestAssistantText(events);\n    \n    if (latestServerEvent) {\n      // Extract text from the event\n      const delta = latestServerEvent.delta as MessageDelta;\n      const content = delta.content[0];\n      \n      if (isValidTextContent(content)) {\n        const messageId = latestServerEvent.event_id;\n        \n        // Update or add message in the Map\n        messagesMap.current.set(messageId, {\n          id: messageId,\n          content: content.text!, // Non-null assertion since we know it's defined after type guard\n          sender: 'assistant'\n        });\n        triggerUpdate();\n      }\n    }\n\n    // Log function calls from the agent\n    const functionCalls = functionCallEvents(events);\n\n    if (functionCalls.length > 0) {\n      functionCalls.forEach(call => {\n        // each response.done.output entry has its own id\n        const id = call.id ?? JSON.stringify(call);      // fallback if no id field\n        if (processed.current.has(id)) return;      // ‚Üê already handled\n        processed.current.add(id);                  // mark as processed\n\n        const { name: functionName, arguments: functionArgsStr, result } = call;\n\n        // Parse function arguments if they're a string\n        let functionArgs;\n        try {\n          functionArgs = typeof functionArgsStr === 'string' ? JSON.parse(functionArgsStr) : functionArgsStr || {};\n        } catch (e) {\n          console.error(`‚ùå Failed to parse arguments for ${functionName}:`, e);\n          console.error(`‚ùå Raw function arguments string:`, functionArgsStr);\n          console.error(`‚ùå String length:`, typeof functionArgsStr === 'string' ? functionArgsStr.length : 'N/A');\n          \n          // Try to find the problematic part around position 508\n          if (typeof functionArgsStr === 'string' && functionArgsStr.length > 500) {\n            const start = Math.max(0, 500 - 50);\n            const end = Math.min(functionArgsStr.length, 520);\n            console.error(`‚ùå Problematic section (chars ${start}-${end}):`, functionArgsStr.substring(start, end));\n          }\n          \n          if (sendClientEvent) {\n            sendClientEvent({\n              type: \"conversation.item.create\",\n              item: {\n                type: \"function_call_output\",\n                call_id: call.call_id,\n                output: JSON.stringify({ \n                  error: \"Failed to parse function arguments\", \n                  details: e instanceof Error ? e.message : 'Unknown parse error',\n                  raw_args: typeof functionArgsStr === 'string' ? functionArgsStr.substring(0, 200) + '...' : functionArgsStr\n                })\n              }\n            });\n          }\n          return;\n        }\n\n        // Simplified console logging for function calls - just show function name\n        console.log(`üîß Function call: ${functionName}`);\n        \n        // Handle the function call\n        if (elkGraph && setElkGraph) {\n          handleFunctionCall(call, {\n            elkGraph,\n            setElkGraph,\n            mutations: {\n              addNode: addNode || (() => elkGraph),\n              deleteNode: deleteNode || (() => elkGraph),\n              moveNode: moveNode || (() => elkGraph),\n              addEdge: addEdge || (() => elkGraph),\n              deleteEdge: deleteEdge || (() => elkGraph),\n              groupNodes: groupNodes || (() => elkGraph),\n              removeGroup: removeGroup || (() => elkGraph),\n              batchUpdate: batchUpdate || (() => elkGraph),\n              process_user_requirements: process_user_requirements\n            },\n            safeSend: safeSendClientEvent\n          });\n        }\n      });\n    }\n  }, [isSessionActive, events, elkGraph, setElkGraph, addNode, deleteNode, moveNode, addEdge, deleteEdge, groupNodes, removeGroup, batchUpdate, process_user_requirements, safeSendClientEvent, triggerUpdate]);\n\n  // Initialize session with tool definitions\n  useEffect(() => {\n    if (!isSessionActive) {\n      // Reset both guards when session becomes inactive\n      initSent.current = false;\n      lastSessionId.current = null;\n      return;\n    }\n\n    // Look for the latest session.created\n    const created = events?.find(e => e.type === \"session.created\");\n    if (!created) {\n      // Waiting for session.created event\n      return;\n    }\n\n    // Skip if this is the same session we've already initialized\n    if (created.session.id === lastSessionId.current) {\n      console.log(\"‚ÑπÔ∏è Session already initialized:\", created.session.id);\n      return;\n    }\n\n    console.log(\"üöÄ Initializing new session:\", created.session.id);\n    const ok = initSession(events, safeSendClientEvent, elkGraphDescription || '');\n    \n    // Update both guards for this session\n    lastSessionId.current = created.session.id;\n    initSent.current = true;\n\n    if (ok) {\n      console.log(\"‚úÖ Session initialization complete\");\n    } else {\n      console.log(\"‚ÑπÔ∏è Session was already globally initialized ‚Äì skipping further logs\");\n    }\n  }, [isSessionActive, events, safeSendClientEvent, elkGraphDescription]);\n\n  // Handle chat submission\n  const handleChatSubmit = useCallback(async (message: string) => {\n    if (!message.trim()) return;\n\n    const messageId = crypto.randomUUID();\n    const newMessage: Message = {\n      id: messageId,\n      content: message,\n      sender: 'user'\n    };\n\n    // Add to Map\n    messagesMap.current.set(messageId, newMessage);\n    triggerUpdate();\n    \n    // If there's a session, send the message to the AI\n    if (isSessionActive && sendTextMessage) {\n      try {\n        await sendTextMessage(message);\n      } catch (error) {\n        console.error('Failed to send message:', error);\n        // Add error message to Map\n        messagesMap.current.set(`error-${messageId}`, {\n          id: `error-${messageId}`,\n          content: 'Failed to send message. Please try again.',\n          sender: \"assistant\"\n        });\n        triggerUpdate();\n      }\n    }\n  }, [isSessionActive, sendTextMessage, triggerUpdate]);\n\n  // Clear messages when session becomes inactive\n  useEffect(() => {\n    if (!isSessionActive) {\n      messagesMap.current.clear();\n      triggerUpdate();\n    }\n  }, [isSessionActive, triggerUpdate]);\n\n  return {\n    messages,\n    isSending: false,\n    messageSendStatus: 'idle',\n    handleChatSubmit,\n    processEvents,\n    safeSendClientEvent,\n    initSentRef: initSent,\n    processedCalls: processed\n  };\n}",
    "start_line": 39,
    "end_line": 292,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useChatSession",
    "component_id": "client.hooks.useChatSession.useChatSession"
  },
  "client.hooks.useConnectionRecovery.ConnectionRecoveryOptions": {
    "id": "client.hooks.useConnectionRecovery.ConnectionRecoveryOptions",
    "name": "ConnectionRecoveryOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useConnectionRecovery.ts",
    "relative_path": "client/hooks/useConnectionRecovery.ts",
    "depends_on": [],
    "source_code": "interface ConnectionRecoveryOptions {\n  maxRetries?: number;\n  retryDelay?: number;\n  exponentialBackoff?: boolean;\n  onRetry?: (attempt: number) => void;\n  onMaxRetriesReached?: () => void;\n}",
    "start_line": 3,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ConnectionRecoveryOptions",
    "component_id": "client.hooks.useConnectionRecovery.ConnectionRecoveryOptions"
  },
  "client.hooks.useConnectionRecovery.useConnectionRecovery": {
    "id": "client.hooks.useConnectionRecovery.useConnectionRecovery",
    "name": "useConnectionRecovery",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useConnectionRecovery.ts",
    "relative_path": "client/hooks/useConnectionRecovery.ts",
    "depends_on": [
      "client.hooks.useConnectionRecovery.ConnectionRecoveryOptions",
      "scripts.test-vercel-preview.error",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function useConnectionRecovery(\n  isSessionActive: boolean,\n  events: any[],\n  options: ConnectionRecoveryOptions = {}\n) {\n  const {\n    maxRetries = 3,\n    retryDelay = 2000,\n    exponentialBackoff = true,\n    onRetry,\n    onMaxRetriesReached\n  } = options;\n\n  const [retryCount, setRetryCount] = useState(0);\n  const [isRetrying, setIsRetrying] = useState(false);\n  const [lastError, setLastError] = useState<string | null>(null);\n  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Detect connection errors from events\n  const hasConnectionError = events?.some(event => \n    event.type === 'error' && (\n      event.error?.includes('Socket timeout') ||\n      event.error?.includes('Unknown error') ||\n      event.error?.includes('Connection closed')\n    )\n  );\n\n  // Reset retry count when session becomes active and working\n  useEffect(() => {\n    if (isSessionActive && !hasConnectionError) {\n      setRetryCount(0);\n      setIsRetrying(false);\n      setLastError(null);\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n        retryTimeoutRef.current = null;\n      }\n    }\n  }, [isSessionActive, hasConnectionError]);\n\n  // Handle automatic retry\n  const attemptRetry = useCallback(() => {\n    if (retryCount >= maxRetries) {\n      console.log(`‚ùå Max retries (${maxRetries}) reached. Please refresh the page.`);\n      setIsRetrying(false);\n      onMaxRetriesReached?.();\n      return;\n    }\n\n    const nextRetryCount = retryCount + 1;\n    setRetryCount(nextRetryCount);\n    setIsRetrying(true);\n\n    const delay = exponentialBackoff \n      ? retryDelay * Math.pow(2, nextRetryCount - 1)\n      : retryDelay;\n\n    console.log(`üîÑ Connection lost. Retrying in ${delay}ms... (${nextRetryCount}/${maxRetries})`);\n    \n    retryTimeoutRef.current = setTimeout(() => {\n      console.log(`üîÑ Attempting reconnection (${nextRetryCount}/${maxRetries})`);\n      onRetry?.(nextRetryCount);\n      \n      // Refresh the page to reconnect\n      window.location.reload();\n    }, delay);\n  }, [retryCount, maxRetries, retryDelay, exponentialBackoff, onRetry, onMaxRetriesReached]);\n\n  // Trigger retry when connection error is detected\n  useEffect(() => {\n    if (hasConnectionError && !isRetrying && retryCount < maxRetries) {\n      setLastError('Connection lost due to socket timeout');\n      attemptRetry();\n    }\n  }, [hasConnectionError, isRetrying, retryCount, maxRetries, attemptRetry]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (retryTimeoutRef.current) {\n        clearTimeout(retryTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    retryCount,\n    isRetrying,\n    lastError,\n    hasConnectionError,\n    maxRetries\n  };\n}",
    "start_line": 11,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "isSessionActive",
      "events",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useConnectionRecovery",
    "component_id": "client.hooks.useConnectionRecovery.useConnectionRecovery"
  },
  "client.hooks.useConnectorTool.UseConnectorToolProps": {
    "id": "client.hooks.useConnectorTool.UseConnectorToolProps",
    "name": "UseConnectorToolProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useConnectorTool.ts",
    "relative_path": "client/hooks/useConnectorTool.ts",
    "depends_on": [
      "client.hooks.useToolSelection.Tool"
    ],
    "source_code": "interface UseConnectorToolProps {\n  selectedTool: Tool;\n  reactFlowRef: React.RefObject<ReactFlowInstance>;\n  onConnect: (connection: Connection) => void;\n  setSelectedNodes: (nodes: any[]) => void;\n}",
    "start_line": 5,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseConnectorToolProps",
    "component_id": "client.hooks.useConnectorTool.UseConnectorToolProps"
  },
  "client.hooks.useConnectorTool.useConnectorTool": {
    "id": "client.hooks.useConnectorTool.useConnectorTool",
    "name": "useConnectorTool",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useConnectorTool.ts",
    "relative_path": "client/hooks/useConnectorTool.ts",
    "depends_on": [
      "client.hooks.useConnectorTool.UseConnectorToolProps",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "useConnectorTool = ({ \n  selectedTool, \n  reactFlowRef, \n  onConnect, \n  setSelectedNodes \n}: UseConnectorToolProps) => {\n  const [connectingFrom, setConnectingFrom] = useState<string | null>(null);\n  const [connectingFromHandle, setConnectingFromHandle] = useState<string | null>(null);\n  const [connectionMousePos, setConnectionMousePos] = useState<{ x: number; y: number } | null>(null);\n\n  // Clear connection state\n  const handleConnectEnd = useCallback(() => {\n    setConnectingFrom(null);\n    setConnectingFromHandle(null);\n    setConnectionMousePos(null);\n  }, []);\n\n  // Manual handler for clicking on connector dots to start connection with edge preview\n  const handleConnectorDotClick = useCallback((nodeId: string, handleId: string) => {\n    // CRITICAL: Immediately deselect all nodes when connector port is clicked\n    // This prevents ReactFlow from selecting the node when clicking on the port\n    if (reactFlowRef.current) {\n      reactFlowRef.current.setNodes((nds) => nds.map(node => ({ ...node, selected: false })));\n    }\n    setSelectedNodes([]);\n    \n    console.log(`[ConnectorTool] handleConnectorDotClick called:`, { nodeId, handleId, currentConnectingFrom: connectingFrom });\n    \n    // Check if handleId is a target handle (completing a connection)\n    if (handleId.includes('target') && connectingFrom && connectingFrom !== nodeId) {\n      // Complete the connection\n      console.log(`[ConnectorTool] Completing connection from ${connectingFrom} to ${nodeId}`, {\n        source: connectingFrom,\n        sourceHandle: connectingFromHandle,\n        target: nodeId,\n        targetHandle: handleId\n      });\n      \n      // Create the connection with proper handle IDs\n      const connection = { \n        source: connectingFrom, \n        sourceHandle: connectingFromHandle || undefined, \n        target: nodeId, \n        targetHandle: handleId || undefined\n      };\n      \n      console.log(`[ConnectorTool] Calling onConnect with:`, connection);\n      console.log(`[ConnectorTool] Connection details:`, {\n        source: connection.source,\n        sourceHandle: connection.sourceHandle,\n        target: connection.target,\n        targetHandle: connection.targetHandle,\n        sourceHandleType: connection.sourceHandle?.includes('connector') ? 'connector' : 'regular',\n        targetHandleType: connection.targetHandle?.includes('connector') ? 'connector' : 'regular'\n      });\n      \n      // Call onConnect - this will trigger ReactFlow's onConnect handler\n      // which then calls our graph onConnect handler\n      onConnect(connection);\n      \n      // Clear connection state\n      setConnectingFrom(null);\n      setConnectingFromHandle(null);\n      setConnectionMousePos(null);\n      return;\n    }\n    \n    // Otherwise, start a new connection\n    console.log(`[ConnectorTool] Starting new connection from ${nodeId}, handle ${handleId}`);\n    setConnectingFrom(nodeId);\n    setConnectingFromHandle(handleId);\n    \n    // Track mouse movement to show edge preview (always show when connecting)\n    const handleMouseMove = (e: MouseEvent) => {\n      if (reactFlowRef.current) {\n        const rf = reactFlowRef.current;\n        const flowPos = (rf as any).screenToFlowPosition\n          ? (rf as any).screenToFlowPosition({ x: e.clientX, y: e.clientY })\n          : rf.project({ x: e.clientX, y: e.clientY });\n        \n        // Always show preview line while moving\n        setConnectionMousePos(flowPos);\n      }\n    };\n    \n    const handleMouseUp = (e: MouseEvent) => {\n      // Remove mouse tracking\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      \n      const currentConnectingFrom = connectingFrom;\n      const currentConnectingFromHandle = connectingFromHandle;\n      \n      if (!currentConnectingFrom) {\n        setConnectionMousePos(null);\n        return;\n      }\n      \n      // Check if clicked on a target handle\n      const target = e.target as HTMLElement;\n      const targetHandle = target.closest('.react-flow__handle') as HTMLElement;\n      \n      if (targetHandle) {\n        const handleType = targetHandle.getAttribute('data-handletype');\n        const handleId = targetHandle.getAttribute('data-id') || targetHandle.id;\n        \n        // Find the node that contains this handle\n        const nodeElement = targetHandle.closest('.react-flow__node') as HTMLElement;\n        const targetNodeId = nodeElement?.getAttribute('data-id') || nodeElement?.id;\n        \n        // Check if it's a target handle (or connector target handle)\n        if (targetNodeId && handleId && \n            (handleType === 'target' || handleId.includes('target')) && \n            targetNodeId !== currentConnectingFrom) {\n          // Create connection\n          onConnect({ source: currentConnectingFrom, sourceHandle: currentConnectingFromHandle, target: targetNodeId, targetHandle: handleId });\n          // Clear connection state after successful connection\n          setConnectingFrom(null);\n          setConnectingFromHandle(null);\n          setConnectionMousePos(null);\n          return;\n        }\n      }\n      \n      // Also check if clicking on another connector dot (to connect to it)\n      const clickedConnectorDot = target.closest('[data-connector-dot]') as HTMLElement;\n      if (clickedConnectorDot) {\n        const targetNodeId = clickedConnectorDot.getAttribute('data-node-id');\n        const targetHandleId = clickedConnectorDot.getAttribute('data-handle-id');\n        \n        if (targetNodeId && targetHandleId && targetNodeId !== currentConnectingFrom) {\n          // Create connection to the clicked connector dot\n          onConnect({ source: currentConnectingFrom, sourceHandle: currentConnectingFromHandle, target: targetNodeId, targetHandle: targetHandleId });\n          setConnectingFrom(null);\n          setConnectingFromHandle(null);\n          setConnectionMousePos(null);\n          return;\n        }\n      }\n      \n      // If clicked anywhere else (empty space, node, etc.), cancel connection (deselect)\n      console.log(`[ConnectorTool] Clicked outside port area, cancelling connection (deselection)`);\n      setConnectingFrom(null);\n      setConnectingFromHandle(null);\n      setConnectionMousePos(null);\n    };\n    \n    const handleClick = (e: MouseEvent) => {\n      // Check if this is a click on a connector port (source or target)\n      const target = e.target as HTMLElement;\n      const isConnectorPortClick = target.closest('[data-connector-dot]') || \n                                   target.closest('[style*=\"rgba(0, 255, 0\"]') ||\n                                   target.closest('.react-flow__handle[id*=\"connector\"]');\n      \n      // CRITICAL FIX: Allow toolbar clicks to pass through\n      const isToolbarClick = target.closest('.absolute.bottom-8.left-1\\\\/2.-translate-x-1\\\\/2.z-\\\\[8000\\\\]') ||\n                             target.closest('[aria-label=\"Select (V)\"]') ||\n                             target.closest('[aria-label=\"Add box (R)\"]') ||\n                             target.closest('[aria-label=\"Add connector (C)\"]') ||\n                             target.closest('[aria-label=\"Create group (G)\"]');\n      \n      // If clicking on toolbar, let the toolbar handle it - don't intercept\n      if (isToolbarClick) {\n        console.log(`[ConnectorTool] Toolbar click detected - allowing it to pass through`);\n        // Clean up listeners but don't prevent the toolbar click\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n        document.removeEventListener('click', handleClick);\n        return; // Let toolbar handle the click\n      }\n      \n      // If clicking anywhere EXCEPT a connector port or toolbar, cancel the connection (deselect)\n      if (!isConnectorPortClick) {\n        console.log(`[ConnectorTool] Click outside connector port detected, cancelling connection (deselection)`);\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n        document.removeEventListener('click', handleClick);\n        setConnectingFrom(null);\n        setConnectingFromHandle(null);\n        setConnectionMousePos(null);\n      } else {\n        // Click was on a connector port - let the port click handler deal with it\n        // Just clean up the event listeners\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n        document.removeEventListener('click', handleClick);\n      }\n    };\n    \n    // Start tracking mouse\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp, { once: true });\n    // Listen for clicks to detect deselection (clicking anywhere outside ports)\n    document.addEventListener('click', handleClick, { once: true, capture: true });\n  }, [connectingFrom, connectingFromHandle, onConnect, handleConnectEnd, reactFlowRef, setSelectedNodes]);\n\n  return {\n    connectingFrom,\n    connectingFromHandle,\n    connectionMousePos,\n    handleConnectorDotClick,\n    handleConnectEnd\n  };\n}",
    "start_line": 12,
    "end_line": 215,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useConnectorTool",
    "component_id": "client.hooks.useConnectorTool.useConnectorTool"
  },
  "client.hooks.useElkToReactflowGraphConverter.useElkToReactflowGraphConverter": {
    "id": "client.hooks.useElkToReactflowGraphConverter.useElkToReactflowGraphConverter",
    "name": "useElkToReactflowGraphConverter",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useElkToReactflowGraphConverter.ts",
    "relative_path": "client/hooks/useElkToReactflowGraphConverter.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.types.index.RawGraph",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.graph_helper_functions.groupNodes",
      "client.utils.graph_helper_functions.addNode",
      "client.components.graph.mutations.edgeIdExists",
      "client.core.viewstate.modeHelpers.migrateModeDomainToViewState",
      "client.components.graph.utils.elk.ids.ensureIds",
      "client.renderer.ReactFlowAdapter.toReactFlowWithViewState",
      "client.components.graph.utils.elk.structuralHash.structuralHash",
      "client.components.graph.utils.elk.edgePoints.add",
      "scripts.test-vercel-preview.error",
      "client.utils.graph_helper_functions.addEdge",
      "client.core.viewstate.modeHelpers.syncViewStateLayoutWithGraph"
    ],
    "source_code": "function useElkToReactflowGraphConverter(initialRaw: RawGraph, selectedTool: string = 'arrow') {\n  /* 1) raw‚Äêgraph state */\n  const [rawGraph, setRawGraphState] = useState<RawGraph>(initialRaw);\n  const rawGraphRef = useRef<RawGraph>(initialRaw);\n  \n  /* 2) layouted‚Äêgraph state */\n  const [layoutGraph, setLayoutGraph] = useState<LayoutGraph|null>(null);\n  \n  /* 3) layout error state */\n  const [layoutError, setLayoutError] = useState<string | null>(null);\n  \n  /* refs that NEVER cause re-render */\n  const hashRef = useRef<string>(structuralHash(initialRaw));\n  const abortRef = useRef<AbortController | null>(null);\n  const lastMutationRef = useRef<{ source: 'ai' | 'user'; scopeId: string; timestamp: number } | null>(null);\n  const previousHashRef = useRef<string>(structuralHash(initialRaw));\n  \n  const shouldSkipFitViewRef = useRef<boolean>(false);\n  \n  /* react-flow state */\n  const [nodes, setNodes] = useState<Node[]>([]);\n  const [edges, setEdges] = useState<Edge[]>([]);\n  const [layoutVersion, incLayoutVersion] = useState(0);\n  \n  /* 4) view-state (authoritative geometry, prep for future phases) */\n  const viewStateRef = useRef<ViewState>({\n    node: {},\n    group: {},\n    edge: {},\n  });\n  const lastElkReasonRef = useRef<string | null>(null);\n  const cloneViewState = (value: any) => {\n    if (!value) return value;\n    try {\n      return JSON.parse(JSON.stringify(value));\n    } catch (error) {\n      console.warn('‚ö†Ô∏è [useElkToReactflow] Failed to clone viewState snapshot:', error);\n      return value;\n    }\n  };\n  \n  /* -------------------------------------------------- */\n  /* üîπ 3. mutate helper                                 */\n  /* -------------------------------------------------- */\n  type MutFn = (...a: any[]) => any;\n  type MutateOptions = { source?: 'ai' | 'user'; scopeId?: string };\n  \n  const mutate = useCallback((...args: any[]) => {\n    let fn: MutFn;\n    let rest: any[];\n    let options: MutateOptions = { source: 'user' };\n    \n    if (typeof args[0] === 'function') {\n      fn = args[0] as MutFn;\n      rest = args.slice(1);\n    } else {\n      options = { ...options, ...args[0] };\n      fn = args[1] as MutFn;\n      rest = args.slice(2);\n    }\n    \n    // Read from ref, not React state\n    const prev = rawGraphRef.current;\n    if (!prev) {\n      throw new Error(`Cannot mutate graph: graph state is null or undefined`);\n    }\n    \n    const next = fn(...rest, prev) as RawGraph;\n    \n    // Update ref immediately\n    rawGraphRef.current = next;\n    hashRef.current = structuralHash(next);\n    \n    // Only update React state for AI mutations (triggers ELK)\n    if (options.source === 'ai') {\n      lastMutationRef.current = {\n        source: 'ai',\n        scopeId: options.scopeId || 'root',\n        timestamp: Date.now()\n      };\n      setRawGraphState(next);\n    }\n  }, []);\n  \n  /* -------------------------------------------------- */\n  /* üîπ 4.  mutation wrappers for mutate pattern       */\n  /* -------------------------------------------------- */\n  // The mutate function appends the current graph as the LAST parameter,\n  // but mutations expect graph in different positions. Create wrappers:\n  \n  // addNode expects: (nodeName, parentId, graph, data?)\n  // mutate calls: (nodeName, parentId, data?, graph)\n  const addNodeWrapper = (nodeName: string, parentId: string, data: any, graph: RawGraph) => {\n    return addNode(nodeName, parentId, graph, data);\n  };\n  \n  // groupNodes expects: (nodeIds, parentId, groupId, graph, style?)\n  // mutate calls: (nodeIds, parentId, groupId, style?, graph)\n  const groupNodesWrapper = (nodeIds: any[], parentId: string, groupId: string, style: any, graph: RawGraph) => {\n    // Filter out null/undefined/invalid node IDs\n    const validNodeIds = nodeIds.filter((id): id is string => {\n      if (!id || typeof id !== 'string') {\n        console.warn('[groupNodesWrapper] Filtering out invalid node ID:', id);\n        return false;\n      }\n      return true;\n    });\n    \n    if (validNodeIds.length === 0) {\n      throw new Error('Cannot create group: no valid node IDs provided');\n    }\n    \n    // Ensure groupId is valid\n    const validGroupId = groupId || `group-${Date.now()}`;\n    \n    return groupNodes(validNodeIds, parentId, validGroupId, graph, style);\n  };\n  \n  // deleteNode expects: (nodeId, graph)\n  // mutate calls: (nodeId, graph) - already correct\n  \n  // addEdge expects: (edgeId, sourceId, targetId, labelOrGraph?, sourceHandle?, targetHandle?, graph?)\n  // mutate calls: (edgeId, sourceId, targetId, label?, sourceHandle?, targetHandle?, graph)\n  // Create a wrapper that checks for duplicate edge IDs before calling addEdge\nconst addEdgeWrapper = (edgeId: string, sourceId: string, targetId: string, label: any, sourceHandle: any, targetHandle: any, graph: RawGraph) => {\n    if (edgeIdExists(graph, edgeId)) {\n      return graph;\n    }\n    return addEdge(edgeId, sourceId, targetId, label, sourceHandle, targetHandle, graph);\n  };\n  \n  /* -------------------------------------------------- */\n  /* üîπ 5.  exposed handlers                            */\n  /* -------------------------------------------------- */\n  const handlers = useMemo(() => ({\n    // Backward compatible variants (no options) - using wrappers where needed\n    handleAddNode     : (...a: any[]) => mutate(addNodeWrapper, ...a),\n    handleDeleteNode  : (...a: any[]) => mutate(deleteNode,    ...a),\n    handleMoveNode    : (...a: any[]) => mutate(moveNode,      ...a),\n    handleAddEdge     : (...a: any[]) => mutate(addEdgeWrapper, ...a), // Use wrapper to prevent duplicates\n    handleDeleteEdge  : (...a: any[]) => mutate(deleteEdge,    ...a),\n    handleGroupNodes  : (...a: any[]) => mutate(groupNodesWrapper,    ...a),\n    handleRemoveGroup : (...a: any[]) => mutate(removeGroup,   ...a),\n    handleBatchUpdate : (...a: any[]) => mutate(batchUpdate,   ...a),\n    // New option-aware variants (ignored for now)\n    addNodeWith       : (opts: MutateOptions, ...a: any[]) => mutate(opts, addNodeWrapper, ...a),\n    deleteNodeWith    : (opts: MutateOptions, ...a: any[]) => mutate(opts, deleteNode,     ...a),\n    moveNodeWith      : (opts: MutateOptions, ...a: any[]) => mutate(opts, moveNode,       ...a),\n    addEdgeWith       : (opts: MutateOptions, ...a: any[]) => mutate(opts, addEdge,        ...a),\n    deleteEdgeWith    : (opts: MutateOptions, ...a: any[]) => mutate(opts, deleteEdge,     ...a),\n    groupNodesWith    : (opts: MutateOptions, ...a: any[]) => mutate(opts, groupNodes,     ...a),\n    removeGroupWith   : (opts: MutateOptions, ...a: any[]) => mutate(opts, removeGroup,    ...a),\n    batchUpdateWith   : (opts: MutateOptions, ...a: any[]) => mutate(opts, batchUpdate,    ...a),\n  }), [mutate]);\n  \n  const handleAddNodeLegacy = useCallback(\n    (groupId: string) => {\n      const newNodeId = `new-node-${Date.now()}`;\n      const newNode: Node = {\n        id: newNodeId,\n        data: { label: 'New Node', isEditing: true },\n        position: { x: 20, y: 20 },\n        type: 'custom',\n        parentNode: groupId,\n        extent: 'parent' as const,\n      };\n      setNodes((nds) => [...nds, newNode]);\n    },\n    [setNodes]\n  );\n\n  const handleLabelChange = useCallback(\n    (id: string, label: string) => {\n      setNodes((nds) =>\n        nds.map((node) => {\n          if (node.id === id) {\n            node.data = { ...node.data, label, isEditing: false };\n          }\n          return node;\n        })\n      );\n    },\n    [setNodes]\n  );\n  \n  /* -------------------------------------------------- */\n  /* üîπ 2b. raw graph setter (AI mode only)              */\n  /* -------------------------------------------------- */\n  const setRawGraph = useCallback((\n    next: RawGraph | ((prev: RawGraph) => RawGraph),\n    source?: 'ai'\n  ) => {\n    let resolved = typeof next === 'function'\n      ? (next as (p: RawGraph) => RawGraph)(rawGraphRef.current)\n      : next;\n\n    // For AI graphs, remove viewState so ELK runs\n    if (resolved && typeof resolved === 'object' && 'viewState' in resolved) {\n      delete (resolved as any).viewState;\n    }\n\n    rawGraphRef.current = resolved;\n    hashRef.current = structuralHash(resolved);\n    \n    lastMutationRef.current = {\n      source: 'ai',\n      scopeId: 'external-setRawGraph',\n      timestamp: Date.now(),\n    };\n    \n    setRawGraphState(resolved);\n  }, []);\n\n  /* -------------------------------------------------- */\n  /* üîπ 4.5 ELK-only trigger (no orchestration)        */\n  /* -------------------------------------------------- */\n  const triggerRender = useCallback(() => {\n    incLayoutVersion(v => v + 1);\n  }, []);\n  \n  // Keep rawGraphRef in sync\n  useEffect(() => {\n    rawGraphRef.current = rawGraph;\n  }, [rawGraph]);\n\n  /* -------------------------------------------------- */\n  /* üîπ 5. layout side-effect                           */\n  /* -------------------------------------------------- */\n  useEffect(() => {\n    const mutation = lastMutationRef.current;\n    \n    if (!rawGraph) return;\n    if (mutation?.source !== 'ai') return;\n    \n    const currentHash = hashRef.current;\n    previousHashRef.current = currentHash;\n    \n    /* cancel any in-flight run */\n    abortRef.current?.abort();\n    const ac = new AbortController();\n    abortRef.current = ac;\n    \n    const hashAtStart = hashRef.current;\n    \n    (async () => {\n      try {\n        \n        // Clear any previous layout errors\n        setLayoutError(null);\n        \n        // Validate graph structure before processing\n        const validateGraph = (node: any, visited = new Set()): boolean => {\n          if (!node || typeof node !== 'object') return false;\n          if (visited.has(node)) return false; // Prevent cycles\n          visited.add(node);\n          \n          if (!node.id || typeof node.id !== 'string') {\n            console.error(\"[ELK] Invalid node - missing or invalid ID:\", node);\n            return false;\n          }\n          \n          // Validate children\n          if (node.children) {\n            if (!Array.isArray(node.children)) {\n              console.error(\"[ELK] Invalid node - children is not an array:\", node);\n              return false;\n            }\n            for (const child of node.children) {\n              if (!validateGraph(child, visited)) return false;\n            }\n          }\n          \n          // Validate edges\n          if (node.edges) {\n            if (!Array.isArray(node.edges)) {\n              console.error(\"[ELK] Invalid node - edges is not an array:\", node);\n              return false;\n            }\n            for (const edge of node.edges) {\n              if (!edge.id || !edge.sources || !edge.targets) {\n                console.error(\"[ELK] Invalid edge:\", edge);\n                return false;\n              }\n            }\n          }\n          \n          return true;\n        };\n        \n        if (!validateGraph(rawGraph)) {\n          throw new Error(\"Graph validation failed - invalid structure detected\");\n        }\n        \n        // 1) Extract mode map from rawGraph BEFORE ELK (preserve mode field)\n        // Phase 4: Migrate and sync ViewState.layout with graph structure\n        if (!viewStateRef.current.layout || Object.keys(viewStateRef.current.layout).length === 0) {\n          viewStateRef.current = migrateModeDomainToViewState(rawGraph, viewStateRef.current);\n        } else {\n          // Sync to ensure all groups have modes (for newly created groups)\n          viewStateRef.current = syncViewStateLayoutWithGraph(rawGraph, viewStateRef.current);\n        }\n        \n        // 2) inject IDs + elkOptions onto a clone of rawGraph\n        const prepared = ensureIds(structuredClone(rawGraph));\n        \n        // 3) run ELK (mode no longer in ELK input/output - stays in ViewState)\n        const layout = await elk.layout(prepared);\n        \n        // Critical: Check if ELK returned zero positions - this indicates a layout failure\n        const zeroPosChildren = (layout.children || []).filter((c: any) => (c.x === 0 && c.y === 0));\n        if (zeroPosChildren.length > 0 && zeroPosChildren.length === (layout.children || []).length) {\n          // All nodes at 0,0 - ELK layout failed\n          throw new Error(`ELK layout failed: all ${zeroPosChildren.length} nodes positioned at (0,0). Graph structure may be invalid.`);\n        }\n        \n        /* stale result? ‚Äì ignore */\n        if (hashAtStart !== hashRef.current) return;\n        \n        // 3) store for SVG & RF conversion\n        setLayoutGraph(layout as LayoutGraph);\n        \n        // 4) Ensure ViewState exists - initialize from ELK output ONCE if empty\n        const currentViewState = viewStateRef.current;\n        const hasViewStateGeometry = \n          (Object.keys(currentViewState?.node || {}).length > 0) ||\n          (Object.keys(currentViewState?.group || {}).length > 0);\n        \n        if (!hasViewStateGeometry) {\n          // Initialize ViewState from ELK output ONCE\n          // This is the only time we populate ViewState from ELK\n          const nextNodeState: Record<string, { x: number; y: number; w: number; h: number }> = {};\n          const nextGroupState: Record<string, { x: number; y: number; w: number; h: number }> = {};\n          \n          // Helper to recursively extract geometry from ELK layout\n          const extractGeometry = (elkNode: any, parentX = 0, parentY = 0) => {\n            // Detect groups: has NON-EMPTY children OR has isGroup flag\n            // Note: Empty children array means leaf node, not a group\n            const hasRealChildren = Array.isArray(elkNode.children) && elkNode.children.length > 0;\n            const hasRealEdges = Array.isArray(elkNode.edges) && elkNode.edges.length > 0;\n            const isGroup = \n              elkNode.data?.isGroup === true || \n              hasRealChildren ||  // Groups have children with content\n              hasRealEdges;       // Groups have edges to contain\n            \n            // PROBLEM 2 FIX: ELK returns RELATIVE positions, must add parent absolute to get world absolute\n            const elkRelativeX = elkNode.x ?? 0;\n            const elkRelativeY = elkNode.y ?? 0;\n            const absoluteX = elkRelativeX + parentX;  // ‚úÖ FIXED: ELK relative + parent absolute = world absolute\n            const absoluteY = elkRelativeY + parentY;  // ‚úÖ FIXED: ELK relative + parent absolute = world absolute\n            \n            const width = elkNode.width ?? (isGroup ? NON_ROOT_DEFAULT_OPTIONS.width * 3 : NON_ROOT_DEFAULT_OPTIONS.width);\n            const height = elkNode.height ?? (isGroup ? 96 * 3 : 96);\n            \n            const geom = { \n              x: absoluteX, \n              y: absoluteY, \n              w: width, \n              h: height \n            };\n            \n            // PROBLEM 2 DEBUGGING: Log ALL groups being written (including scope root children)\n            const isNested = parentX !== 0 || parentY !== 0;\n            if (isGroup) {\n              console.log('[üéØCOORD] ELK-CONVERTER - WRITING group to ViewState:', {\n                nodeId: elkNode.id,\n                isScopeRootChild: !isNested,\n                isNested,\n                elkRelative: `${elkRelativeX},${elkRelativeY}`,\n                parentAbsolute: `${parentX},${parentY}`,\n                calculatedAbsolute: `${absoluteX},${absoluteY}`,\n                shouldBeAbsolute: isNested ? `${elkRelativeX + parentX},${elkRelativeY + parentY}` : `${elkRelativeX},${elkRelativeY}`,\n                problem2_detected: isNested && (Math.abs(absoluteX - (elkRelativeX + parentX)) > 1 || Math.abs(absoluteY - (elkRelativeY + parentY)) > 1)\n                  ? '‚ö†Ô∏è PROBLEM 2: ELK relative not added to parent absolute!'\n                  : 'OK',\n                writingToViewState: `${absoluteX},${absoluteY}`,\n              });\n            }\n            \n            if (isGroup) {\n              nextGroupState[elkNode.id] = geom;\n            } else {\n              nextNodeState[elkNode.id] = geom;\n            }\n            \n            // Recursively process children - pass this node's absolute position as parent\n            // Now that absoluteX/Y are correctly calculated, children will use correct parent absolute\n            if (elkNode.children) {\n              elkNode.children.forEach((child: any) => {\n                extractGeometry(child, absoluteX, absoluteY);\n              });\n            }\n          };\n          \n          // Extract geometry from ELK layout\n          if (layout.children) {\n            layout.children.forEach((child: any) => {\n              extractGeometry(child);\n            });\n          }\n          \n          viewStateRef.current = { \n            node: nextNodeState, \n            group: nextGroupState, \n            edge: {} \n          };\n          \n        }\n        \n        // 5) Convert to ReactFlow using adapter (reads from ViewState, not ELK)\n        const dimensions = {\n          width: NON_ROOT_DEFAULT_OPTIONS.width,\n          height: 96,\n          groupWidth: NON_ROOT_DEFAULT_OPTIONS.width * 3,\n          groupHeight: 96 * 3,\n          padding: 10\n        };\n        \n        const { nodes: rfNodes, edges: rfEdges } = toReactFlowWithViewState(\n          layout,\n          dimensions,\n          viewStateRef.current,\n          { strictGeometry: true }\n        );\n        \n        // Critical: Check if ReactFlow nodes have zero positions after conversion\n        const zeroPosNodes = rfNodes.filter(n => n.position.x === 0 && n.position.y === 0);\n        if (zeroPosNodes.length > 0 && zeroPosNodes.length === rfNodes.length) {\n          // All nodes at 0,0 - conversion failed\n          throw new Error(`Position conversion failed: all ${zeroPosNodes.length} ReactFlow nodes positioned at (0,0). ELK layout may have failed.`);\n        }\n\n\n        setNodes(rfNodes);\n        setEdges(rfEdges);\n        \n        // ViewState is now the source of truth - no backwards population needed\n        incLayoutVersion(v => v + 1);\n      } catch (e: any) {\n        if (e.name !== \"AbortError\") {\n          console.error(\"[ELK] layout failed\", e);\n          console.error(\"[ELK] Raw graph that caused failure:\", JSON.stringify(rawGraph, null, 2));\n          \n          // Set the error state so it can be accessed by components\n          setLayoutError(e.message || e.toString());\n          \n          // NO FALLBACK - Let it fail loudly so we can fix the actual issue\n          throw new Error(`ELK layout failed: ${e.message}. Fix the graph structure instead of using fallbacks.`);\n        }\n      }\n    })();\n    \n    return () => ac.abort();\n  }, [rawGraph]); // Only depend on rawGraph, not selectedTool - tool changes shouldn't trigger graph processing\n  \n  /* -------------------------------------------------- */\n  /* üîπ 6. react-flow helpers                           */\n  /* -------------------------------------------------- */\n  const onNodesChange = useCallback(\n    (changes: NodeChange[]) => {\n      const GRID_SIZE = 16;\n      const snap = (v: number) => Math.round(v / GRID_SIZE) * GRID_SIZE;\n      const snapPos = (p: { x: number; y: number }) => ({ x: snap(p.x), y: snap(p.y) });\n\n      // Snap position changes to grid\n      const snappedChanges = changes.map((ch) => {\n        if (ch.type === 'position' && (ch as any).position) {\n          const pos = (ch as any).position as { x: number; y: number };\n          const snapped = snapPos(pos);\n          return { ...ch, position: snapped } as NodeChange;\n        }\n        return ch;\n      });\n\n      setNodes((nodesState) => applyNodeChanges(snappedChanges, nodesState));\n    },\n    []\n  );\n  \n  const onEdgesChange = useCallback(\n    (c: EdgeChange[]) => setEdges(e => applyEdgeChanges(c, e)), []);\n  \n  // Track pending connections to prevent duplicates\n  const pendingConnectionsRef = useRef<Set<string>>(new Set());\n  // Track pending edge IDs to prevent duplicate edge creation\n  const pendingEdgeIdsRef = useRef<Set<string>>(new Set());\n\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      (window as any).__elkState = {\n        rawGraph,\n        layoutGraph,\n        nodes,\n        edges,\n        viewStateRef,\n      };\n    }\n  }, [rawGraph, layoutGraph, nodes, edges]);\n  \n  const onConnect: OnConnect = useCallback(({ source, target, sourceHandle, targetHandle }: Connection) => {\n    if (!source || !target) {\n      return;\n    }\n\n    const connectionKey = `${source}:${sourceHandle || ''}->${target}:${targetHandle || ''}`;\n    if (pendingConnectionsRef.current.has(connectionKey)) {\n      return;\n    }\n\n    pendingConnectionsRef.current.add(connectionKey);\n\n    const counter = Date.now();\n    const random = Math.random().toString(36).slice(2, 11);\n    const id = `edge-${counter}-${random}`;\n\n    if (pendingEdgeIdsRef.current.has(id)) {\n      pendingConnectionsRef.current.delete(connectionKey);\n      return;\n    }\n\n    pendingEdgeIdsRef.current.add(id);\n\n    try {\n      handlers.handleAddEdge(id, source, target, undefined, sourceHandle || undefined, targetHandle || undefined);\n    } catch (error) {\n      console.error('‚ùå [onConnect] Failed to create edge:', error);\n      pendingConnectionsRef.current.delete(connectionKey);\n      pendingEdgeIdsRef.current.delete(id);\n      throw error;\n    }\n\n    setTimeout(() => {\n      pendingConnectionsRef.current.delete(connectionKey);\n      pendingEdgeIdsRef.current.delete(id);\n    }, 100);\n  }, [handlers]);\n  \n  /* -------------------------------------------------- */\n  /* üîπ 7. public API                                   */\n  /* -------------------------------------------------- */\n  return {\n    rawGraph, layoutGraph, layoutError, nodes, edges, layoutVersion,\n    setRawGraph, setNodes, setEdges,\n    viewStateRef, rawGraphRef,\n    shouldSkipFitViewRef,  // Expose ref so InteractiveCanvas can check if fitView should be skipped\n    ...handlers,\n    onNodesChange, onEdgesChange, onConnect,\n    handleAddNodeLegacy: handleAddNodeLegacy,\n    handleLabelChange,\n  } as const;\n}",
    "start_line": 57,
    "end_line": 606,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "initialRaw",
      "selectedTool"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useElkToReactflowGraphConverter",
    "component_id": "client.hooks.useElkToReactflowGraphConverter.useElkToReactflowGraphConverter"
  },
  "client.hooks.useKeyboardShortcuts.UseKeyboardShortcutsProps": {
    "id": "client.hooks.useKeyboardShortcuts.UseKeyboardShortcutsProps",
    "name": "UseKeyboardShortcutsProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useKeyboardShortcuts.ts",
    "relative_path": "client/hooks/useKeyboardShortcuts.ts",
    "depends_on": [],
    "source_code": "interface UseKeyboardShortcutsProps {\n  selectedNodes: Node[];\n  selectedEdges: Edge[];\n  rawGraph: any;\n  setRawGraph: (graph: any) => void;\n  selectedTool?: 'select' | 'box' | 'connector' | 'group';\n  handleGroupNodes?: (nodeIds: string[], parentId: string, groupId: string, style?: any, groupIconName?: string) => void;\n  setSelectedNodes?: (nodes: Node[]) => void;\n  setSelectedTool?: (tool: 'select' | 'box' | 'connector' | 'group') => void;\n}",
    "start_line": 4,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseKeyboardShortcutsProps",
    "component_id": "client.hooks.useKeyboardShortcuts.UseKeyboardShortcutsProps"
  },
  "client.hooks.useKeyboardShortcuts.useKeyboardShortcuts": {
    "id": "client.hooks.useKeyboardShortcuts.useKeyboardShortcuts",
    "name": "useKeyboardShortcuts",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useKeyboardShortcuts.ts",
    "relative_path": "client/hooks/useKeyboardShortcuts.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.hooks.useKeyboardShortcuts.UseKeyboardShortcutsProps"
    ],
    "source_code": "useKeyboardShortcuts = ({\n  selectedNodes,\n  selectedEdges,\n  rawGraph,\n  setRawGraph,\n  selectedTool,\n  handleGroupNodes,\n  setSelectedNodes,\n  setSelectedTool\n}: UseKeyboardShortcutsProps) => {\n\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    // Handle Enter key for group creation when group tool is active\n    if (event.key === 'Enter' && selectedTool === 'group' && selectedNodes.length >= 2 && handleGroupNodes) {\n      event.preventDefault();\n      const nodeIds = selectedNodes.map(node => node.id);\n      const groupId = `group-${Date.now()}`;\n      const parentId = 'root'; // Default to root\n      \n      try {\n        handleGroupNodes(nodeIds, parentId, groupId, undefined);\n        // Clear selection after grouping\n        if (setSelectedNodes) {\n          setSelectedNodes([]);\n        }\n        // Switch back to select tool\n        if (setSelectedTool) {\n          setSelectedTool('select');\n        }\n      } catch (error) {\n        console.error('Failed to create group:', error);\n      }\n      return;\n    }\n    \n    // Handle Delete/Backspace for selected nodes and edges\n    if (event.key === 'Delete' || event.key === 'Backspace') {\n      if (selectedNodes.length > 0 || selectedEdges.length > 0) {\n        event.preventDefault();\n        // Create a deep copy of the graph (like DevPanel does)\n        let updatedGraph = JSON.parse(JSON.stringify(rawGraph));\n        \n        // Remove selected nodes\n        if (selectedNodes.length > 0) {\n          console.log('üóëÔ∏è [Keyboard] Deleting nodes:', selectedNodes.map(n => n.id));\n          \n          const deleteNodeRecursively = (node: any, nodeIdToDelete: string): any => {\n            if (!node.children) return node;\n            \n            return {\n              ...node,\n              children: node.children\n                .filter((child: any) => child.id !== nodeIdToDelete)\n                .map((child: any) => deleteNodeRecursively(child, nodeIdToDelete))\n            };\n          };\n          \n          selectedNodes.forEach(selectedNode => {\n            updatedGraph = deleteNodeRecursively(updatedGraph, selectedNode.id);\n          });\n        }\n        \n        // Remove selected edges\n        if (selectedEdges.length > 0) {\n          console.log('üóëÔ∏è [Keyboard] Deleting edges:', selectedEdges.map(e => e.id));\n          \n          const deleteEdgeRecursively = (node: any, edgeIdToDelete: string): any => {\n            const updatedNode = { ...node };\n            \n            if (updatedNode.edges) {\n              updatedNode.edges = updatedNode.edges.filter((edge: any) => edge.id !== edgeIdToDelete);\n            }\n            \n            if (updatedNode.children) {\n              updatedNode.children = updatedNode.children.map((child: any) => \n                deleteEdgeRecursively(child, edgeIdToDelete)\n              );\n            }\n            \n            return updatedNode;\n          };\n          \n          selectedEdges.forEach(selectedEdge => {\n            updatedGraph = deleteEdgeRecursively(updatedGraph, selectedEdge.id);\n          });\n        }\n        \n        // Update the graph\n        setRawGraph(updatedGraph);\n        console.log('‚úÖ [Keyboard] Graph updated after deletion');\n      }\n    }\n  }, [selectedNodes, selectedEdges, rawGraph, setRawGraph]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown);\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n\n  return null; // This hook doesn't render anything\n}",
    "start_line": 15,
    "end_line": 117,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useKeyboardShortcuts",
    "component_id": "client.hooks.useKeyboardShortcuts.useKeyboardShortcuts"
  },
  "client.hooks.useNodeSelection.UseNodeSelectionProps": {
    "id": "client.hooks.useNodeSelection.UseNodeSelectionProps",
    "name": "UseNodeSelectionProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useNodeSelection.ts",
    "relative_path": "client/hooks/useNodeSelection.ts",
    "depends_on": [
      "client.hooks.useToolSelection.Tool"
    ],
    "source_code": "interface UseNodeSelectionProps {\n  selectedTool: Tool;\n  setNodes: (nodes: Node[] | ((nodes: Node[]) => Node[])) => void;\n}",
    "start_line": 5,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseNodeSelectionProps",
    "component_id": "client.hooks.useNodeSelection.UseNodeSelectionProps"
  },
  "client.hooks.useNodeSelection.useNodeSelection": {
    "id": "client.hooks.useNodeSelection.useNodeSelection",
    "name": "useNodeSelection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useNodeSelection.ts",
    "relative_path": "client/hooks/useNodeSelection.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.hooks.useNodeSelection.UseNodeSelectionProps"
    ],
    "source_code": "useNodeSelection = ({ selectedTool, setNodes }: UseNodeSelectionProps) => {\n  const [selectedNodes, setSelectedNodes] = useState<Node[]>([]);\n  const [selectedEdges, setSelectedEdges] = useState<Edge[]>([]);\n\n  const onSelectionChange = useCallback(({ nodes: selectedNodesParam, edges: selectedEdgesParam }: { nodes: Node[]; edges: Edge[] }) => {\n    // CRITICAL: When connector or box tool is active, ignore node selections\n    // Box tool: nodes should not be selectable while placing new nodes\n    // Connector tool: nodes should not be selectable while connecting\n    if (selectedTool === 'connector' || selectedTool === 'box') {\n      // Clear node selection when these tools are active\n      if (selectedNodesParam.length > 0) {\n        console.log('üö´ [onSelectionChange] Ignoring node selection - tool is:', selectedTool);\n        // Force deselect nodes in ReactFlow\n        setNodes((nds) => nds.map(node => ({ ...node, selected: false })));\n      }\n      setSelectedNodes([]);\n      setSelectedEdges(selectedEdgesParam);\n      return;\n    }\n\n    // Normal selection handling for select tool\n    setSelectedNodes(selectedNodesParam);\n    setSelectedEdges(selectedEdgesParam);\n    \n    // Log selection changes for debugging\n    console.log('üì¶ Selected nodes:', selectedNodesParam.map(n => n.id));\n    console.log('üì¶ Selected edges:', selectedEdgesParam.map(e => e.id));\n  }, [selectedTool, setNodes]);\n\n  return {\n    selectedNodes,\n    selectedEdges,\n    setSelectedNodes,\n    setSelectedEdges,\n    onSelectionChange\n  };\n}",
    "start_line": 10,
    "end_line": 46,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useNodeSelection",
    "component_id": "client.hooks.useNodeSelection.useNodeSelection"
  },
  "client.hooks.useOpenAIKey.useOpenAIKey": {
    "id": "client.hooks.useOpenAIKey.useOpenAIKey",
    "name": "useOpenAIKey",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useOpenAIKey.ts",
    "relative_path": "client/hooks/useOpenAIKey.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function useOpenAIKey() {\n  const [apiKey, setApiKey] = useState<string | undefined>(undefined);\n\n  useEffect(() => {\n    // Try to get the API key from Vite's environment variables\n    const key = import.meta.env.VITE_OPENAI_API_KEY;\n    if (key) {\n      setApiKey(key);\n      return;\n    }\n\n    // If not found in environment, try to get it from window\n    const windowKey = (window as any).VITE_OPENAI_API_KEY;\n    if (windowKey) {\n      setApiKey(windowKey);\n      return;\n    }\n\n    // If still not found, try to get it from a script tag\n    const script = document.querySelector('script[data-openai-key]');\n    if (script) {\n      const key = script.getAttribute('data-openai-key');\n      if (key) {\n        setApiKey(key);\n        return;\n      }\n    }\n\n    // If we get here, no key was found\n    console.warn(\"‚ö†Ô∏è OPENAI_API_KEY is not set. Please add VITE_OPENAI_API_KEY to your .env file\");\n  }, []);\n\n  return apiKey;\n}",
    "start_line": 3,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useOpenAIKey",
    "component_id": "client.hooks.useOpenAIKey.useOpenAIKey"
  },
  "client.hooks.useSessionLifecycle.useSessionLifecycle": {
    "id": "client.hooks.useSessionLifecycle.useSessionLifecycle",
    "name": "useSessionLifecycle",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useSessionLifecycle.ts",
    "relative_path": "client/hooks/useSessionLifecycle.ts",
    "depends_on": [
      "client.realtime.safeSend.safeSend"
    ],
    "source_code": "function useSessionLifecycle(events: any[], safeSend: (e: any) => void) {\n  const lastId = useRef<string|undefined>(undefined);\n  const initSent = useRef(false);\n  const processed = useRef(new Set<string>());\n\n  useEffect(() => {\n    const created = events.find(e => e.type === \"session.created\");\n    if (!created) return;\n    if (created.session?.id === lastId.current) return;\n\n    lastId.current = created.session.id;\n    initSent.current = false;\n    processed.current.clear();\n    safeSend({ type: \"session.update\", session: { tool_choice: \"auto\" } });\n  }, [events, safeSend]);\n\n  // Cleanup on unmount\n  useEffect(() => () => {\n    processed.current.clear();\n  }, []);\n\n  return { initSent, processed };\n}",
    "start_line": 3,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "events",
      "safeSend"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useSessionLifecycle",
    "component_id": "client.hooks.useSessionLifecycle.useSessionLifecycle"
  },
  "client.hooks.useToolSelection.Tool": {
    "id": "client.hooks.useToolSelection.Tool",
    "name": "Tool",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useToolSelection.ts",
    "relative_path": "client/hooks/useToolSelection.ts",
    "depends_on": [],
    "source_code": "type Tool = 'select' | 'box' | 'connector' | 'group';",
    "start_line": 4,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Tool",
    "component_id": "client.hooks.useToolSelection.Tool"
  },
  "client.hooks.useToolSelection.UseToolSelectionProps": {
    "id": "client.hooks.useToolSelection.UseToolSelectionProps",
    "name": "UseToolSelectionProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useToolSelection.ts",
    "relative_path": "client/hooks/useToolSelection.ts",
    "depends_on": [],
    "source_code": "interface UseToolSelectionProps {\n  nodes: Node[];\n  setNodes: (nodes: Node[] | ((nodes: Node[]) => Node[])) => void;\n  setSelectedNodes: (nodes: Node[]) => void;\n}",
    "start_line": 6,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseToolSelectionProps",
    "component_id": "client.hooks.useToolSelection.UseToolSelectionProps"
  },
  "client.hooks.useToolSelection.useToolSelection": {
    "id": "client.hooks.useToolSelection.useToolSelection",
    "name": "useToolSelection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useToolSelection.ts",
    "relative_path": "client/hooks/useToolSelection.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.hooks.useToolSelection.Tool",
      "client.hooks.useToolSelection.UseToolSelectionProps"
    ],
    "source_code": "useToolSelection = ({ nodes, setNodes, setSelectedNodes }: UseToolSelectionProps) => {\n  const [selectedTool, setSelectedTool] = useState<Tool>('select');\n\n  const handleToolSelect = useCallback((tool: Tool) => {\n    console.log('üõ†Ô∏è [handleToolSelect] Switching tool:', { from: selectedTool, to: tool });\n    \n    // Deselect all nodes when switching to box or connector tool BEFORE setting the tool\n    // This ensures nodes are deselected immediately when switching tools\n    if (tool === 'connector' || tool === 'box') {\n      console.log('üõ†Ô∏è [handleToolSelect] Deselecting nodes for tool:', tool);\n      \n      // Debug nodes state  \n      console.log('üõ†Ô∏è [handleToolSelect] Nodes from state:', nodes.length, 'selected:', nodes.filter(n => n.selected).length);\n      \n      // Use the actual nodes state instead of ref (ref might be stale)\n      const selectedNodesFromState = nodes.filter(n => n.selected);\n      console.log('üõ†Ô∏è [handleToolSelect] Selected nodes from state:', selectedNodesFromState.map(n => n.id));\n      \n      // Deselect all nodes using state (more reliable than ref)\n      if (selectedNodesFromState.length > 0) {\n        console.log('üõ†Ô∏è [handleToolSelect] Deselecting nodes:', selectedNodesFromState.map(n => n.id));\n        setNodes((nds) => {\n          const updated = nds.map(node => ({ ...node, selected: false }));\n          console.log('üõ†Ô∏è [handleToolSelect] After deselection - nodes:', updated.length, 'selected:', updated.filter(n => n.selected).length);\n          return updated;\n        });\n      }\n      \n      setSelectedNodes([]);\n    }\n    \n    // Special case: If switching away from arrow tool while nodes are selected, deselect them\n    if (selectedTool === 'select' && tool !== 'select') {\n      const selectedNodesFromState = nodes.filter(n => n.selected);\n      if (selectedNodesFromState.length > 0) {\n        console.log('üõ†Ô∏è [handleToolSelect] Switching away from select tool, deselecting nodes:', selectedNodesFromState.map(n => n.id));\n        setNodes((nds) => nds.map(node => ({ ...node, selected: false })));\n        setSelectedNodes([]);\n      }\n    }\n    \n    // Set the tool after deselection\n    setSelectedTool(tool);\n    console.log('üõ†Ô∏è [handleToolSelect] Tool set to:', tool);\n  }, [selectedTool, nodes, setNodes, setSelectedNodes]);\n\n  return {\n    selectedTool,\n    handleToolSelect\n  };\n}",
    "start_line": 12,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function useToolSelection",
    "component_id": "client.hooks.useToolSelection.useToolSelection"
  },
  "client.hooks.useUrlArchitecture.UseUrlArchitectureProps": {
    "id": "client.hooks.useUrlArchitecture.UseUrlArchitectureProps",
    "name": "UseUrlArchitectureProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useUrlArchitecture.ts",
    "relative_path": "client/hooks/useUrlArchitecture.ts",
    "depends_on": [
      "client.services.anonymousArchitectureService.AnonymousArchitecture"
    ],
    "source_code": "interface UseUrlArchitectureProps {\n  loadArchitecture: (architecture: AnonymousArchitecture, source: string) => void;\n  config: { isEmbedded: boolean; requiresAuth?: boolean };\n  currentUser?: {\n    uid: string;\n    email: string | null;\n  } | null;\n}",
    "start_line": 13,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UseUrlArchitectureProps",
    "component_id": "client.hooks.useUrlArchitecture.UseUrlArchitectureProps"
  },
  "client.hooks.useUrlArchitecture.useUrlArchitecture": {
    "id": "client.hooks.useUrlArchitecture.useUrlArchitecture",
    "name": "useUrlArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/hooks/useUrlArchitecture.ts",
    "relative_path": "client/hooks/useUrlArchitecture.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.services.anonymousArchitectureService.getArchitectureIdFromUrl",
      "client.utils.naming.generateNameWithFallback",
      "client.utils.chatPersistence.isEmbedToCanvasTransition",
      "client.utils.chatPersistence.getCurrentConversation",
      "client.services.architectureService.saveArchitecture",
      "client.services.anonymousArchitectureService.loadAnonymousArchitectureById",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.chatPersistence.mergeChatMessages",
      "client.hooks.useUrlArchitecture.UseUrlArchitectureProps",
      "client.utils.canvasPersistence.restoreCanvasSnapshot",
      "client.utils.chatPersistence.getChatMessages",
      "scripts.test-vercel-preview.error",
      "client.utils.copyToClipboard.isEmbedded",
      "client.utils.chatPersistence.normalizeChatMessages"
    ],
    "source_code": "function useUrlArchitecture({ loadArchitecture, config, currentUser }: UseUrlArchitectureProps) {\n  // Store the current user in a ref so it's always up to date\n  const currentUserRef = useRef(currentUser);\n  currentUserRef.current = currentUser;\n  /**\n   * Check for URL architecture ID and load it if present\n   * Returns whether URL architecture was found and loaded\n   */\n  const checkAndLoadUrlArchitecture = useCallback(async (): Promise<boolean> => {\n    // Short circuit for embedded mode\n    if (config.isEmbedded) {\n      return false;\n    }\n\n    // CRITICAL: ALWAYS check localStorage FIRST before loading from URL\n    // This is the user's explicit requirement: localStorage has priority\n    if (typeof window !== 'undefined') {\n      try {\n        // Check if localStorage has been explicitly set (even if empty)\n        const stored = localStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY) || sessionStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY);\n        \n        console.log('[üîç URL-ARCH] DEBUG localStorage check:', {\n          hasStoredData: !!stored,\n          storedLength: stored?.length || 0\n        });\n        \n        if (stored) {\n          // localStorage has been set (even if it's empty) - this means user has interacted with the app\n          // Don't load from URL - localStorage takes absolute priority\n          console.log('[üîÑ URL-ARCH] localStorage exists (user has used the app) - skipping URL load entirely');\n          return false;\n        } else {\n          console.log('[üîÑ URL-ARCH] No localStorage data - user has never used the app - proceeding with URL check');\n        }\n      } catch (error) {\n        console.warn('‚ö†Ô∏è [URL-ARCH] Error checking localStorage before URL load:', error);\n        // Continue with URL load if localStorage check fails\n      }\n    }\n\n    // Only proceed with URL loading if localStorage is empty or doesn't exist\n    const urlArchId = anonymousArchitectureService.getArchitectureIdFromUrl();\n    if (urlArchId) {\n      console.log('[üîÑ URL-ARCH] Loading from URL since localStorage is empty:', urlArchId);\n      await loadSharedAnonymousArchitecture(urlArchId);\n      return true;\n    }\n    \n    return false;\n  }, [loadArchitecture, config.isEmbedded]);\n\n  /**\n   * Load a shared anonymous architecture by ID\n   */\n  const loadSharedAnonymousArchitecture = useCallback(async (architectureId: string) => {\n    \n    try {\n      // CRITICAL: Check if localStorage has a snapshot for this architecture ID first\n      // If it does, skip loading from Firebase/URL - localStorage takes precedence (user's current state)\n      if (typeof window !== 'undefined') {\n        try {\n          const snapshot = restoreCanvasSnapshot();\n          if (snapshot && snapshot.selectedArchitectureId === architectureId) {\n            const hasContent = \n              (snapshot.rawGraph?.children && snapshot.rawGraph.children.length > 0) ||\n              (snapshot.rawGraph?.edges && snapshot.rawGraph.edges.length > 0);\n            \n            if (hasContent) {\n              console.log('[üîÑ URL-ARCH] Skipping URL load - localStorage snapshot exists for same architecture:', architectureId);\n              // Return early - let the localStorage restoration handle it\n              return true;\n            }\n          }\n        } catch (error) {\n          console.warn('‚ö†Ô∏è [LOAD-SHARED] Error checking localStorage snapshot:', error);\n          // Continue with normal load\n        }\n      }\n      \n      let sharedArch = null;\n      const isLocalFallback = architectureId.startsWith('local-');\n\n      if (!isLocalFallback) {\n        sharedArch = await anonymousArchitectureService.loadAnonymousArchitectureById(architectureId);\n      }\n\n      let fallbackData: any = null;\n      const fallbackSources: Array<'session' | 'local'> = [];\n\n      if (typeof window !== 'undefined') {\n        const storageKey = `${EMBED_PENDING_ARCH_PREFIX}${architectureId}`;\n        try {\n          const sessionPayload = window.sessionStorage?.getItem(storageKey);\n          if (sessionPayload) {\n            fallbackData = JSON.parse(sessionPayload);\n            fallbackSources.push('session');\n          }\n        } catch (error) {\n          console.warn('‚ö†Ô∏è [LOAD-SHARED] Failed to read sessionStorage fallback:', error);\n        }\n\n        if (!fallbackData) {\n          try {\n            const localPayload = window.localStorage?.getItem(storageKey);\n            if (localPayload) {\n              fallbackData = JSON.parse(localPayload);\n              fallbackSources.push('local');\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è [LOAD-SHARED] Failed to read localStorage fallback:', error);\n          }\n        }\n\n        if (!fallbackData && fallbackSources.length === 0) {\n          // If session payload existed but couldn't be parsed, still try local storage\n          try {\n            const localPayload = window.localStorage?.getItem(storageKey);\n            if (localPayload) {\n              fallbackData = JSON.parse(localPayload);\n              fallbackSources.push('local');\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è [LOAD-SHARED] Fallback localStorage parse error:', error);\n          }\n        }\n      }\n\n      if (!sharedArch && !fallbackData) {\n        console.warn('‚ö†Ô∏è [LOAD-SHARED] Shared architecture not found. Falling back to default architecture:', architectureId);\n        const defaultGraph = {\n          id: 'root',\n          children: [\n            {\n              id: 'quickstart_node',\n              labels: [{ text: 'Quickstart Node' }],\n              children: [],\n              edges: [],\n              data: { label: 'Quickstart Node', icon: 'browser_client' },\n            },\n          ],\n          edges: [],\n        };\n\n        sharedArch = {\n          id: architectureId,\n          name: 'Quickstart Architecture',\n          rawGraph: defaultGraph,\n          sessionId: 'default-fallback',\n          timestamp: Timestamp.now(),\n          isAnonymous: true,\n          userPrompt: '',\n          chatMessages: [],\n        } as AnonymousArchitecture;\n      }\n\n      if (!sharedArch && fallbackData?.rawGraph) {\n\n        sharedArch = {\n          id: architectureId,\n          name: fallbackData.name || 'Unsaved Architecture',\n          rawGraph: fallbackData.rawGraph,\n          sessionId: 'local-fallback',\n          timestamp: Timestamp.now(),\n          isAnonymous: true,\n          userPrompt: fallbackData.userPrompt || '',\n          chatMessages: fallbackData.chatMessages || [],\n          viewState: fallbackData.viewState || undefined,\n        } as AnonymousArchitecture;\n      } else if (sharedArch && fallbackData) {\n        const hasChatInDoc = Array.isArray((sharedArch as any).chatMessages) && (sharedArch as any).chatMessages.length > 0;\n        const fallbackChat = Array.isArray(fallbackData.chatMessages) ? fallbackData.chatMessages : [];\n        if (!hasChatInDoc && fallbackChat.length > 0) {\n          sharedArch = {\n            ...sharedArch,\n            chatMessages: fallbackChat,\n            userPrompt: sharedArch.userPrompt || fallbackData.userPrompt || sharedArch.userPrompt,\n            viewState: sharedArch.viewState || fallbackData.viewState || undefined,\n          } as AnonymousArchitecture;\n        }\n      }\n\n      if (fallbackSources.length && typeof window !== 'undefined') {\n        const storageKey = `${EMBED_PENDING_ARCH_PREFIX}${architectureId}`;\n        for (const source of fallbackSources) {\n          try {\n            if (source === 'session') {\n              window.sessionStorage?.removeItem(storageKey);\n            } else if (source === 'local') {\n              window.localStorage?.removeItem(storageKey);\n            }\n          } catch {}\n        }\n      }\n      \n      if (sharedArch && sharedArch.rawGraph) {\n        \n        // ALWAYS set chat messages from architecture (even if empty) to clear any stale localStorage data\n        try {\n          const transitionedFromEmbed = isEmbedToCanvasTransition();\n          const existingConversation = getCurrentConversation();\n          const normalizedArchMessages = normalizeChatMessages((sharedArch as any).chatMessages);\n          const mergedConversation = mergeChatMessages(existingConversation, normalizedArchMessages);\n\n          const existingCount = existingConversation.length;\n          const incomingCount = normalizedArchMessages?.length || 0;\n\n\n          if (mergedConversation && mergedConversation.length > 0) {\n            localStorage.setItem('atelier_current_conversation', JSON.stringify(mergedConversation));\n          } else if (existingCount > 0) {\n          } else {\n            localStorage.removeItem('atelier_current_conversation');\n          }\n        } catch (error) {\n          console.warn('Failed to restore/merge chat messages:', error);\n        }\n        \n        // Check if we're in auth mode (user is authenticated)\n        const isAuthMode = config.requiresAuth || false;\n        \n        if (isAuthMode) {\n          // In auth mode, we need to convert the anonymous architecture to a Firebase architecture\n          // and set it as priority so it becomes the first tab\n\n          // Check if user is authenticated\n          if (!currentUserRef.current?.uid || !currentUserRef.current?.email) {\n            // Still load the architecture as anonymous for now\n            loadArchitecture(sharedArch, 'url-shared-anonymous');\n            return true;\n          }\n\n          try {\n            // Import required modules\n            const { ArchitectureService } = await import('../services/architectureService');\n            const { generateNameWithFallback } = await import('../utils/naming');\n            const { getChatMessages } = await import('../utils/chatPersistence');\n\n            // PRIORITY ORDER for getting userPrompt:\n            // 1. From the loaded architecture (most reliable - saved with the architecture)\n            // 2. From persisted chat messages (fallback for old architectures)\n            // 3. From window global (fallback for current session)\n            // 4. Empty string (will trigger componentsHintFromGraph fallback)\n\n            let userPrompt = sharedArch.userPrompt || '';\n\n            if (!userPrompt) {\n              const persistedMessages = getChatMessages();\n              const lastUserMessage = persistedMessages.filter(msg => msg.sender === 'user').pop();\n              userPrompt = lastUserMessage?.content || (window as any).originalChatTextInput || (window as any).chatTextInput || '';\n\n            } else {\n            }\n\n\n            // Generate name using backend API (will use componentsHintFromGraph if userPrompt is empty)\n            const baseChatName = await generateNameWithFallback(sharedArch.rawGraph, userPrompt);\n            \n            // Save to Firebase\n            const savedArchId = await ArchitectureService.saveArchitecture({\n              name: baseChatName,\n              userId: currentUserRef.current.uid,\n              userEmail: currentUserRef.current.email,\n              rawGraph: sharedArch.rawGraph,\n              userPrompt: userPrompt,\n              nodes: [],\n              edges: []\n            });\n            \n            \n            // Set as priority architecture so it appears as first tab\n            localStorage.setItem('priority_architecture_id', savedArchId);\n            \n            // Create the architecture object for loading\n            const firebaseArch = {\n              id: savedArchId,\n              name: baseChatName,\n              timestamp: new Date(),\n              rawGraph: sharedArch.rawGraph,\n              firebaseId: savedArchId,\n              userPrompt: userPrompt,\n              isFromFirebase: true\n            };\n            \n            // Load the architecture\n            loadArchitecture(firebaseArch, 'URL_AUTH_TRANSFER');\n            \n          } catch (error) {\n            console.error('üî• [LOAD-SHARED] ‚ùå Failed to process for authenticated user:', error);\n            // Fallback to anonymous loading\n            loadArchitecture(sharedArch, 'URL_SHARED');\n          }\n        } else {\n          // In canvas/embed mode, load directly as anonymous architecture\n          loadArchitecture(sharedArch, 'URL_SHARED');\n        }\n        \n      } else {\n        console.warn('üî• [LOAD-SHARED] ‚ö†Ô∏è Shared architecture not found or has no content:', architectureId);\n      }\n    } catch (error) {\n      console.error('üî• [LOAD-SHARED] ‚ùå Failed to load shared architecture:', error);\n    }\n  }, [loadArchitecture, config]);\n\n  return {\n    checkAndLoadUrlArchitecture,\n    loadSharedAnonymousArchitecture\n  };\n}",
    "start_line": 22,
    "end_line": 330,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useUrlArchitecture",
    "component_id": "client.hooks.useUrlArchitecture.useUrlArchitecture"
  },
  "client.layout.types.ViewStateDelta": {
    "id": "client.layout.types.ViewStateDelta",
    "name": "ViewStateDelta",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/layout/types.ts",
    "relative_path": "client/layout/types.ts",
    "depends_on": [],
    "source_code": "type ViewStateDelta = Partial<ViewState>;",
    "start_line": 12,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ViewStateDelta",
    "component_id": "client.layout.types.ViewStateDelta"
  },
  "client.layout.types.LayoutOptions": {
    "id": "client.layout.types.LayoutOptions",
    "name": "LayoutOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/layout/types.ts",
    "relative_path": "client/layout/types.ts",
    "depends_on": [],
    "source_code": "interface LayoutOptions {\n  /**\n   * ID of node/group to anchor (preserve its top-left position)\n   * If provided, layout output will be translated to keep this entity's top-left fixed.\n   */\n  anchorId?: string;\n}",
    "start_line": 17,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LayoutOptions",
    "component_id": "client.layout.types.LayoutOptions"
  },
  "client.lib.BatchRoutingCoordinator.Point": {
    "id": "client.lib.BatchRoutingCoordinator.Point",
    "name": "Point",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "interface Point {\n  x: number;\n  y: number;\n}",
    "start_line": 18,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Point",
    "component_id": "client.lib.BatchRoutingCoordinator.Point"
  },
  "client.lib.BatchRoutingCoordinator.EdgeRegistration": {
    "id": "client.lib.BatchRoutingCoordinator.EdgeRegistration",
    "name": "EdgeRegistration",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "interface EdgeRegistration {\n  id: string;\n  connection: any; // libavoid ConnRef\n  sourceId: string;\n  targetId: string;\n}",
    "start_line": 23,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeRegistration",
    "component_id": "client.lib.BatchRoutingCoordinator.EdgeRegistration"
  },
  "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinatorOptions": {
    "id": "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinatorOptions",
    "name": "BatchRoutingCoordinatorOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "interface BatchRoutingCoordinatorOptions {\n  /** Time to wait after last edge registers before processing (ms) */\n  debounceTime?: number;\n  /** Maximum time to wait for all edges (ms) */\n  maxWaitTime?: number;\n  /** Callback when batch processing completes */\n  onBatchComplete?: (edgeIds: string[]) => void;\n}",
    "start_line": 30,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface BatchRoutingCoordinatorOptions",
    "component_id": "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinatorOptions"
  },
  "client.lib.BatchRoutingCoordinator.RouteReadyCallback": {
    "id": "client.lib.BatchRoutingCoordinator.RouteReadyCallback",
    "name": "RouteReadyCallback",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [
      "client.lib.BatchRoutingCoordinator.Point"
    ],
    "source_code": "type RouteReadyCallback = (route: Point[]) => void;",
    "start_line": 39,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type RouteReadyCallback",
    "component_id": "client.lib.BatchRoutingCoordinator.RouteReadyCallback"
  },
  "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinator": {
    "id": "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinator",
    "name": "BatchRoutingCoordinator",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [
      "client.lib.BatchRoutingCoordinator.Point",
      "scripts.test-vercel-preview.log",
      "client.lib.BatchRoutingCoordinator.reset",
      "client.lib.BatchRoutingCoordinator.EdgeRegistration",
      "client.lib.BatchRoutingCoordinator.RouteReadyCallback",
      "client.lib.BatchRoutingCoordinator.processBatch",
      "client.lib.BatchRoutingCoordinator.checkAndProcess",
      "client.lib.BatchRoutingCoordinator.scheduleProcessing",
      "client.lib.BatchRoutingCoordinator.extractRoute",
      "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinatorOptions",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "class BatchRoutingCoordinator {\n  private router: any = null;\n  private avoidModule: any = null;\n  private routerVersion: string = '';\n  \n  // Edge registration tracking\n  private pendingEdges: Map<string, EdgeRegistration> = new Map();\n  private computedRoutes: Map<string, Point[]> = new Map();\n  private routeCallbacks: Map<string, RouteReadyCallback[]> = new Map();\n  \n  // Batch processing state\n  private expectedEdgeCount: number = 0;\n  private batchProcessed: boolean = false;\n  private processingInProgress: boolean = false;\n  private debounceTimer: ReturnType<typeof setTimeout> | null = null;\n  private batchStartTime: number = 0;\n  \n  // Configuration\n  private options: Required<BatchRoutingCoordinatorOptions>;\n  \n  constructor(options: BatchRoutingCoordinatorOptions = {}) {\n    this.options = {\n      debounceTime: options.debounceTime ?? 100,\n      maxWaitTime: options.maxWaitTime ?? 2000,\n      onBatchComplete: options.onBatchComplete ?? (() => {}),\n    };\n  }\n  \n  /**\n   * Initialize or reset the coordinator with a new router\n   * Simplified: No router version tracking - router is managed by StepEdge\n   */\n  initialize(router: any, avoidModule: any): void {\n    // Only reset if router instance actually changed\n    if (this.router !== router) {\n      this.reset();\n      this.router = router;\n      this.avoidModule = avoidModule;\n      this.routerVersion = 'persistent'; // No version tracking - router persists\n      this.batchStartTime = Date.now();\n    }\n  }\n  \n  /**\n   * Set the expected number of edges for this batch\n   */\n  setExpectedEdgeCount(count: number): void {\n    if (this.expectedEdgeCount !== count) {\n      console.log(`[BatchRoutingCoordinator] Expected edge count changed: ${this.expectedEdgeCount} -> ${count}`);\n      this.expectedEdgeCount = count;\n      \n      // If we already have enough edges, trigger processing\n      if (this.pendingEdges.size >= count && !this.batchProcessed) {\n        this.scheduleProcessing();\n      }\n    }\n  }\n  \n  /**\n   * Register an edge for batch routing\n   * \n   * @param id - Unique edge identifier\n   * @param connection - libavoid ConnRef object\n   * @param sourceId - Source node ID\n   * @param targetId - Target node ID\n   * @param onRouteReady - Callback when route is computed\n   */\n  registerEdge(\n    id: string,\n    connection: any,\n    sourceId: string,\n    targetId: string,\n    onRouteReady?: RouteReadyCallback\n  ): void {\n    // Store the registration\n    this.pendingEdges.set(id, {\n      id,\n      connection,\n      sourceId,\n      targetId,\n    });\n    \n    // Store callback if provided\n    if (onRouteReady) {\n      if (!this.routeCallbacks.has(id)) {\n        this.routeCallbacks.set(id, []);\n      }\n      this.routeCallbacks.get(id)!.push(onRouteReady);\n    }\n    \n    console.log(`[BatchRoutingCoordinator] Edge registered: ${id} (${this.pendingEdges.size}/${this.expectedEdgeCount})`);\n    \n    // Check if we should process\n    this.checkAndProcess();\n  }\n  \n  /**\n   * Check if we should trigger batch processing\n   */\n  private checkAndProcess(): void {\n    if (this.batchProcessed || this.processingInProgress) {\n      return;\n    }\n    \n    const pendingCount = this.pendingEdges.size;\n    const waitTime = Date.now() - this.batchStartTime;\n    \n    // Process if all edges registered OR if we've waited too long\n    if (pendingCount >= this.expectedEdgeCount && this.expectedEdgeCount > 0) {\n      this.scheduleProcessing();\n    } else if (waitTime > this.options.maxWaitTime && pendingCount > 0) {\n      console.log(`[BatchRoutingCoordinator] Max wait time exceeded (${waitTime}ms), processing ${pendingCount} edges`);\n      this.processBatch();\n    }\n  }\n  \n  /**\n   * Schedule batch processing with debounce\n   */\n  private scheduleProcessing(): void {\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n    }\n    \n    this.debounceTimer = setTimeout(() => {\n      this.processBatch();\n    }, this.options.debounceTime);\n  }\n  \n  /**\n   * Process all registered edges in a single batch\n   */\n  private processBatch(): void {\n    if (this.batchProcessed || this.processingInProgress || !this.router) {\n      return;\n    }\n    \n    this.processingInProgress = true;\n    const edgeIds = Array.from(this.pendingEdges.keys());\n    \n    console.log(`[BatchRoutingCoordinator] üöÄ Processing batch: ${edgeIds.length} edges`);\n    \n    try {\n      // Call processTransaction ONCE for all edges\n      this.router.processTransaction?.();\n      \n      // Extract routes for each edge\n      for (const [id, registration] of Array.from(this.pendingEdges.entries())) {\n        const route = this.extractRoute(registration.connection);\n        this.computedRoutes.set(id, route);\n        \n        console.log(`[BatchRoutingCoordinator] Route computed for ${id}: ${route.length} points`);\n        \n        // Notify callbacks\n        const callbacks = this.routeCallbacks.get(id) || [];\n        for (const callback of callbacks) {\n          callback(route);\n        }\n      }\n      \n      this.batchProcessed = true;\n      this.processingInProgress = false;\n      \n      console.log(`[BatchRoutingCoordinator] ‚úÖ Batch complete: ${edgeIds.length} edges processed`);\n      this.options.onBatchComplete(edgeIds);\n      \n    } catch (error) {\n      console.error(`[BatchRoutingCoordinator] ‚ùå Batch processing failed:`, error);\n      this.processingInProgress = false;\n    }\n  }\n  \n  /**\n   * Extract route points from a libavoid connection\n   */\n  private extractRoute(connection: any): Point[] {\n    const points: Point[] = [];\n    \n    try {\n      const polyline = connection.displayRoute();\n      for (let i = 0; i < polyline.size(); i++) {\n        const pt = polyline.get_ps(i);\n        points.push({ x: pt.x, y: pt.y });\n      }\n    } catch (error) {\n      console.error(`[BatchRoutingCoordinator] Failed to extract route:`, error);\n    }\n    \n    return points;\n  }\n  \n  /**\n   * Get the computed route for an edge\n   * Returns null if route is not yet computed\n   */\n  getRoute(id: string): Point[] | null {\n    return this.computedRoutes.get(id) || null;\n  }\n  \n  /**\n   * Check if batch processing is complete\n   */\n  isBatchComplete(): boolean {\n    return this.batchProcessed;\n  }\n  \n  /**\n   * Check if an edge is registered\n   */\n  isEdgeRegistered(id: string): boolean {\n    return this.pendingEdges.has(id);\n  }\n  \n  /**\n   * Get current batch status\n   */\n  getStatus(): {\n    routerVersion: string;\n    expectedEdgeCount: number;\n    registeredEdgeCount: number;\n    batchProcessed: boolean;\n    processingInProgress: boolean;\n  } {\n    return {\n      routerVersion: this.routerVersion || 'persistent', // No version tracking - router persists\n      expectedEdgeCount: this.expectedEdgeCount,\n      registeredEdgeCount: this.pendingEdges.size,\n      batchProcessed: this.batchProcessed,\n      processingInProgress: this.processingInProgress,\n    };\n  }\n  \n  /**\n   * Reset the coordinator for a new batch\n   */\n  reset(): void {\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n      this.debounceTimer = null;\n    }\n    \n    this.pendingEdges.clear();\n    this.computedRoutes.clear();\n    this.routeCallbacks.clear();\n    this.batchProcessed = false;\n    this.processingInProgress = false;\n    this.batchStartTime = Date.now();\n    \n    console.log(`[BatchRoutingCoordinator] Reset`);\n  }\n  \n  /**\n   * Force immediate processing (useful for testing or when edge count is unknown)\n   */\n  forceProcess(): void {\n    if (!this.batchProcessed && this.pendingEdges.size > 0) {\n      console.log(`[BatchRoutingCoordinator] Force processing ${this.pendingEdges.size} edges`);\n      this.processBatch();\n    }\n  }\n}",
    "start_line": 41,
    "end_line": 301,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class BatchRoutingCoordinator",
    "component_id": "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinator"
  },
  "client.lib.BatchRoutingCoordinator.initialize": {
    "id": "client.lib.BatchRoutingCoordinator.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "initialize(router: any, avoidModule: any): void {\n    // Only reset if router instance actually changed\n    if (this.router !== router) {\n      this.reset();\n      this.router = router;\n      this.avoidModule = avoidModule;\n      this.routerVersion = 'persistent'; // No version tracking - router persists\n      this.batchStartTime = Date.now();\n    }\n  }",
    "start_line": 73,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "router",
      "avoidModule"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initialize",
    "component_id": "client.lib.BatchRoutingCoordinator.initialize"
  },
  "client.lib.BatchRoutingCoordinator.setExpectedEdgeCount": {
    "id": "client.lib.BatchRoutingCoordinator.setExpectedEdgeCount",
    "name": "setExpectedEdgeCount",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "setExpectedEdgeCount(count: number): void {\n    if (this.expectedEdgeCount !== count) {\n      console.log(`[BatchRoutingCoordinator] Expected edge count changed: ${this.expectedEdgeCount} -> ${count}`);\n      this.expectedEdgeCount = count;\n      \n      // If we already have enough edges, trigger processing\n      if (this.pendingEdges.size >= count && !this.batchProcessed) {\n        this.scheduleProcessing();\n      }\n    }\n  }",
    "start_line": 87,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "count"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method setExpectedEdgeCount",
    "component_id": "client.lib.BatchRoutingCoordinator.setExpectedEdgeCount"
  },
  "client.lib.BatchRoutingCoordinator.registerEdge": {
    "id": "client.lib.BatchRoutingCoordinator.registerEdge",
    "name": "registerEdge",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "registerEdge(\n    id: string,\n    connection: any,\n    sourceId: string,\n    targetId: string,\n    onRouteReady?: RouteReadyCallback\n  ): void {\n    // Store the registration\n    this.pendingEdges.set(id, {\n      id,\n      connection,\n      sourceId,\n      targetId,\n    });\n    \n    // Store callback if provided\n    if (onRouteReady) {\n      if (!this.routeCallbacks.has(id)) {\n        this.routeCallbacks.set(id, []);\n      }\n      this.routeCallbacks.get(id)!.push(onRouteReady);\n    }\n    \n    console.log(`[BatchRoutingCoordinator] Edge registered: ${id} (${this.pendingEdges.size}/${this.expectedEdgeCount})`);\n    \n    // Check if we should process\n    this.checkAndProcess();\n  }",
    "start_line": 108,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id",
      "connection",
      "sourceId",
      "targetId",
      "onRouteReady"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method registerEdge",
    "component_id": "client.lib.BatchRoutingCoordinator.registerEdge"
  },
  "client.lib.BatchRoutingCoordinator.checkAndProcess": {
    "id": "client.lib.BatchRoutingCoordinator.checkAndProcess",
    "name": "checkAndProcess",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "private checkAndProcess(): void {\n    if (this.batchProcessed || this.processingInProgress) {\n      return;\n    }\n    \n    const pendingCount = this.pendingEdges.size;\n    const waitTime = Date.now() - this.batchStartTime;\n    \n    // Process if all edges registered OR if we've waited too long\n    if (pendingCount >= this.expectedEdgeCount && this.expectedEdgeCount > 0) {\n      this.scheduleProcessing();\n    } else if (waitTime > this.options.maxWaitTime && pendingCount > 0) {\n      console.log(`[BatchRoutingCoordinator] Max wait time exceeded (${waitTime}ms), processing ${pendingCount} edges`);\n      this.processBatch();\n    }\n  }",
    "start_line": 140,
    "end_line": 155,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method checkAndProcess",
    "component_id": "client.lib.BatchRoutingCoordinator.checkAndProcess"
  },
  "client.lib.BatchRoutingCoordinator.scheduleProcessing": {
    "id": "client.lib.BatchRoutingCoordinator.scheduleProcessing",
    "name": "scheduleProcessing",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "private scheduleProcessing(): void {\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n    }\n    \n    this.debounceTimer = setTimeout(() => {\n      this.processBatch();\n    }, this.options.debounceTime);\n  }",
    "start_line": 160,
    "end_line": 168,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method scheduleProcessing",
    "component_id": "client.lib.BatchRoutingCoordinator.scheduleProcessing"
  },
  "client.lib.BatchRoutingCoordinator.processBatch": {
    "id": "client.lib.BatchRoutingCoordinator.processBatch",
    "name": "processBatch",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "private processBatch(): void {\n    if (this.batchProcessed || this.processingInProgress || !this.router) {\n      return;\n    }\n    \n    this.processingInProgress = true;\n    const edgeIds = Array.from(this.pendingEdges.keys());\n    \n    console.log(`[BatchRoutingCoordinator] üöÄ Processing batch: ${edgeIds.length} edges`);\n    \n    try {\n      // Call processTransaction ONCE for all edges\n      this.router.processTransaction?.();\n      \n      // Extract routes for each edge\n      for (const [id, registration] of Array.from(this.pendingEdges.entries())) {\n        const route = this.extractRoute(registration.connection);\n        this.computedRoutes.set(id, route);\n        \n        console.log(`[BatchRoutingCoordinator] Route computed for ${id}: ${route.length} points`);\n        \n        // Notify callbacks\n        const callbacks = this.routeCallbacks.get(id) || [];\n        for (const callback of callbacks) {\n          callback(route);\n        }\n      }\n      \n      this.batchProcessed = true;\n      this.processingInProgress = false;\n      \n      console.log(`[BatchRoutingCoordinator] ‚úÖ Batch complete: ${edgeIds.length} edges processed`);\n      this.options.onBatchComplete(edgeIds);\n      \n    } catch (error) {\n      console.error(`[BatchRoutingCoordinator] ‚ùå Batch processing failed:`, error);\n      this.processingInProgress = false;\n    }\n  }",
    "start_line": 173,
    "end_line": 211,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method processBatch",
    "component_id": "client.lib.BatchRoutingCoordinator.processBatch"
  },
  "client.lib.BatchRoutingCoordinator.extractRoute": {
    "id": "client.lib.BatchRoutingCoordinator.extractRoute",
    "name": "extractRoute",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "private extractRoute(connection: any): Point[] {\n    const points: Point[] = [];\n    \n    try {\n      const polyline = connection.displayRoute();\n      for (let i = 0; i < polyline.size(); i++) {\n        const pt = polyline.get_ps(i);\n        points.push({ x: pt.x, y: pt.y });\n      }\n    } catch (error) {\n      console.error(`[BatchRoutingCoordinator] Failed to extract route:`, error);\n    }\n    \n    return points;\n  }",
    "start_line": 216,
    "end_line": 230,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "connection"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method extractRoute",
    "component_id": "client.lib.BatchRoutingCoordinator.extractRoute"
  },
  "client.lib.BatchRoutingCoordinator.getRoute": {
    "id": "client.lib.BatchRoutingCoordinator.getRoute",
    "name": "getRoute",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "getRoute(id: string): Point[] | null {\n    return this.computedRoutes.get(id) || null;\n  }",
    "start_line": 236,
    "end_line": 238,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getRoute",
    "component_id": "client.lib.BatchRoutingCoordinator.getRoute"
  },
  "client.lib.BatchRoutingCoordinator.isBatchComplete": {
    "id": "client.lib.BatchRoutingCoordinator.isBatchComplete",
    "name": "isBatchComplete",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "isBatchComplete(): boolean {\n    return this.batchProcessed;\n  }",
    "start_line": 243,
    "end_line": 245,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isBatchComplete",
    "component_id": "client.lib.BatchRoutingCoordinator.isBatchComplete"
  },
  "client.lib.BatchRoutingCoordinator.isEdgeRegistered": {
    "id": "client.lib.BatchRoutingCoordinator.isEdgeRegistered",
    "name": "isEdgeRegistered",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "isEdgeRegistered(id: string): boolean {\n    return this.pendingEdges.has(id);\n  }",
    "start_line": 250,
    "end_line": 252,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isEdgeRegistered",
    "component_id": "client.lib.BatchRoutingCoordinator.isEdgeRegistered"
  },
  "client.lib.BatchRoutingCoordinator.getStatus": {
    "id": "client.lib.BatchRoutingCoordinator.getStatus",
    "name": "getStatus",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "getStatus(): {\n    routerVersion: string;\n    expectedEdgeCount: number;\n    registeredEdgeCount: number;\n    batchProcessed: boolean;\n    processingInProgress: boolean;\n  } {\n    return {\n      routerVersion: this.routerVersion || 'persistent', // No version tracking - router persists\n      expectedEdgeCount: this.expectedEdgeCount,\n      registeredEdgeCount: this.pendingEdges.size,\n      batchProcessed: this.batchProcessed,\n      processingInProgress: this.processingInProgress,\n    };\n  }",
    "start_line": 257,
    "end_line": 271,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getStatus",
    "component_id": "client.lib.BatchRoutingCoordinator.getStatus"
  },
  "client.lib.BatchRoutingCoordinator.reset": {
    "id": "client.lib.BatchRoutingCoordinator.reset",
    "name": "reset",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "reset(): void {\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n      this.debounceTimer = null;\n    }\n    \n    this.pendingEdges.clear();\n    this.computedRoutes.clear();\n    this.routeCallbacks.clear();\n    this.batchProcessed = false;\n    this.processingInProgress = false;\n    this.batchStartTime = Date.now();\n    \n    console.log(`[BatchRoutingCoordinator] Reset`);\n  }",
    "start_line": 276,
    "end_line": 290,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method reset",
    "component_id": "client.lib.BatchRoutingCoordinator.reset"
  },
  "client.lib.BatchRoutingCoordinator.forceProcess": {
    "id": "client.lib.BatchRoutingCoordinator.forceProcess",
    "name": "forceProcess",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [],
    "source_code": "forceProcess(): void {\n    if (!this.batchProcessed && this.pendingEdges.size > 0) {\n      console.log(`[BatchRoutingCoordinator] Force processing ${this.pendingEdges.size} edges`);\n      this.processBatch();\n    }\n  }",
    "start_line": 295,
    "end_line": 300,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method forceProcess",
    "component_id": "client.lib.BatchRoutingCoordinator.forceProcess"
  },
  "client.lib.BatchRoutingCoordinator.getBatchRoutingCoordinator": {
    "id": "client.lib.BatchRoutingCoordinator.getBatchRoutingCoordinator",
    "name": "getBatchRoutingCoordinator",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [
      "client.lib.BatchRoutingCoordinator.BatchRoutingCoordinator"
    ],
    "source_code": "function getBatchRoutingCoordinator(): BatchRoutingCoordinator {\n  if (!globalCoordinator) {\n    globalCoordinator = new BatchRoutingCoordinator();\n  }\n  return globalCoordinator;\n}",
    "start_line": 309,
    "end_line": 314,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getBatchRoutingCoordinator",
    "component_id": "client.lib.BatchRoutingCoordinator.getBatchRoutingCoordinator"
  },
  "client.lib.BatchRoutingCoordinator.resetBatchRoutingCoordinator": {
    "id": "client.lib.BatchRoutingCoordinator.resetBatchRoutingCoordinator",
    "name": "resetBatchRoutingCoordinator",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/BatchRoutingCoordinator.ts",
    "relative_path": "client/lib/BatchRoutingCoordinator.ts",
    "depends_on": [
      "client.lib.BatchRoutingCoordinator.reset"
    ],
    "source_code": "function resetBatchRoutingCoordinator(): void {\n  if (globalCoordinator) {\n    globalCoordinator.reset();\n  }\n  globalCoordinator = null;\n}",
    "start_line": 319,
    "end_line": 324,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function resetBatchRoutingCoordinator",
    "component_id": "client.lib.BatchRoutingCoordinator.resetBatchRoutingCoordinator"
  },
  "client.lib.utils.cn": {
    "id": "client.lib.utils.cn",
    "name": "cn",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/lib/utils.ts",
    "relative_path": "client/lib/utils.ts",
    "depends_on": [],
    "source_code": "function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}",
    "start_line": 4,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cn",
    "component_id": "client.lib.utils.cn"
  },
  "client.orchestration.Policy.DecideLayoutInput": {
    "id": "client.orchestration.Policy.DecideLayoutInput",
    "name": "DecideLayoutInput",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/orchestration/Policy.ts",
    "relative_path": "client/orchestration/Policy.ts",
    "depends_on": [
      "client.orchestration.types.Source",
      "client.orchestration.types.ModeMap"
    ],
    "source_code": "interface DecideLayoutInput {\n  source: Source;\n  scopeId: string;\n  modeMap: ModeMap;\n}",
    "start_line": 14,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DecideLayoutInput",
    "component_id": "client.orchestration.Policy.DecideLayoutInput"
  },
  "client.orchestration.Policy.decideLayout": {
    "id": "client.orchestration.Policy.decideLayout",
    "name": "decideLayout",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/orchestration/Policy.ts",
    "relative_path": "client/orchestration/Policy.ts",
    "depends_on": [
      "client.orchestration.Policy.DecideLayoutInput",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function decideLayout(input: DecideLayoutInput): boolean {\n  // TODO: Agent D will implement:\n  // - If source === 'ai': return true (AI always ELK)\n  // - If source === 'user':\n  //   - Find highest locked ancestor of scopeId\n  //   - If found: return true (LOCK mode requires ELK)\n  //   - Else: return false (FREE mode, no ELK)\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn(\n      `[Policy] decideLayout called but not yet implemented. ` +\n      `input:`, input\n    );\n  }\n\n  // Stub: default to false (conservative, no ELK until policy implemented)\n  return false;\n}",
    "start_line": 41,
    "end_line": 58,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "input"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function decideLayout",
    "component_id": "client.orchestration.Policy.decideLayout"
  },
  "client.orchestration.Policy.findHighestLockedAncestor": {
    "id": "client.orchestration.Policy.findHighestLockedAncestor",
    "name": "findHighestLockedAncestor",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/orchestration/Policy.ts",
    "relative_path": "client/orchestration/Policy.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.orchestration.types.ModeMap"
    ],
    "source_code": "function findHighestLockedAncestor(\n  id: string,\n  modeMap: ModeMap,\n  parentOf: (id: string) => string | null\n): string | null {\n  // TODO: Agent D will implement:\n  // - Walk up from id to root using parentOf\n  // - For each ancestor, check modeMap\n  // - Return first ancestor with mode === 'LOCK'\n  // - Return null if reach root without finding LOCK\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn(\n      `[Policy] findHighestLockedAncestor called but not yet implemented. ` +\n      `id: ${id}, modeMap keys:`, Object.keys(modeMap)\n    );\n  }\n\n  // Stub: return null (no locked ancestor found)\n  return null;\n}",
    "start_line": 81,
    "end_line": 101,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "id",
      "modeMap",
      "parentOf"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findHighestLockedAncestor",
    "component_id": "client.orchestration.Policy.findHighestLockedAncestor"
  },
  "client.orchestration.types.Source": {
    "id": "client.orchestration.types.Source",
    "name": "Source",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/orchestration/types.ts",
    "relative_path": "client/orchestration/types.ts",
    "depends_on": [],
    "source_code": "type Source = 'ai' | 'user';",
    "start_line": 9,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Source",
    "component_id": "client.orchestration.types.Source"
  },
  "client.orchestration.types.EditKind": {
    "id": "client.orchestration.types.EditKind",
    "name": "EditKind",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/orchestration/types.ts",
    "relative_path": "client/orchestration/types.ts",
    "depends_on": [],
    "source_code": "type EditKind = \n  | 'geo-only'           // FREE: drag/resize within same parent (no structure change)\n  | 'free-structural'    // FREE: reparent/group/edge ops (structure changes, no ELK)\n  | 'ai-lock-structural';",
    "start_line": 14,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EditKind",
    "component_id": "client.orchestration.types.EditKind"
  },
  "client.orchestration.types.EditIntent": {
    "id": "client.orchestration.types.EditIntent",
    "name": "EditIntent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/orchestration/types.ts",
    "relative_path": "client/orchestration/types.ts",
    "depends_on": [
      "client.orchestration.types.EditKind",
      "client.orchestration.types.Source"
    ],
    "source_code": "interface EditIntent {\n  source: Source;\n  kind: EditKind;\n  scopeId: string;\n  /**\n   * Optional payload for specific operations\n   */\n  payload?: {\n    nodeId?: string;\n    oldParentId?: string;\n    newParentId?: string;\n    [key: string]: unknown;\n  };\n}",
    "start_line": 22,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EditIntent",
    "component_id": "client.orchestration.types.EditIntent"
  },
  "client.orchestration.types.ModeMap": {
    "id": "client.orchestration.types.ModeMap",
    "name": "ModeMap",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/orchestration/types.ts",
    "relative_path": "client/orchestration/types.ts",
    "depends_on": [],
    "source_code": "type ModeMap = Record<string, 'FREE' | 'LOCK'>;",
    "start_line": 40,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ModeMap",
    "component_id": "client.orchestration.types.ModeMap"
  },
  "client.pages.index.Index": {
    "id": "client.pages.index.Index",
    "name": "Index",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/pages/index.jsx",
    "relative_path": "client/pages/index.jsx",
    "depends_on": [],
    "source_code": "function Index() {\n  return <App />;\n}",
    "start_line": 3,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function Index",
    "component_id": "client.pages.index.Index"
  },
  "client.questionnaire.QuestionnaireExecutor.QuestionnaireExecutor": {
    "id": "client.questionnaire.QuestionnaireExecutor.QuestionnaireExecutor",
    "name": "QuestionnaireExecutor",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/questionnaire/QuestionnaireExecutor.ts",
    "relative_path": "client/questionnaire/QuestionnaireExecutor.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.utils.chatUtils.addUserDecisionToChat",
      "client.utils.chatUtils.createFollowupQuestionsToChat"
    ],
    "source_code": "class QuestionnaireExecutor {\n  constructor() {\n    // No API key needed - using server endpoint\n  }\n\n  async execute(\n    requirement: string,\n    onStartAgent: () => void,\n    onQuestions: (questions: any[]) => void,\n    onError: (error: Error) => void\n  ): Promise<void> {\n    try {\n      console.log('üîß Starting questionnaire agent with requirement:', requirement);\n      \n      onStartAgent();\n\n      const messages = [\n        {\n          role: 'system',\n          content: questionnaireAgentDescription\n        },\n        {\n          role: 'user',\n          content: requirement\n        }\n      ];\n\n      console.log('üì§ Sending request to server /questionnaire endpoint...');\n\n      // Use the API endpoint (works for both local and prod)\n      const response = await fetch('/api/questionnaire', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          messages\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        console.error('‚ùå Server API error:', response.status, errorData);\n        throw new Error(`Server API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n      console.log('üì® Server Response:', data);\n\n      // Check for function call in the server response format\n      if (data.output && data.output.length > 0) {\n        const output = data.output[0];\n        \n        if (output.type === 'function_call' && output.function_call.name === 'log_requirements_and_generate_questions') {\n          const functionArgs = JSON.parse(output.function_call.arguments);\n          console.log('‚úÖ Parsed function arguments:', functionArgs);\n          \n          if (functionArgs.requirements && functionArgs.questions) {\n            console.log('üîç DEBUG: Requirements extracted:', functionArgs.requirements);\n            console.log('üîç DEBUG: Questions generated:', functionArgs.questions);\n            \n            // Add user's original requirement to chat\n            addUserDecisionToChat(requirement);\n            \n            // Process questions and add to chat\n            const processedQuestions = functionArgs.questions.map((q: any, index: number) => ({\n              id: `q_${Date.now()}_${index}`,\n              ...q\n            }));\n            \n            createFollowupQuestionsToChat(processedQuestions);\n            \n            // Store chat data for reasoning agent\n            const chatMessages = [\n              {\n                id: crypto.randomUUID(),\n                content: requirement,\n                sender: 'user'\n              },\n              ...functionArgs.requirements.map((req: string) => ({\n                id: crypto.randomUUID(),\n                content: req,\n                sender: 'user'\n              })),\n              ...processedQuestions.map(q => ({\n                id: q.id,\n                content: q.text,\n                sender: 'assistant',\n                type: q.type === 'multiselect' ? 'checkbox-question' : 'radio-question',\n                question: q.text,\n                options: q.options.map((option: string, optIndex: number) => ({\n                  id: `${q.id}_${optIndex}`,\n                  text: option\n                }))\n              }))\n            ];\n            \n            // Store for reasoning agent\n            storeChatData(chatMessages, {});\n            console.log('üîç DEBUG: Stored chat messages for reasoning agent:', chatMessages);\n            console.log('üìù Stored chat data for reasoning agent:', chatMessages.length, 'messages');\n            \n            // Call the callback with questions\n            onQuestions(processedQuestions);\n            \n            console.log('‚úÖ Questions processed and added to chat');\n          } else {\n            console.error('‚ùå Missing requirements or questions in function call');\n            throw new Error('Invalid function call response - missing requirements or questions');\n          }\n        } else {\n          console.error('‚ùå Unexpected function call or message:', output);\n          throw new Error(`Unexpected response type: ${output.type}`);\n        }\n      } else {\n        console.error('‚ùå No output in server response');\n        throw new Error('No output in server response');\n      }\n\n    } catch (error) {\n      console.error('‚ùå Questionnaire execution failed:', error);\n      onError(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }\n}",
    "start_line": 5,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class QuestionnaireExecutor",
    "component_id": "client.questionnaire.QuestionnaireExecutor.QuestionnaireExecutor"
  },
  "client.questionnaire.QuestionnaireExecutor.execute": {
    "id": "client.questionnaire.QuestionnaireExecutor.execute",
    "name": "execute",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/questionnaire/QuestionnaireExecutor.ts",
    "relative_path": "client/questionnaire/QuestionnaireExecutor.ts",
    "depends_on": [],
    "source_code": "async execute(\n    requirement: string,\n    onStartAgent: () => void,\n    onQuestions: (questions: any[]) => void,\n    onError: (error: Error) => void\n  ): Promise<void> {\n    try {\n      console.log('üîß Starting questionnaire agent with requirement:', requirement);\n      \n      onStartAgent();\n\n      const messages = [\n        {\n          role: 'system',\n          content: questionnaireAgentDescription\n        },\n        {\n          role: 'user',\n          content: requirement\n        }\n      ];\n\n      console.log('üì§ Sending request to server /questionnaire endpoint...');\n\n      // Use the API endpoint (works for both local and prod)\n      const response = await fetch('/api/questionnaire', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          messages\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        console.error('‚ùå Server API error:', response.status, errorData);\n        throw new Error(`Server API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n      console.log('üì® Server Response:', data);\n\n      // Check for function call in the server response format\n      if (data.output && data.output.length > 0) {\n        const output = data.output[0];\n        \n        if (output.type === 'function_call' && output.function_call.name === 'log_requirements_and_generate_questions') {\n          const functionArgs = JSON.parse(output.function_call.arguments);\n          console.log('‚úÖ Parsed function arguments:', functionArgs);\n          \n          if (functionArgs.requirements && functionArgs.questions) {\n            console.log('üîç DEBUG: Requirements extracted:', functionArgs.requirements);\n            console.log('üîç DEBUG: Questions generated:', functionArgs.questions);\n            \n            // Add user's original requirement to chat\n            addUserDecisionToChat(requirement);\n            \n            // Process questions and add to chat\n            const processedQuestions = functionArgs.questions.map((q: any, index: number) => ({\n              id: `q_${Date.now()}_${index}`,\n              ...q\n            }));\n            \n            createFollowupQuestionsToChat(processedQuestions);\n            \n            // Store chat data for reasoning agent\n            const chatMessages = [\n              {\n                id: crypto.randomUUID(),\n                content: requirement,\n                sender: 'user'\n              },\n              ...functionArgs.requirements.map((req: string) => ({\n                id: crypto.randomUUID(),\n                content: req,\n                sender: 'user'\n              })),\n              ...processedQuestions.map(q => ({\n                id: q.id,\n                content: q.text,\n                sender: 'assistant',\n                type: q.type === 'multiselect' ? 'checkbox-question' : 'radio-question',\n                question: q.text,\n                options: q.options.map((option: string, optIndex: number) => ({\n                  id: `${q.id}_${optIndex}`,\n                  text: option\n                }))\n              }))\n            ];\n            \n            // Store for reasoning agent\n            storeChatData(chatMessages, {});\n            console.log('üîç DEBUG: Stored chat messages for reasoning agent:', chatMessages);\n            console.log('üìù Stored chat data for reasoning agent:', chatMessages.length, 'messages');\n            \n            // Call the callback with questions\n            onQuestions(processedQuestions);\n            \n            console.log('‚úÖ Questions processed and added to chat');\n          } else {\n            console.error('‚ùå Missing requirements or questions in function call');\n            throw new Error('Invalid function call response - missing requirements or questions');\n          }\n        } else {\n          console.error('‚ùå Unexpected function call or message:', output);\n          throw new Error(`Unexpected response type: ${output.type}`);\n        }\n      } else {\n        console.error('‚ùå No output in server response');\n        throw new Error('No output in server response');\n      }\n\n    } catch (error) {\n      console.error('‚ùå Questionnaire execution failed:', error);\n      onError(error instanceof Error ? error : new Error('Unknown error'));\n    }\n  }",
    "start_line": 10,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "requirement",
      "onStartAgent",
      "onQuestions",
      "onError"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method execute",
    "component_id": "client.questionnaire.QuestionnaireExecutor.execute"
  },
  "client.realtime.RtcClient.EventCB": {
    "id": "client.realtime.RtcClient.EventCB",
    "name": "EventCB",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/RtcClient.ts",
    "relative_path": "client/realtime/RtcClient.ts",
    "depends_on": [],
    "source_code": "type EventCB = (e: any) => void;",
    "start_line": 1,
    "end_line": 1,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EventCB",
    "component_id": "client.realtime.RtcClient.EventCB"
  },
  "client.realtime.RtcClient.RtcClient": {
    "id": "client.realtime.RtcClient.RtcClient",
    "name": "RtcClient",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/RtcClient.ts",
    "relative_path": "client/realtime/RtcClient.ts",
    "depends_on": [
      "client.realtime.RtcClient.EventCB",
      "scripts.test-vercel-preview.log",
      "client.realtime.RtcClient.close",
      "client.realtime.RtcClient.flush",
      "client.realtime.RtcClient.send"
    ],
    "source_code": "class RtcClient {\n  private pc: RTCPeerConnection | null = null;\n  private dc: RTCDataChannel | null = null;\n  private queue: any[] = [];\n  private onEvent: EventCB;\n\n  constructor(onEvent: EventCB) { this.onEvent = onEvent; }\n\n  /** Open peer-conn, mic ‚Üí track, data-channel. */\n  async connect(token: string) {\n    this.pc = new RTCPeerConnection();\n    /* audio track ‚Üì */\n    const mic = await navigator.mediaDevices.getUserMedia({ audio:true });\n    this.pc.addTrack(mic.getTracks()[0]);\n    /* remote audio */\n    const audio = new Audio(); audio.autoplay = true;\n    this.pc.ontrack = e => audio.srcObject = e.streams[0];\n\n    /* data-channel */\n    this.dc = this.pc.createDataChannel(\"oai-events\");\n    this.dc.addEventListener(\"open\",  () => this.flush());\n    this.dc.addEventListener(\"close\", () => console.log(\"dc closed\"));\n    this.dc.addEventListener(\"message\", e => this.onEvent(JSON.parse(e.data)));\n\n    /* SDP dance */\n    const off = await this.pc.createOffer();\n    await this.pc.setLocalDescription(off);\n    const res = await fetch(`https://api.openai.com/v1/realtime`, {\n      method:\"POST\", body:off.sdp,\n      headers:{ Authorization:`Bearer ${token}`, \"Content-Type\":\"application/sdp\" },\n    });\n    await this.pc.setRemoteDescription({ type:\"answer\", sdp: await res.text() });\n  }\n\n  /** Queues if closed, else sends. */\n  send(evt: any) {\n    if (!this.dc || this.dc.readyState !== \"open\") { this.queue.push(evt); return false; }\n    this.dc.send(JSON.stringify(evt)); return true;\n  }\n\n  close() {\n    if (this.dc) this.dc.close();\n    if (this.pc) this.pc.close();\n    this.queue.length = 0;\n  }\n\n  /** internal */\n  private flush() {\n    while (this.queue.length && this.dc?.readyState === \"open\")\n      this.dc.send(JSON.stringify(this.queue.shift()));\n  }\n}",
    "start_line": 3,
    "end_line": 54,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class RtcClient",
    "component_id": "client.realtime.RtcClient.RtcClient"
  },
  "client.realtime.RtcClient.connect": {
    "id": "client.realtime.RtcClient.connect",
    "name": "connect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/RtcClient.ts",
    "relative_path": "client/realtime/RtcClient.ts",
    "depends_on": [],
    "source_code": "async connect(token: string) {\n    this.pc = new RTCPeerConnection();\n    /* audio track ‚Üì */\n    const mic = await navigator.mediaDevices.getUserMedia({ audio:true });\n    this.pc.addTrack(mic.getTracks()[0]);\n    /* remote audio */\n    const audio = new Audio(); audio.autoplay = true;\n    this.pc.ontrack = e => audio.srcObject = e.streams[0];\n\n    /* data-channel */\n    this.dc = this.pc.createDataChannel(\"oai-events\");\n    this.dc.addEventListener(\"open\",  () => this.flush());\n    this.dc.addEventListener(\"close\", () => console.log(\"dc closed\"));\n    this.dc.addEventListener(\"message\", e => this.onEvent(JSON.parse(e.data)));\n\n    /* SDP dance */\n    const off = await this.pc.createOffer();\n    await this.pc.setLocalDescription(off);\n    const res = await fetch(`https://api.openai.com/v1/realtime`, {\n      method:\"POST\", body:off.sdp,\n      headers:{ Authorization:`Bearer ${token}`, \"Content-Type\":\"application/sdp\" },\n    });\n    await this.pc.setRemoteDescription({ type:\"answer\", sdp: await res.text() });\n  }",
    "start_line": 12,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "token"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method connect",
    "component_id": "client.realtime.RtcClient.connect"
  },
  "client.realtime.RtcClient.send": {
    "id": "client.realtime.RtcClient.send",
    "name": "send",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/RtcClient.ts",
    "relative_path": "client/realtime/RtcClient.ts",
    "depends_on": [],
    "source_code": "send(evt: any) {\n    if (!this.dc || this.dc.readyState !== \"open\") { this.queue.push(evt); return false; }\n    this.dc.send(JSON.stringify(evt)); return true;\n  }",
    "start_line": 38,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "evt"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method send",
    "component_id": "client.realtime.RtcClient.send"
  },
  "client.realtime.RtcClient.close": {
    "id": "client.realtime.RtcClient.close",
    "name": "close",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/RtcClient.ts",
    "relative_path": "client/realtime/RtcClient.ts",
    "depends_on": [],
    "source_code": "close() {\n    if (this.dc) this.dc.close();\n    if (this.pc) this.pc.close();\n    this.queue.length = 0;\n  }",
    "start_line": 43,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method close",
    "component_id": "client.realtime.RtcClient.close"
  },
  "client.realtime.RtcClient.flush": {
    "id": "client.realtime.RtcClient.flush",
    "name": "flush",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/RtcClient.ts",
    "relative_path": "client/realtime/RtcClient.ts",
    "depends_on": [],
    "source_code": "private flush() {\n    while (this.queue.length && this.dc?.readyState === \"open\")\n      this.dc.send(JSON.stringify(this.queue.shift()));\n  }",
    "start_line": 50,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method flush",
    "component_id": "client.realtime.RtcClient.flush"
  },
  "client.realtime.eventSelectors.latestAssistantText": {
    "id": "client.realtime.eventSelectors.latestAssistantText",
    "name": "latestAssistantText",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/eventSelectors.ts",
    "relative_path": "client/realtime/eventSelectors.ts",
    "depends_on": [
      "client.realtime.types.ClientEvent"
    ],
    "source_code": "latestAssistantText = (evts: ClientEvent[]) =>\n  [...evts]\n    .filter((e): e is ResponseDeltaEvent => e.type === \"response.delta\"\n              && e.delta?.type === \"message\"\n              && e.delta?.content?.[0]?.type === \"text\")\n    .sort((a,b)=> new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())[0]",
    "start_line": 3,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "evts"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function latestAssistantText",
    "component_id": "client.realtime.eventSelectors.latestAssistantText"
  },
  "client.realtime.eventSelectors.functionCallEvents": {
    "id": "client.realtime.eventSelectors.functionCallEvents",
    "name": "functionCallEvents",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/eventSelectors.ts",
    "relative_path": "client/realtime/eventSelectors.ts",
    "depends_on": [
      "client.realtime.types.FunctionCall",
      "client.realtime.types.ClientEvent"
    ],
    "source_code": "functionCallEvents = (evts: ClientEvent[]): FunctionCall[] => {\n  // Accumulate function call arguments across multiple delta events\n  const functionCallMap = new Map<string, { name: string; call_id: string; arguments: string | Record<string, any>; id?: string }>();\n  \n  // Process delta events to accumulate arguments\n  evts.forEach(e => {\n    if (e.type === \"response.delta\" && e.delta?.type === \"function_call\") {\n      const delta = e.delta as FunctionCallDelta;\n      const key = delta.call_id || delta.name;\n      \n      if (!functionCallMap.has(key)) {\n        functionCallMap.set(key, {\n        id: delta.id,\n        call_id: delta.call_id,\n        name: delta.name,\n          arguments: delta.arguments || ''\n        });\n      } else {\n        // Accumulate arguments - only if both are strings\n        const existing = functionCallMap.get(key)!;\n        if (typeof existing.arguments === 'string' && typeof delta.arguments === 'string') {\n          existing.arguments += delta.arguments;\n        } else if (typeof delta.arguments === 'string' && delta.arguments) {\n          // If existing is object but delta is string, replace with accumulated string\n          existing.arguments = (typeof existing.arguments === 'string' ? existing.arguments : '') + delta.arguments;\n        }\n      }\n    }\n  });\n  \n  // Process done events for complete function calls\n  const doneEvents = evts.flatMap(e => {\n    if (e.type === \"response.done\" && e.response?.output) {\n      return e.response.output.filter((o): o is FunctionCall => \n        typeof o === 'object' && 'name' in o && 'call_id' in o\n      );\n    }\n    return [];\n  }); \n  \n  // Combine accumulated deltas with done events, preferring done events for complete data\n  const result: FunctionCall[] = [];\n  \n  // Add done events first (they have complete data)\n  doneEvents.forEach(call => {\n    result.push(call);\n  });\n  \n  // Add accumulated delta events only if not already present in done events\n  functionCallMap.forEach(call => {\n    const alreadyExists = result.some(r => r.call_id === call.call_id);\n    if (!alreadyExists) {\n      result.push(call);\n    }\n  });\n  \n  return result;\n}",
    "start_line": 10,
    "end_line": 67,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "evts"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function functionCallEvents",
    "component_id": "client.realtime.eventSelectors.functionCallEvents"
  },
  "client.realtime.handleFunctionCall.Mutations": {
    "id": "client.realtime.handleFunctionCall.Mutations",
    "name": "Mutations",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/handleFunctionCall.ts",
    "relative_path": "client/realtime/handleFunctionCall.ts",
    "depends_on": [],
    "source_code": "interface Mutations {\n  addNode: (nodeName: string, parentId: string, graph: any, data?: { label?: string; icon?: string; style?: any }) => any;\n  deleteNode: (nodeId: string, graph: any) => any;\n  moveNode: (nodeId: string, newParentId: string, graph: any) => any;\n  addEdge: (edgeId: string, sourceId: string, targetId: string, graph: any, label?: string) => any;\n  deleteEdge: (edgeId: string, graph: any) => any;\n  groupNodes: (nodeIds: string[], parentId: string, groupId: string, graph: any, style?: any, groupIconName?: string) => any;\n  removeGroup: (groupId: string, graph: any) => any;\n  batchUpdate: (operations: any[], graph: any) => any;\n  process_user_requirements?: () => string;\n}",
    "start_line": 5,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Mutations",
    "component_id": "client.realtime.handleFunctionCall.Mutations"
  },
  "client.realtime.handleFunctionCall.FunctionCallHelpers": {
    "id": "client.realtime.handleFunctionCall.FunctionCallHelpers",
    "name": "FunctionCallHelpers",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/handleFunctionCall.ts",
    "relative_path": "client/realtime/handleFunctionCall.ts",
    "depends_on": [
      "client.realtime.handleFunctionCall.Mutations",
      "client.realtime.types.ClientEvent"
    ],
    "source_code": "interface FunctionCallHelpers {\n  elkGraph: any;\n  setElkGraph: (g: any) => void;\n  mutations: Mutations;\n  safeSend: (e: ClientEvent) => void;\n}",
    "start_line": 17,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FunctionCallHelpers",
    "component_id": "client.realtime.handleFunctionCall.FunctionCallHelpers"
  },
  "client.realtime.handleFunctionCall.Window": {
    "id": "client.realtime.handleFunctionCall.Window",
    "name": "Window",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/handleFunctionCall.ts",
    "relative_path": "client/realtime/handleFunctionCall.ts",
    "depends_on": [],
    "source_code": "interface Window {\n    realtimeAgentSendTextMessage?: (message: string) => void;\n  }",
    "start_line": 26,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Window",
    "component_id": "client.realtime.handleFunctionCall.Window"
  },
  "client.realtime.handleFunctionCall.handleFunctionCall": {
    "id": "client.realtime.handleFunctionCall.handleFunctionCall",
    "name": "handleFunctionCall",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/handleFunctionCall.ts",
    "relative_path": "client/realtime/handleFunctionCall.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.graph_helper_functions.batchUpdate",
      "client.utils.chatUtils.addUserDecisionToChat",
      "client.realtime.handleFunctionCall.FunctionCallHelpers",
      "client.utils.graph_helper_functions.moveNode",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.graph_helper_functions.addEdge",
      "client.realtime.safeSend.safeSend",
      "client.utils.graph_helper_functions.groupNodes",
      "client.utils.graph_helper_functions.addNode",
      "scripts.test-vercel-preview.error",
      "client.realtime.types.FunctionCall",
      "client.utils.chatUtils.createFollowupQuestionsToChat",
      "client.utils.graph_helper_functions.removeGroup",
      "client.utils.graph_helper_functions.deleteEdge",
      "client.utils.graph_helper_functions.deleteNode"
    ],
    "source_code": "function handleFunctionCall(\n  call: FunctionCall,\n  helpers: FunctionCallHelpers\n) {\n  // Correct destructuring for call and helpers\n  const { name, arguments: argStr, call_id } = call;\n  const args = typeof argStr === \"string\" ? JSON.parse(argStr) : argStr || {};\n  const { elkGraph, setElkGraph, mutations, safeSend } = helpers;\n\n  // Essential logging only\n\n\n  let result: any = null;\n  // Always start from a deep copy so we never mutate the prev-state object\n  let graphCopy = typeof structuredClone === \"function\"\n    ? structuredClone(elkGraph)\n    : JSON.parse(JSON.stringify(elkGraph));\n  let updated = graphCopy; // Work on the copy\n\n  try {\n    switch (name) {\n      case \"display_elk_graph\":\n        // Nothing to change, just return a fresh copy so React sees a new object\n        // This will be handled by the common result generation below\n        break;\n        \n      case \"log_requirements_and_generate_questions\":\n\n        try {\n          // Validate both requirements and questions\n          if (!args.requirements || !Array.isArray(args.requirements) || args.requirements.length === 0) {\n            console.error('‚ùå Invalid or empty requirements array');\n            result = { success: false, message: 'Error: requirements must be a non-empty array' };\n          } else if (!args.questions || !Array.isArray(args.questions) || args.questions.length === 0) {\n            console.error('‚ùå Invalid or empty questions array');\n            result = { success: false, message: 'Error: questions must be a non-empty array' };\n          } else {\n            // Log each requirement to create UI components\n            for (const requirement of args.requirements) {\n              addUserDecisionToChat(requirement);\n            }\n            // Generate follow-up questions UI\n            result = createFollowupQuestionsToChat(args.questions);\n          }\n\n          // Store requirements and questions in the graph metadata\n          updated.metadata = updated.metadata || {};\n          updated.metadata.requirements = args.requirements || [];\n          updated.metadata.questions = args.questions || [];\n        } catch (err) {\n          // Catch any unexpected errors and send to agent\n          console.error('‚ùå Exception in log_requirements_and_generate_questions:', err);\n          result = { success: false, message: `Exception: ${err instanceof Error ? err.message : String(err)}` };\n        }\n        // Log the result before sending\n\n        // Send response and return early to prevent graph update\n        safeSend({\n          type: \"conversation.item.create\",\n          item: {\n            type: \"function_call_output\",\n            call_id: call_id,\n            output: JSON.stringify(result)\n          }\n        });\n        return; // Return early to prevent graph update\n        break;\n        \n      case \"add_node\":\n        updated = mutations.addNode(args.nodename, args.parentId, graphCopy, args.data);\n        console.log(`üü¢ Added node '${args.nodename}' to parent '${args.parentId}'${args.data ? ' with data' : ''}`);\n        break;\n        \n      case \"delete_node\":\n        updated = mutations.deleteNode(args.nodeId, graphCopy);\n        console.log(`üî¥ Deleted node '${args.nodeId}'`);\n        break;\n        \n      case \"move_node\":\n        updated = mutations.moveNode(args.nodeId, args.newParentId, graphCopy);\n        console.log(`üîÑ Moved node '${args.nodeId}' to parent '${args.newParentId}'`);\n        break;\n        \n      case \"add_edge\":\n        updated = mutations.addEdge(args.edgeId, args.sourceId, args.targetId, graphCopy, args.label);\n        console.log(`‚û°Ô∏è Added edge '${args.edgeId}' from '${args.sourceId}' to '${args.targetId}'`);\n        break;\n        \n      case \"delete_edge\":\n        updated = mutations.deleteEdge(args.edgeId, graphCopy);\n        console.log(`‚úÇÔ∏è Deleted edge '${args.edgeId}'`);\n        break;\n        \n      case \"group_nodes\":\n        console.log('üîç group_nodes arguments received:', args);\n        \n        // Validate required parameters before calling the function\n        if (!args.nodeIds || !Array.isArray(args.nodeIds) || args.nodeIds.length === 0) {\n          throw new Error(`group_nodes requires 'nodeIds' as a non-empty array, got: ${JSON.stringify(args.nodeIds)}`);\n        }\n        if (!args.parentId || typeof args.parentId !== 'string') {\n          throw new Error(`group_nodes requires 'parentId' as a string, got: ${JSON.stringify(args.parentId)}`);\n        }\n        if (!args.groupId || typeof args.groupId !== 'string') {\n          throw new Error(`group_nodes requires 'groupId' as a string, got: ${JSON.stringify(args.groupId)}`);\n        }\n        if (!args.groupIconName || typeof args.groupIconName !== 'string') {\n          throw new Error(`group_nodes requires 'groupIconName' as a string for proper cloud provider styling, got: ${JSON.stringify(args.groupIconName)}`);\n        }\n        \n        updated = mutations.groupNodes(args.nodeIds, args.parentId, args.groupId, graphCopy, undefined, args.groupIconName);\n        console.log(`üì¶ Grouped nodes [${args.nodeIds.join(', ')}] into '${args.groupId}' under '${args.parentId}' with group icon: ${args.groupIconName}`);\n        break;\n        \n      case \"remove_group\":\n        updated = mutations.removeGroup(args.groupId, graphCopy);\n        console.log(`üì≠ Removed group '${args.groupId}'`);\n        break;\n        \n      case \"batch_update\":\n        // Debug logging to see what's being passed\n\n        \n        // Quick validation\n        if (args.id || args.children || args.edges) {\n          console.error('‚ùå batch_update received a graph object instead of operations array');\n          console.error('‚ùå Received object with keys:', Object.keys(args));\n          console.error('‚ùå Expected: { operations: [...] }');\n          throw new Error(`batch_update requires an object with an 'operations' array. You passed a graph object instead. Please use: batch_update({ operations: [...] })`);\n        }\n        \n        if (!args.operations) {\n          console.error('‚ùå batch_update missing operations parameter');\n          throw new Error(`batch_update requires an 'operations' array. Example: batch_update({ operations: [{ name: \"add_node\", ... }] })`);\n        }\n        \n        if (!Array.isArray(args.operations)) {\n          console.error('‚ùå batch_update operations is not an array:', typeof args.operations);\n          throw new Error(`batch_update 'operations' must be an array. Got ${typeof args.operations}. Example: batch_update({ operations: [{ name: \"add_node\", ... }] })`);\n        }\n        \n        // Validate operations\n        args.operations.forEach((op, index) => {\n          if (!op.name) {\n            throw new Error(`Operation at index ${index} is missing required 'name' field`);\n          }\n          if (!['add_node', 'delete_node', 'move_node', 'add_edge', 'delete_edge', 'group_nodes', 'remove_group'].includes(op.name)) {\n            throw new Error(`Operation at index ${index} has invalid name '${op.name}'. Must be one of: add_node, delete_node, move_node, add_edge, delete_edge, group_nodes, remove_group`);\n          }\n        });\n        \n        if (!updated || !updated.id) {\n          console.error('‚ùå Invalid graph state detected');\n          throw new Error(`Invalid graph state: graph must have an 'id' property`);\n        }\n        \n        updated = mutations.batchUpdate(args.operations, graphCopy);\n\n        break;\n        \n      default:\n        console.warn(`‚ö†Ô∏è Unknown function call: ${name}`);\n        result = { success: false, message: `Unknown function: ${name}` };\n        safeSend({\n          type: \"conversation.item.create\",\n          item: {\n            type: \"function_call_output\",\n            call_id: call_id,\n            output: JSON.stringify(result)\n          }\n        });\n        return;\n    }\n\n    // Helper function to recursively collect all nodes\n    const collectAllNodes = (node: any, parentId: string = 'root'): any[] => {\n      const nodes = [];\n      if (node.children) {\n        for (const child of node.children) {\n          nodes.push({\n            id: child.id,\n            label: child.label || child.id,\n            icon: child.icon,\n            parentId: parentId,\n            hasChildren: child.children && child.children.length > 0\n          });\n          // Recursively collect nested nodes\n          nodes.push(...collectAllNodes(child, child.id));\n        }\n      }\n      return nodes;\n    };\n    \n    // Helper function to recursively collect all edges\n    const collectAllEdges = (node: any): any[] => {\n      const edges = [];\n      if (node.edges) {\n        for (const edge of node.edges) {\n          edges.push({\n            id: edge.id,\n            source: edge.source,\n            target: edge.target,\n            label: edge.label || ''\n          });\n        }\n      }\n      if (node.children) {\n        for (const child of node.children) {\n          edges.push(...collectAllEdges(child));\n        }\n      }\n      return edges;\n    };\n    \n    // Create detailed result with graph information for the agent\n    const allNodes = collectAllNodes(updated);\n    const allEdges = collectAllEdges(updated);\n    \n    const graphSummary = {\n      nodeCount: allNodes.length,\n      edgeCount: allEdges.length,\n      nodes: allNodes,\n      edges: allEdges\n    };\n    \n    // Create comprehensive result object - SUCCESS CASE\n    result = {\n      success: true,\n      operation: name,\n      message: `${name} completed successfully. Graph now has ${graphSummary.nodeCount} nodes and ${graphSummary.edgeCount} edges.`,\n      graphInfo: {\n        nodeCount: graphSummary.nodeCount,\n        edgeCount: graphSummary.edgeCount,\n        note: \"This is informational only - do NOT pass this object to batch_update or other functions\"\n      },\n      summary: {\n        totalNodes: graphSummary.nodeCount,\n        totalEdges: graphSummary.edgeCount,\n        nodesList: graphSummary.nodes.map(n => `${n.id} (${n.icon || 'no-icon'})`).join(', '),\n        edgesList: graphSummary.edges.map(e => `${e.source} ‚Üí ${e.target}${e.label ? ` (${e.label})` : ''}`).join(', ')\n      }\n    };\n    \n    // Update graph state\n\n    setElkGraph(updated);\n\n    \n    // Send the result back to the agent\n    safeSend({\n      type: \"conversation.item.create\",\n      item: {\n        type: \"function_call_output\",\n        call_id: call_id,\n        output: JSON.stringify(result)\n      }\n    });\n  } catch (err) {\n    // Log any unexpected errors in the main handler\n    console.error('‚ùå Exception in handleFunctionCall:', err);\n    \n    // Create detailed error result for the agent\n    const errorMessage = err instanceof Error ? err.message : String(err);\n    \n    // Add specific guidance for different types of batch_update errors\n    let specificGuidance = '';\n    if (name === 'batch_update') {\n      if (errorMessage.includes('graph object')) {\n      specificGuidance = '\\n\\nüî• CRITICAL: You MUST use the operations array format:\\nbatch_update({ operations: [{ name: \"add_node\", nodename: \"my-node\", parentId: \"root\" }] })\\n\\nNEVER pass graph objects like { id: \"...\", children: [...] }!';\n      } else if (errorMessage.includes('Common ancestor not found')) {\n        specificGuidance = '\\n\\nüî• EDGE ERROR: Cannot create edge between nodes that do not share a common parent container.\\n\\n' +\n          'üîß SOLUTION: Before adding an edge, ensure both source and target nodes exist and are in related containers.\\n' +\n          '‚úÖ CORRECT APPROACH:\\n' +\n          '1. First add both nodes\\n' +\n          '2. Group related nodes into the same container if needed\\n' +\n          '3. Then add edges between nodes that share a common ancestor\\n\\n' +\n          '‚ùå AVOID: Adding edges between nodes in completely separate, unrelated containers.';\n      }\n    }\n    \n    result = { \n      success: false, \n      operation: name,\n      error: errorMessage,\n      message: `‚ùå OPERATION FAILED: ${name} - ${errorMessage}${specificGuidance}`,\n      details: `The operation '${name}' could not be completed. Please check the error message and retry with corrected parameters.`,\n      retry_instructions: specificGuidance ? \"Please follow the guidance above and retry the operation.\" : \"Please correct the parameters and retry.\"\n    };\n    \n    safeSend({\n      type: \"conversation.item.create\",\n      item: {\n        type: \"function_call_output\",\n        call_id: call_id,\n        output: JSON.stringify(result)\n      }\n    });\n    return;\n  }\n}",
    "start_line": 31,
    "end_line": 330,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "call",
      "helpers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handleFunctionCall",
    "component_id": "client.realtime.handleFunctionCall.handleFunctionCall"
  },
  "client.realtime.initSession.initSession": {
    "id": "client.realtime.initSession.initSession",
    "name": "initSession",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/initSession.ts",
    "relative_path": "client/realtime/initSession.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.realtime.toolCatalog.toolPages",
      "client.realtime.safeSend.safeSend",
      "client.realtime.types.SessionConfig",
      "scripts.test-vercel-preview.error",
      "client.realtime.types.InputTextContent",
      "client.realtime.types.ClientEvent"
    ],
    "source_code": "function initSession(\n  events: any[],\n  safeSend: (e: ClientEvent) => void,\n  elkGraphDescription: string,\n  config?: SessionConfig\n) {\n  // Check for session.created event specifically (not just any event)\n  const sessionCreatedEvent = events.find((e) => e.type === \"session.created\");\n  if (!sessionCreatedEvent) {\n    console.error(\"‚ùå Cannot initialize session: No session.created event found\");\n    return false; // caller will know it did nothing\n  }\n\n  // Enforce non-empty elkGraphDescription with more detailed error\n  if (!elkGraphDescription || elkGraphDescription.trim() === '') {\n    console.error('‚ùå Cannot initialize session: elkGraphDescription must be provided');\n    return false;\n  }\n\n  // Minimal logging - just note that we're initializing\n  console.log(\"üöÄ Initializing session\");\n  \n  // Apply simplified session configuration if provided\n  if (config) {\n    const sessionConfig: Partial<SessionConfig> = {};\n    \n    // Add the core configuration options\n    if (config.language) sessionConfig.language = config.language;\n    if (config.temperature) sessionConfig.temperature = config.temperature;\n    if (config.model) sessionConfig.model = config.model;\n    if (config.instructions) sessionConfig.instructions = config.instructions;\n    \n    // Send initial session configuration\n    safeSend({ \n      type: \"session.update\", \n      session: sessionConfig\n    });\n  }\n  \n  // Send tool configuration - suppress individual page logs\n  const toolPageCount = toolPages().length;\n  toolPages().forEach((page, i, arr) => {\n    safeSend({ \n      type: \"session.update\", \n      session: { \n        tools: page,\n        tool_choice: \"auto\"\n      } \n    });\n  });\n\n  // If language is provided, include instructions to use that language\n  const languageInstruction = config?.language ? \n    `You must respond only in ${config.language}. Do not switch to any other language.` : '';\n\n  const content: InputTextContent = {\n    type: \"input_text\",\n    text: `\n      ${languageInstruction}\n      ${elkGraphDescription}\n    `\n  };\n\n  // Send instructions and create response without logging each step\n  safeSend({\n    type: \"conversation.item.create\",\n    item: {\n      type: \"message\",\n      role: \"user\",\n      content: [{\n        type: \"input_text\",\n        text: `${languageInstruction}\n               ${elkGraphDescription}\n\n              Please greet the user with exactly 'How can I help?' and nothing else. Do not add any additional text or explanation.`\n      }]\n    }\n  });\n\n  // Create single response to trigger the greeting\n  console.log(\"initSession: sending greet instruction\");\n  safeSend({ type: \"response.create\" });\n  \n  return true;\n}",
    "start_line": 5,
    "end_line": 89,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "events",
      "safeSend",
      "elkGraphDescription",
      "config"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function initSession",
    "component_id": "client.realtime.initSession.initSession"
  },
  "client.realtime.safeSend.safeSend": {
    "id": "client.realtime.safeSend.safeSend",
    "name": "safeSend",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/safeSend.ts",
    "relative_path": "client/realtime/safeSend.ts",
    "depends_on": [
      "client.realtime.types.SendStatus",
      "client.realtime.types.ClientEvent",
      "client.realtime.RtcClient.send"
    ],
    "source_code": "function safeSend(\n  send: ((e: ClientEvent) => void) | undefined,\n  setStatus: Dispatch<SetStateAction<SendStatus>>,\n) {\n  return (evt: ClientEvent) => {\n    if (!send) return;\n    setStatus(s => ({ ...s, sending: true }));\n    try {\n      send(evt);\n      setStatus(s => ({ ...s, sending: false, retrying: false, retryCount: 0, lastError: null }));\n    } catch (err) {\n      setStatus(s => ({\n        ...s,\n        sending: false,\n        retrying: true,\n        retryCount: s.retryCount + 1,\n        lastError: err as Error,\n      }));\n    }\n  };\n}",
    "start_line": 4,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "send",
      "setStatus"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function safeSend",
    "component_id": "client.realtime.safeSend.safeSend"
  },
  "client.realtime.toolCatalog.toolPages": {
    "id": "client.realtime.toolCatalog.toolPages",
    "name": "toolPages",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/toolCatalog.ts",
    "relative_path": "client/realtime/toolCatalog.ts",
    "depends_on": [
      "client.utils.splitTools.chunkTools"
    ],
    "source_code": "function toolPages() {\n  return chunkTools(allTools);\n}",
    "start_line": 306,
    "end_line": 308,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toolPages",
    "component_id": "client.realtime.toolCatalog.toolPages"
  },
  "client.realtime.types.EventType": {
    "id": "client.realtime.types.EventType",
    "name": "EventType",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "type EventType = \n  | 'session.created'\n  | 'session.update'\n  | 'conversation.item.create'\n  | 'response.delta'\n  | 'response.done'\n  | 'response.create';",
    "start_line": 2,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EventType",
    "component_id": "client.realtime.types.EventType"
  },
  "client.realtime.types.TextContent": {
    "id": "client.realtime.types.TextContent",
    "name": "TextContent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface TextContent {\n  type: 'text';\n  text: string;\n}",
    "start_line": 11,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface TextContent",
    "component_id": "client.realtime.types.TextContent"
  },
  "client.realtime.types.InputTextContent": {
    "id": "client.realtime.types.InputTextContent",
    "name": "InputTextContent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface InputTextContent {\n  type: 'input_text';\n  text: string;\n}",
    "start_line": 16,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InputTextContent",
    "component_id": "client.realtime.types.InputTextContent"
  },
  "client.realtime.types.MessageContent": {
    "id": "client.realtime.types.MessageContent",
    "name": "MessageContent",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "type MessageContent = TextContent | InputTextContent;",
    "start_line": 21,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type MessageContent",
    "component_id": "client.realtime.types.MessageContent"
  },
  "client.realtime.types.Message": {
    "id": "client.realtime.types.Message",
    "name": "Message",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [
      "client.realtime.types.MessageContent"
    ],
    "source_code": "interface Message {\n  type: 'message';\n  role: 'user' | 'assistant' | 'system';\n  content: MessageContent[];\n}",
    "start_line": 24,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Message",
    "component_id": "client.realtime.types.Message"
  },
  "client.realtime.types.FunctionCallOutput": {
    "id": "client.realtime.types.FunctionCallOutput",
    "name": "FunctionCallOutput",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface FunctionCallOutput {\n  type: 'function_call_output';\n  call_id: string;\n  output: string;\n}",
    "start_line": 30,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FunctionCallOutput",
    "component_id": "client.realtime.types.FunctionCallOutput"
  },
  "client.realtime.types.FunctionCall": {
    "id": "client.realtime.types.FunctionCall",
    "name": "FunctionCall",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface FunctionCall {\n  id?: string;\n  call_id: string;\n  name: string;\n  arguments: string | Record<string, any>;\n  result?: any;\n}",
    "start_line": 37,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FunctionCall",
    "component_id": "client.realtime.types.FunctionCall"
  },
  "client.realtime.types.SessionConfig": {
    "id": "client.realtime.types.SessionConfig",
    "name": "SessionConfig",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface SessionConfig {\n  language?: string;\n  temperature?: number;\n  model?: string;\n  instructions?: string;\n  tools?: any[];\n  tool_choice?: 'auto' | 'none';\n}",
    "start_line": 46,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SessionConfig",
    "component_id": "client.realtime.types.SessionConfig"
  },
  "client.realtime.types.MessageDelta": {
    "id": "client.realtime.types.MessageDelta",
    "name": "MessageDelta",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [
      "client.realtime.types.MessageContent"
    ],
    "source_code": "interface MessageDelta {\n  type: 'message';\n  content: MessageContent[];\n}",
    "start_line": 56,
    "end_line": 59,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface MessageDelta",
    "component_id": "client.realtime.types.MessageDelta"
  },
  "client.realtime.types.FunctionCallDelta": {
    "id": "client.realtime.types.FunctionCallDelta",
    "name": "FunctionCallDelta",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface FunctionCallDelta {\n  type: 'function_call';\n  id?: string;\n  call_id: string;\n  name: string;\n  arguments: string | Record<string, any>;\n}",
    "start_line": 61,
    "end_line": 67,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface FunctionCallDelta",
    "component_id": "client.realtime.types.FunctionCallDelta"
  },
  "client.realtime.types.DeltaType": {
    "id": "client.realtime.types.DeltaType",
    "name": "DeltaType",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "type DeltaType = MessageDelta | FunctionCallDelta;",
    "start_line": 69,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type DeltaType",
    "component_id": "client.realtime.types.DeltaType"
  },
  "client.realtime.types.SessionCreatedEvent": {
    "id": "client.realtime.types.SessionCreatedEvent",
    "name": "SessionCreatedEvent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface SessionCreatedEvent {\n  type: 'session.created';\n  timestamp: string;\n}",
    "start_line": 72,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SessionCreatedEvent",
    "component_id": "client.realtime.types.SessionCreatedEvent"
  },
  "client.realtime.types.SessionUpdateEvent": {
    "id": "client.realtime.types.SessionUpdateEvent",
    "name": "SessionUpdateEvent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [
      "client.realtime.types.SessionConfig"
    ],
    "source_code": "interface SessionUpdateEvent {\n  type: 'session.update';\n  session: Partial<SessionConfig>;\n}",
    "start_line": 77,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SessionUpdateEvent",
    "component_id": "client.realtime.types.SessionUpdateEvent"
  },
  "client.realtime.types.ConversationItemEvent": {
    "id": "client.realtime.types.ConversationItemEvent",
    "name": "ConversationItemEvent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [
      "client.realtime.types.FunctionCallOutput",
      "client.realtime.types.Message"
    ],
    "source_code": "interface ConversationItemEvent {\n  type: 'conversation.item.create';\n  item: Message | FunctionCallOutput;\n}",
    "start_line": 82,
    "end_line": 85,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ConversationItemEvent",
    "component_id": "client.realtime.types.ConversationItemEvent"
  },
  "client.realtime.types.ResponseDeltaEvent": {
    "id": "client.realtime.types.ResponseDeltaEvent",
    "name": "ResponseDeltaEvent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [
      "client.realtime.types.DeltaType"
    ],
    "source_code": "interface ResponseDeltaEvent {\n  type: 'response.delta';\n  event_id: string;\n  timestamp: string;\n  delta: DeltaType;\n}",
    "start_line": 87,
    "end_line": 92,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResponseDeltaEvent",
    "component_id": "client.realtime.types.ResponseDeltaEvent"
  },
  "client.realtime.types.ResponseDoneEvent": {
    "id": "client.realtime.types.ResponseDoneEvent",
    "name": "ResponseDoneEvent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [
      "client.realtime.types.FunctionCall",
      "client.realtime.types.Message"
    ],
    "source_code": "interface ResponseDoneEvent {\n  type: 'response.done';\n  timestamp: string;\n  response: {\n    output: (Message | FunctionCall)[];\n  };\n}",
    "start_line": 94,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResponseDoneEvent",
    "component_id": "client.realtime.types.ResponseDoneEvent"
  },
  "client.realtime.types.ResponseCreateEvent": {
    "id": "client.realtime.types.ResponseCreateEvent",
    "name": "ResponseCreateEvent",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface ResponseCreateEvent {\n  type: 'response.create';\n}",
    "start_line": 102,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ResponseCreateEvent",
    "component_id": "client.realtime.types.ResponseCreateEvent"
  },
  "client.realtime.types.ClientEvent": {
    "id": "client.realtime.types.ClientEvent",
    "name": "ClientEvent",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "type ClientEvent =\n  | SessionCreatedEvent\n  | SessionUpdateEvent\n  | ConversationItemEvent\n  | ResponseDeltaEvent\n  | ResponseDoneEvent\n  | ResponseCreateEvent;",
    "start_line": 107,
    "end_line": 113,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ClientEvent",
    "component_id": "client.realtime.types.ClientEvent"
  },
  "client.realtime.types.SendStatus": {
    "id": "client.realtime.types.SendStatus",
    "name": "SendStatus",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [],
    "source_code": "interface SendStatus {\n  sending: boolean;\n  retrying: boolean;\n  retryCount: number;\n  lastError: Error | null;\n}",
    "start_line": 116,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SendStatus",
    "component_id": "client.realtime.types.SendStatus"
  },
  "client.realtime.types.EventCallback": {
    "id": "client.realtime.types.EventCallback",
    "name": "EventCallback",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/realtime/types.ts",
    "relative_path": "client/realtime/types.ts",
    "depends_on": [
      "client.realtime.types.ClientEvent"
    ],
    "source_code": "type EventCallback = (event: ClientEvent) => void;",
    "start_line": 124,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EventCallback",
    "component_id": "client.realtime.types.EventCallback"
  },
  "client.renderer.ReactFlowAdapter.toReactFlowWithViewState": {
    "id": "client.renderer.ReactFlowAdapter.toReactFlowWithViewState",
    "name": "toReactFlowWithViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/renderer/ReactFlowAdapter.ts",
    "relative_path": "client/renderer/ReactFlowAdapter.ts",
    "depends_on": [
      "client.viewstate.ViewState.requireGeometry",
      "client.viewstate.ViewState.ViewState",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.renderer.types.NodeDimensions",
      "client.components.graph.utils.toReactFlow.processLayoutedGraph",
      "client.renderer.types.ReactFlowAdapterOptions"
    ],
    "source_code": "function toReactFlowWithViewState(\n  elkGraph: any,\n  dimensions: NodeDimensions,\n  viewState: ViewState,\n  options?: ReactFlowAdapterOptions\n): { nodes: Node[]; edges: Edge[] } {\n  const strictGeometry = options?.strictGeometry ?? true;\n\n  // First, get ReactFlow nodes/edges from ELK (for structure, handles, edge routing)\n  const { nodes: elkNodes, edges: elkEdges } = processLayoutedGraph(elkGraph, dimensions);\n\n  // Override all node positions from ViewState (enforce contract)\n  const nodes = elkNodes.map((node) => {\n    const nodeId = node.id;\n    const isGroup = node.type === 'group';\n\n    if (strictGeometry && process.env.NODE_ENV !== 'production') {\n      // Enforce: geometry must exist in ViewState\n      try {\n        requireGeometry(isGroup ? 'group' : 'node', nodeId, viewState);\n      } catch (error) {\n        // Re-throw with more context\n        throw new Error(\n          `[ReactFlowAdapter] Missing ViewState geometry for ${isGroup ? 'group' : 'node'} \"${nodeId}\". ` +\n          `This violates the ViewState-first contract. ` +\n          `Ensure Layout or Orchestration has written geometry before rendering.`,\n          { cause: error }\n        );\n      }\n    }\n\n    // Get geometry from ViewState (source of truth)\n    const geometry = isGroup\n      ? viewState.group?.[nodeId]\n      : viewState.node?.[nodeId];\n\n    if (geometry) {\n      // Override position from ViewState\n      return {\n        ...node,\n        position: {\n          x: geometry.x,\n          y: geometry.y,\n        },\n        // Update data.position if it exists\n        data: {\n          ...node.data,\n          position: { x: geometry.x, y: geometry.y },\n        },\n      };\n    }\n\n    // Fallback: use ELK position (only if strictGeometry is false)\n    if (!strictGeometry) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          `[ReactFlowAdapter] Using ELK position for ${isGroup ? 'group' : 'node'} \"${nodeId}\" ` +\n          `(ViewState missing, strictGeometry=false)`\n        );\n      }\n      return node;\n    }\n\n    // Strict mode: should have thrown above, but if we get here, use safe default\n    return {\n      ...node,\n      position: { x: 0, y: 0 },\n    };\n  });\n\n  // Override edge waypoints from ViewState if available\n  const edges = elkEdges.map((edge) => {\n    const edgeId = edge.id;\n    const edgeGeom = viewState.edge?.[edgeId];\n\n    if (edgeGeom?.waypoints && Array.isArray(edgeGeom.waypoints)) {\n      // Use ViewState waypoints (manual routing in FREE mode)\n      return {\n        ...edge,\n        data: {\n          ...edge.data,\n          bendPoints: edgeGeom.waypoints,\n        },\n      };\n    }\n\n    // Use ELK waypoints (from processLayoutedGraph)\n    return edge;\n  });\n\n  return { nodes, edges };\n}",
    "start_line": 30,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "elkGraph",
      "dimensions",
      "viewState",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toReactFlowWithViewState",
    "component_id": "client.renderer.ReactFlowAdapter.toReactFlowWithViewState"
  },
  "client.renderer.types.NodeDimensions": {
    "id": "client.renderer.types.NodeDimensions",
    "name": "NodeDimensions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/renderer/types.ts",
    "relative_path": "client/renderer/types.ts",
    "depends_on": [],
    "source_code": "interface NodeDimensions {\n  width: number;\n  height: number;\n  groupWidth: number;\n  groupHeight: number;\n  padding: number;\n}",
    "start_line": 6,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeDimensions",
    "component_id": "client.renderer.types.NodeDimensions"
  },
  "client.renderer.types.ReactFlowAdapterOptions": {
    "id": "client.renderer.types.ReactFlowAdapterOptions",
    "name": "ReactFlowAdapterOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/renderer/types.ts",
    "relative_path": "client/renderer/types.ts",
    "depends_on": [],
    "source_code": "interface ReactFlowAdapterOptions {\n  /**\n   * If true, throw in dev mode when ViewState geometry is missing\n   * @default true\n   */\n  strictGeometry?: boolean;\n}",
    "start_line": 14,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ReactFlowAdapterOptions",
    "component_id": "client.renderer.types.ReactFlowAdapterOptions"
  },
  "client.scripts.generateIconList.IconInfo": {
    "id": "client.scripts.generateIconList.IconInfo",
    "name": "IconInfo",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/scripts/generateIconList.ts",
    "relative_path": "client/scripts/generateIconList.ts",
    "depends_on": [],
    "source_code": "interface IconInfo {\n  name: string;\n  category: string;\n  provider: string;\n  path: string;\n}",
    "start_line": 4,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IconInfo",
    "component_id": "client.scripts.generateIconList.IconInfo"
  },
  "client.scripts.generateIconList.IconLists": {
    "id": "client.scripts.generateIconList.IconLists",
    "name": "IconLists",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/scripts/generateIconList.ts",
    "relative_path": "client/scripts/generateIconList.ts",
    "depends_on": [],
    "source_code": "interface IconLists {\n  aws: { [category: string]: string[] };\n  gcp: { [category: string]: string[] };\n  azure: { [category: string]: string[] };\n  generic: string[];\n  all: string[];\n}",
    "start_line": 11,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IconLists",
    "component_id": "client.scripts.generateIconList.IconLists"
  },
  "client.scripts.generateIconList.scanDirectory": {
    "id": "client.scripts.generateIconList.scanDirectory",
    "name": "scanDirectory",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/scripts/generateIconList.ts",
    "relative_path": "client/scripts/generateIconList.ts",
    "depends_on": [
      "client.scripts.generateIconList.scanDirectory"
    ],
    "source_code": "function scanDirectory(dir: string): string[] {\n  const icons: string[] = [];\n  \n  if (!fs.existsSync(dir)) {\n    return icons;\n  }\n  \n  const files = fs.readdirSync(dir);\n  \n  for (const file of files) {\n    const filePath = path.join(dir, file);\n    const stat = fs.statSync(filePath);\n    \n    if (stat.isDirectory()) {\n      // Recursively scan subdirectories\n      icons.push(...scanDirectory(filePath));\n    } else if (file.endsWith('.png')) {\n      // Add PNG file without extension\n      icons.push(path.basename(file, '.png'));\n    }\n  }\n  \n  return icons;\n}",
    "start_line": 22,
    "end_line": 45,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dir"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function scanDirectory",
    "component_id": "client.scripts.generateIconList.scanDirectory"
  },
  "client.scripts.generateIconList.generateIconLists": {
    "id": "client.scripts.generateIconList.generateIconLists",
    "name": "generateIconLists",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/scripts/generateIconList.ts",
    "relative_path": "client/scripts/generateIconList.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.scripts.generateIconList.IconLists",
      "client.scripts.generateIconList.scanDirectory"
    ],
    "source_code": "function generateIconLists(): IconLists {\n  const iconLists: IconLists = {\n    aws: {},\n    gcp: {},\n    azure: {},\n    generic: [],\n    all: []\n  };\n  \n  const baseDir = path.join(process.cwd(), 'client/public/icons');\n  const providers = ['aws', 'gcp', 'azure'];\n  \n  for (const provider of providers) {\n    const providerDir = path.join(baseDir, provider);\n    \n    if (!fs.existsSync(providerDir)) {\n      console.warn(`Provider directory not found: ${providerDir}`);\n      continue;\n    }\n    \n    const categories = fs.readdirSync(providerDir).filter(item => {\n      const itemPath = path.join(providerDir, item);\n      return fs.statSync(itemPath).isDirectory();\n    });\n    \n    for (const category of categories) {\n      const categoryDir = path.join(providerDir, category);\n      const icons = scanDirectory(categoryDir);\n      \n      if (icons.length > 0) {\n        iconLists[provider as keyof typeof iconLists][category] = icons.sort();\n        iconLists.all.push(...icons);\n      }\n    }\n  }\n  \n  // Scan generic icons from the canvas directory\n  const canvasDir = path.join(process.cwd(), 'client/public/assets/canvas');\n  if (fs.existsSync(canvasDir)) {\n    const canvasFiles = fs.readdirSync(canvasDir).filter(file => {\n      const filePath = path.join(canvasDir, file);\n      return fs.statSync(filePath).isFile() && (file.endsWith('.png') || file.endsWith('.svg') || file.endsWith('.jpeg'));\n    });\n    \n    iconLists.generic = canvasFiles.map(file => {\n      // Remove file extension to get icon name\n      return file.replace(/\\.(png|svg|jpeg)$/, '');\n    }).filter((icon, index, array) => array.indexOf(icon) === index).sort(); // Remove duplicates and sort\n    \n    console.log(`üì¶ Found ${iconLists.generic.length} generic icons in canvas directory`);\n    iconLists.all.push(...iconLists.generic);\n  }\n  \n  // Remove duplicates and sort the combined list\n  iconLists.all = Array.from(new Set(iconLists.all)).sort();\n  \n  return iconLists;\n}",
    "start_line": 50,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateIconLists",
    "component_id": "client.scripts.generateIconList.generateIconLists"
  },
  "client.scripts.generateIconList.generateIconListsFile": {
    "id": "client.scripts.generateIconList.generateIconListsFile",
    "name": "generateIconListsFile",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/scripts/generateIconList.ts",
    "relative_path": "client/scripts/generateIconList.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.scripts.generateIconList.IconLists"
    ],
    "source_code": "function generateIconListsFile(iconLists: IconLists): void {\n  const outputDir = path.join(process.cwd(), 'client/generated');\n  const outputFile = path.join(outputDir, 'iconLists.ts');\n  \n  // Ensure output directory exists\n  if (!fs.existsSync(outputDir)) {\n    fs.mkdirSync(outputDir, { recursive: true });\n  }\n  \n  // Create provider-prefixed icon lists for clear identification\n  const awsIconsFlat = Object.values(iconLists.aws).flat().map(icon => `aws_${icon}`);\n  const gcpIconsFlat = Object.values(iconLists.gcp).flat().map(icon => `gcp_${icon}`);\n  const azureIconsFlat = Object.values(iconLists.azure).flat().map(icon => `azure_${icon}`);\n  const genericIcons = iconLists.generic; // Generic icons don't need prefix\n  const allPrefixedIcons = [...awsIconsFlat, ...gcpIconsFlat, ...azureIconsFlat, ...genericIcons].sort();\n  \n  const tsContent = `// This file is auto-generated by scripts/generateIconList.ts\n// Do not edit manually - changes will be overwritten\n\nexport interface IconLists {\n  aws: { [category: string]: string[] };\n  gcp: { [category: string]: string[] };\n  azure: { [category: string]: string[] };\n  generic: string[];\n  all: string[];\n}\n\nexport const iconLists: IconLists = ${JSON.stringify(iconLists, null, 2)};\n\n// Provider-prefixed icons for reasoning agent (avoids confusion between providers)\nexport const availableIconsPrefixed = ${JSON.stringify(allPrefixedIcons, null, 2)};\n\n// Original flat list of all available icons (for backward compatibility)\nexport const availableIcons = iconLists.all;\n\n// Provider-specific icon lists\nexport const awsIcons = iconLists.aws;\nexport const gcpIcons = iconLists.gcp;\nexport const azureIcons = iconLists.azure;\nexport const genericIcons = iconLists.generic;\n\n// Helper function to get icons by provider and category\nexport function getIconsByProvider(provider: 'aws' | 'gcp' | 'azure'): { [category: string]: string[] } {\n  return iconLists[provider];\n}\n\n// Helper function to get all icons for a specific category across all providers\nexport function getIconsByCategory(category: string): string[] {\n  const icons: string[] = [];\n  \n  for (const provider of ['aws', 'gcp', 'azure'] as const) {\n    if (iconLists[provider][category]) {\n      icons.push(...iconLists[provider][category]);\n    }\n  }\n  \n  return Array.from(new Set(icons)).sort();\n}\n\n// Helper function to search icons by name\nexport function searchIcons(query: string): string[] {\n  return iconLists.all.filter(icon => \n    icon.toLowerCase().includes(query.toLowerCase())\n  );\n}\n\n// Helper function to get provider-specific prefixed icons\nexport function getProviderPrefixedIcons(provider: 'aws' | 'gcp' | 'azure'): string[] {\n  const providerIcons = Object.values(iconLists[provider]).flat();\n  return providerIcons.map(icon => \\`\\${provider}_\\${icon}\\`).sort();\n}\n\n// Helper function to parse prefixed icon name back to provider and icon\nexport function parseIconName(prefixedIcon: string): { provider: string; icon: string } | null {\n  const match = prefixedIcon.match(/^(aws|gcp|azure)_(.+)$/);\n  return match ? { provider: match[1], icon: match[2] } : null;\n}\n\n// Statistics\nexport const iconStats = {\n  total: iconLists.all.length,\n  aws: Object.values(iconLists.aws).flat().length,\n  gcp: Object.values(iconLists.gcp).flat().length,\n  azure: Object.values(iconLists.azure).flat().length,\n  generic: iconLists.generic.length,\n  categories: {\n    aws: Object.keys(iconLists.aws).length,\n    gcp: Object.keys(iconLists.gcp).length,\n    azure: Object.keys(iconLists.azure).length,\n  }\n};\n`;\n  \n  fs.writeFileSync(outputFile, tsContent);\n  console.log(`‚úÖ Generated icon lists: ${outputFile}`);\n  console.log(`üìä Total icons: ${iconLists.all.length}`);\n  console.log(`   - AWS: ${Object.values(iconLists.aws).flat().length}`);\n  console.log(`   - GCP: ${Object.values(iconLists.gcp).flat().length}`);\n  console.log(`   - Azure: ${Object.values(iconLists.azure).flat().length}`);\n  console.log(`   - Generic: ${iconLists.generic.length}`);\n  console.log(`üè∑Ô∏è  Provider-prefixed icons: ${allPrefixedIcons.length}`);\n}",
    "start_line": 112,
    "end_line": 213,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconLists"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateIconListsFile",
    "component_id": "client.scripts.generateIconList.generateIconListsFile"
  },
  "client.scripts.generateIconList.main": {
    "id": "client.scripts.generateIconList.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/scripts/generateIconList.ts",
    "relative_path": "client/scripts/generateIconList.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.scripts.generateIconList.generateIconLists",
      "client.scripts.generateIconList.generateIconListsFile"
    ],
    "source_code": "function main(): void {\n  console.log('üîç Scanning organized icon directories...');\n  \n  const iconLists = generateIconLists();\n  generateIconListsFile(iconLists);\n  \n  console.log('‚ú® Icon list generation complete!');\n}",
    "start_line": 218,
    "end_line": 225,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "client.scripts.generateIconList.main"
  },
  "client.services.UrlArchitectureService.UrlArchitectureConfig": {
    "id": "client.services.UrlArchitectureService.UrlArchitectureConfig",
    "name": "UrlArchitectureConfig",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "interface UrlArchitectureConfig {\n  isEmbedded: boolean;\n  requiresAuth?: boolean;\n}",
    "start_line": 16,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UrlArchitectureConfig",
    "component_id": "client.services.UrlArchitectureService.UrlArchitectureConfig"
  },
  "client.services.UrlArchitectureService.LoadArchitectureCallback": {
    "id": "client.services.UrlArchitectureService.LoadArchitectureCallback",
    "name": "LoadArchitectureCallback",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [
      "client.services.anonymousArchitectureService.AnonymousArchitecture"
    ],
    "source_code": "interface LoadArchitectureCallback {\n  (architecture: AnonymousArchitecture, source: string): void;\n}",
    "start_line": 21,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface LoadArchitectureCallback",
    "component_id": "client.services.UrlArchitectureService.LoadArchitectureCallback"
  },
  "client.services.UrlArchitectureService.UrlArchitectureServiceDeps": {
    "id": "client.services.UrlArchitectureService.UrlArchitectureServiceDeps",
    "name": "UrlArchitectureServiceDeps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [
      "client.services.UrlArchitectureService.UrlArchitectureConfig",
      "client.services.UrlArchitectureService.LoadArchitectureCallback"
    ],
    "source_code": "interface UrlArchitectureServiceDeps {\n  loadArchitecture: LoadArchitectureCallback;\n  config: UrlArchitectureConfig;\n  currentUser?: {\n    uid: string;\n    email: string | null;\n  } | null;\n  // UI callbacks for direct loading (from InteractiveCanvas)\n  setRawGraph?: (graph: any, source?: string) => void;\n  setCurrentChatName?: (name: string) => void;\n  setSavedArchitectures?: (fn: (prev: any[]) => any[]) => void;\n  setSelectedArchitectureId?: (id: string) => void;\n  viewStateRef?: { current: any };\n  getViewStateSnapshot?: () => any;\n  logPageLoad?: (source: string, graph: any, id: string) => void;\n}",
    "start_line": 25,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface UrlArchitectureServiceDeps",
    "component_id": "client.services.UrlArchitectureService.UrlArchitectureServiceDeps"
  },
  "client.services.UrlArchitectureService.UrlArchitectureService": {
    "id": "client.services.UrlArchitectureService.UrlArchitectureService",
    "name": "UrlArchitectureService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [
      "client.services.anonymousArchitectureService.getArchitectureIdFromUrl",
      "client.services.anonymousArchitectureService.AnonymousArchitecture",
      "client.services.UrlArchitectureService.createArchitectureFromFallback",
      "client.utils.naming.generateNameWithFallback",
      "client.services.architectureService.saveArchitecture",
      "client.services.UrlArchitectureService.processLoadedArchitecture",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.services.UrlArchitectureService.handleChatMessages",
      "client.utils.chatPersistence.normalizeChatMessages",
      "scripts.test-vercel-preview.log",
      "client.services.UrlArchitectureService.mergeArchitectureWithFallback",
      "client.utils.chatPersistence.getCurrentConversation",
      "client.services.UrlArchitectureService.shouldLoadFromUrl",
      "client.utils.viewstateDebug.logPageLoad",
      "client.utils.chatPersistence.mergeChatMessages",
      "client.services.UrlArchitectureService.cleanupFallbackStorage",
      "client.services.UrlArchitectureService.UrlArchitectureServiceDeps",
      "client.services.UrlArchitectureService.processForAuthenticatedUser",
      "client.utils.chatPersistence.isEmbedToCanvasTransition",
      "client.services.UrlArchitectureService.loadSharedAnonymousArchitecture",
      "client.services.anonymousArchitectureService.loadAnonymousArchitectureById",
      "client.services.UrlArchitectureService.createDefaultArchitecture",
      "client.utils.chatPersistence.getChatMessages",
      "scripts.test-vercel-preview.error",
      "client.utils.copyToClipboard.isEmbedded"
    ],
    "source_code": "class UrlArchitectureService {\n  private deps: UrlArchitectureServiceDeps;\n\n  constructor(deps: UrlArchitectureServiceDeps) {\n    this.deps = deps;\n  }\n\n  /**\n   * MAIN ENTRY POINT: Check for URL architecture and load if appropriate\n   * \n   * PRIORITY LOGIC:\n   * 1. If localStorage exists (even empty) ‚Üí Skip URL loading\n   * 2. If no localStorage ‚Üí Load from URL/Firebase\n   */\n  async checkAndLoadUrlArchitecture(): Promise<boolean> {\n    console.log('[üîÑ URL-ARCH-SERVICE] Starting URL architecture check');\n\n    // Short circuit for embedded mode\n    if (this.deps.config.isEmbedded) {\n      console.log('[üîÑ URL-ARCH-SERVICE] Embedded mode - skipping URL check');\n      return false;\n    }\n\n    // CRITICAL: localStorage priority check\n    if (!this.shouldLoadFromUrl()) {\n      return false;\n    }\n\n    // Get URL architecture ID\n    const urlArchId = anonymousArchitectureService.getArchitectureIdFromUrl();\n    if (!urlArchId) {\n      console.log('[üîÑ URL-ARCH-SERVICE] No URL architecture ID found');\n      return false;\n    }\n\n    console.log('[üîÑ URL-ARCH-SERVICE] Loading from URL since localStorage allows it:', urlArchId);\n    await this.loadSharedAnonymousArchitecture(urlArchId);\n    return true;\n  }\n\n  /**\n   * Check if we should load from URL based on localStorage priority\n   */\n  private shouldLoadFromUrl(): boolean {\n    if (typeof window === 'undefined') return false;\n\n    try {\n      // Check if localStorage has been explicitly set (even if empty)\n      const stored = localStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY) || sessionStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY);\n      \n      console.log('[üîç URL-ARCH-SERVICE] localStorage priority check:', {\n        hasStoredData: !!stored,\n        storedLength: stored?.length || 0\n      });\n      \n      if (stored) {\n        // localStorage has been set - user has interacted with the app\n        // Don't load from URL - localStorage takes absolute priority\n        console.log('[üîÑ URL-ARCH-SERVICE] localStorage exists - BLOCKING URL load (localStorage priority)');\n        return false;\n      } else {\n        console.log('[üîÑ URL-ARCH-SERVICE] No localStorage - ALLOWING URL load');\n        return true;\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Error checking localStorage:', error);\n      // If localStorage check fails, allow URL loading as fallback\n      return true;\n    }\n  }\n\n  /**\n   * Load a shared anonymous architecture by ID\n   */\n  private async loadSharedAnonymousArchitecture(architectureId: string): Promise<void> {\n    try {\n      // Double-check localStorage priority (redundant safety)\n      if (!this.shouldLoadFromUrl()) {\n        console.log('[üîÑ URL-ARCH-SERVICE] localStorage priority block - aborting URL load');\n        return;\n      }\n\n      let sharedArch = null;\n      const isLocalFallback = architectureId.startsWith('local-');\n\n      // Load from Firebase if not a local fallback\n      if (!isLocalFallback) {\n        sharedArch = await anonymousArchitectureService.loadAnonymousArchitectureById(architectureId);\n      }\n\n      // Try fallback storage (sessionStorage/localStorage)\n      let fallbackData: any = null;\n      const fallbackSources: Array<'session' | 'local'> = [];\n\n      if (typeof window !== 'undefined') {\n        const storageKey = `${EMBED_PENDING_ARCH_PREFIX}${architectureId}`;\n        \n        // Try sessionStorage first\n        try {\n          const sessionPayload = window.sessionStorage?.getItem(storageKey);\n          if (sessionPayload) {\n            fallbackData = JSON.parse(sessionPayload);\n            fallbackSources.push('session');\n          }\n        } catch (error) {\n          console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Failed to read sessionStorage fallback:', error);\n        }\n\n        // Try localStorage if sessionStorage failed\n        if (!fallbackData) {\n          try {\n            const localPayload = window.localStorage?.getItem(storageKey);\n            if (localPayload) {\n              fallbackData = JSON.parse(localPayload);\n              fallbackSources.push('local');\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Failed to read localStorage fallback:', error);\n          }\n        }\n      }\n\n      // Create default architecture if nothing found\n      if (!sharedArch && !fallbackData) {\n        console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Architecture not found, creating default:', architectureId);\n        sharedArch = this.createDefaultArchitecture(architectureId);\n      }\n\n      // Use fallback data if no Firebase data\n      if (!sharedArch && fallbackData?.rawGraph) {\n        sharedArch = this.createArchitectureFromFallback(architectureId, fallbackData);\n      } else if (sharedArch && fallbackData) {\n        // Merge Firebase data with fallback chat messages\n        sharedArch = this.mergeArchitectureWithFallback(sharedArch, fallbackData);\n      }\n\n      // Clean up fallback storage\n      this.cleanupFallbackStorage(architectureId, fallbackSources);\n\n      if (sharedArch?.rawGraph) {\n        await this.processLoadedArchitecture(sharedArch);\n      } else {\n        console.warn('üî• [URL-ARCH-SERVICE] No valid architecture found:', architectureId);\n      }\n    } catch (error) {\n      console.error('üî• [URL-ARCH-SERVICE] Failed to load architecture:', error);\n    }\n  }\n\n  /**\n   * Process the loaded architecture based on auth mode\n   */\n  private async processLoadedArchitecture(sharedArch: AnonymousArchitecture): Promise<void> {\n    // Handle chat messages\n    this.handleChatMessages(sharedArch);\n\n    const isAuthMode = this.deps.config.requiresAuth || false;\n\n    if (isAuthMode && this.deps.currentUser?.uid) {\n      // Auth mode: convert to Firebase architecture\n      await this.processForAuthenticatedUser(sharedArch);\n    } else {\n      // Canvas/embed mode: load directly\n      this.deps.loadArchitecture(sharedArch, 'URL_SHARED');\n    }\n  }\n\n  /**\n   * Process architecture for authenticated user (convert to Firebase)\n   */\n  private async processForAuthenticatedUser(sharedArch: AnonymousArchitecture): Promise<void> {\n    try {\n      const { ArchitectureService } = await import('./architectureService');\n      const { generateNameWithFallback } = await import('../utils/naming');\n\n      // Get user prompt from various sources\n      let userPrompt = sharedArch.userPrompt || '';\n      if (!userPrompt) {\n        const persistedMessages = getChatMessages();\n        const lastUserMessage = persistedMessages.filter(msg => msg.sender === 'user').pop();\n        userPrompt = lastUserMessage?.content || (window as any).originalChatTextInput || (window as any).chatTextInput || '';\n      }\n\n      // Generate name and save to Firebase\n      const baseChatName = await generateNameWithFallback(sharedArch.rawGraph, userPrompt);\n      \n      const savedArchId = await ArchitectureService.saveArchitecture({\n        name: baseChatName,\n        userId: this.deps.currentUser!.uid,\n        userEmail: this.deps.currentUser!.email,\n        rawGraph: sharedArch.rawGraph,\n        userPrompt: userPrompt,\n        nodes: [],\n        edges: []\n      });\n\n      // Set as priority architecture\n      localStorage.setItem('priority_architecture_id', savedArchId);\n\n      // Create Firebase architecture object\n      const firebaseArch = {\n        id: savedArchId,\n        name: baseChatName,\n        timestamp: new Date(),\n        rawGraph: sharedArch.rawGraph,\n        firebaseId: savedArchId,\n        userPrompt: userPrompt,\n        isFromFirebase: true\n      };\n\n      this.deps.loadArchitecture(firebaseArch, 'URL_AUTH_TRANSFER');\n    } catch (error) {\n      console.error('üî• [URL-ARCH-SERVICE] Failed to process for authenticated user:', error);\n      // Fallback to anonymous loading\n      this.deps.loadArchitecture(sharedArch, 'URL_SHARED');\n    }\n  }\n\n  /**\n   * Handle chat message restoration/merging\n   */\n  private handleChatMessages(sharedArch: AnonymousArchitecture): void {\n    try {\n      const transitionedFromEmbed = isEmbedToCanvasTransition();\n      const existingConversation = getCurrentConversation();\n      const normalizedArchMessages = normalizeChatMessages((sharedArch as any).chatMessages);\n      const mergedConversation = mergeChatMessages(existingConversation, normalizedArchMessages);\n\n      if (mergedConversation && mergedConversation.length > 0) {\n        localStorage.setItem('atelier_current_conversation', JSON.stringify(mergedConversation));\n      } else if (existingConversation.length === 0) {\n        localStorage.removeItem('atelier_current_conversation');\n      }\n    } catch (error) {\n      console.warn('Failed to restore/merge chat messages:', error);\n    }\n  }\n\n  /**\n   * Create default architecture when none found\n   */\n  private createDefaultArchitecture(architectureId: string): AnonymousArchitecture {\n    const defaultGraph = {\n      id: 'root',\n      children: [\n        {\n          id: 'quickstart_node',\n          labels: [{ text: 'Quickstart Node' }],\n          children: [],\n          edges: [],\n          data: { label: 'Quickstart Node', icon: 'browser_client' },\n        },\n      ],\n      edges: [],\n    };\n\n    return {\n      id: architectureId,\n      name: 'Quickstart Architecture',\n      rawGraph: defaultGraph,\n      sessionId: 'default-fallback',\n      timestamp: Timestamp.now(),\n      isAnonymous: true,\n      userPrompt: '',\n      chatMessages: [],\n    } as AnonymousArchitecture;\n  }\n\n  /**\n   * Create architecture from fallback data\n   */\n  private createArchitectureFromFallback(architectureId: string, fallbackData: any): AnonymousArchitecture {\n    return {\n      id: architectureId,\n      name: fallbackData.name || 'Unsaved Architecture',\n      rawGraph: fallbackData.rawGraph,\n      sessionId: 'local-fallback',\n      timestamp: Timestamp.now(),\n      isAnonymous: true,\n      userPrompt: fallbackData.userPrompt || '',\n      chatMessages: fallbackData.chatMessages || [],\n      viewState: fallbackData.viewState || undefined,\n    } as AnonymousArchitecture;\n  }\n\n  /**\n   * Merge Firebase architecture with fallback data\n   */\n  private mergeArchitectureWithFallback(sharedArch: AnonymousArchitecture, fallbackData: any): AnonymousArchitecture {\n    const hasChatInDoc = Array.isArray((sharedArch as any).chatMessages) && (sharedArch as any).chatMessages.length > 0;\n    const fallbackChat = Array.isArray(fallbackData.chatMessages) ? fallbackData.chatMessages : [];\n    \n    if (!hasChatInDoc && fallbackChat.length > 0) {\n      return {\n        ...sharedArch,\n        chatMessages: fallbackChat,\n        userPrompt: sharedArch.userPrompt || fallbackData.userPrompt || sharedArch.userPrompt,\n        viewState: sharedArch.viewState || fallbackData.viewState || undefined,\n      } as AnonymousArchitecture;\n    }\n    \n    return sharedArch;\n  }\n\n  /**\n   * Clean up fallback storage after successful load\n   */\n  private cleanupFallbackStorage(architectureId: string, fallbackSources: Array<'session' | 'local'>): void {\n    if (fallbackSources.length && typeof window !== 'undefined') {\n      const storageKey = `${EMBED_PENDING_ARCH_PREFIX}${architectureId}`;\n      for (const source of fallbackSources) {\n        try {\n          if (source === 'session') {\n            window.sessionStorage?.removeItem(storageKey);\n          } else if (source === 'local') {\n            window.localStorage?.removeItem(storageKey);\n          }\n        } catch {}\n      }\n    }\n  }\n\n  /**\n   * LEGACY SUPPORT: Direct architecture loading (from InteractiveCanvas)\n   * This maintains compatibility with existing loadArchitectureFromUrl calls\n   */\n  loadArchitectureFromUrl(architecture: any, source: string): void {\n    if (!this.deps.setRawGraph || !this.deps.viewStateRef) {\n      console.error('[URL-ARCH-SERVICE] Missing dependencies for direct loading');\n      return;\n    }\n\n    // Check localStorage priority first\n    if (!this.shouldLoadFromUrl()) {\n      console.log('[üîÑ URL-ARCH-SERVICE] localStorage priority - blocking direct URL load');\n      return;\n    }\n\n    console.log('[üîÑ URL-ARCH-SERVICE] Direct loading architecture from URL:', architecture.id);\n\n    // Handle ViewState\n    let viewStateSnapshot = undefined;\n    if (architecture.viewState) {\n      try {\n        viewStateSnapshot = JSON.parse(JSON.stringify(architecture.viewState));\n      } catch (error) {\n        console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Failed to clone viewState:', error);\n        viewStateSnapshot = architecture.viewState;\n      }\n      this.deps.viewStateRef.current = viewStateSnapshot ?? { node: {}, group: {}, edge: {} };\n    } else {\n      this.deps.viewStateRef.current = this.deps.viewStateRef.current || { node: {}, group: {}, edge: {} };\n    }\n\n    const graphWithViewState = viewStateSnapshot\n      ? { ...architecture.rawGraph, viewState: viewStateSnapshot }\n      : architecture.rawGraph;\n\n    // Set the content\n    if (this.deps.logPageLoad) {\n      this.deps.logPageLoad('URL', architecture.rawGraph, architecture.id);\n    }\n    this.deps.setRawGraph(graphWithViewState);\n    \n    if (this.deps.setCurrentChatName) {\n      this.deps.setCurrentChatName(architecture.name);\n    }\n\n    // Create architecture tab\n    const urlArch = {\n      id: architecture.id,\n      name: architecture.name,\n      timestamp: architecture.timestamp || new Date(),\n      rawGraph: graphWithViewState,\n      userPrompt: architecture.userPrompt || '',\n      firebaseId: architecture.firebaseId || architecture.id,\n      isFromFirebase: true,\n      viewState: viewStateSnapshot,\n      isFromUrl: true\n    };\n\n    if (this.deps.setSavedArchitectures && this.deps.setSelectedArchitectureId) {\n      this.deps.setSavedArchitectures(prev => {\n        const exists = prev.some(arch => arch.id === architecture.id);\n        if (!exists) {\n          return [urlArch, ...prev];\n        }\n        return prev;\n      });\n      this.deps.setSelectedArchitectureId(architecture.id);\n    }\n  }\n}",
    "start_line": 42,
    "end_line": 434,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class UrlArchitectureService",
    "component_id": "client.services.UrlArchitectureService.UrlArchitectureService"
  },
  "client.services.UrlArchitectureService.checkAndLoadUrlArchitecture": {
    "id": "client.services.UrlArchitectureService.checkAndLoadUrlArchitecture",
    "name": "checkAndLoadUrlArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "async checkAndLoadUrlArchitecture(): Promise<boolean> {\n    console.log('[üîÑ URL-ARCH-SERVICE] Starting URL architecture check');\n\n    // Short circuit for embedded mode\n    if (this.deps.config.isEmbedded) {\n      console.log('[üîÑ URL-ARCH-SERVICE] Embedded mode - skipping URL check');\n      return false;\n    }\n\n    // CRITICAL: localStorage priority check\n    if (!this.shouldLoadFromUrl()) {\n      return false;\n    }\n\n    // Get URL architecture ID\n    const urlArchId = anonymousArchitectureService.getArchitectureIdFromUrl();\n    if (!urlArchId) {\n      console.log('[üîÑ URL-ARCH-SERVICE] No URL architecture ID found');\n      return false;\n    }\n\n    console.log('[üîÑ URL-ARCH-SERVICE] Loading from URL since localStorage allows it:', urlArchId);\n    await this.loadSharedAnonymousArchitecture(urlArchId);\n    return true;\n  }",
    "start_line": 56,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method checkAndLoadUrlArchitecture",
    "component_id": "client.services.UrlArchitectureService.checkAndLoadUrlArchitecture"
  },
  "client.services.UrlArchitectureService.shouldLoadFromUrl": {
    "id": "client.services.UrlArchitectureService.shouldLoadFromUrl",
    "name": "shouldLoadFromUrl",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private shouldLoadFromUrl(): boolean {\n    if (typeof window === 'undefined') return false;\n\n    try {\n      // Check if localStorage has been explicitly set (even if empty)\n      const stored = localStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY) || sessionStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY);\n      \n      console.log('[üîç URL-ARCH-SERVICE] localStorage priority check:', {\n        hasStoredData: !!stored,\n        storedLength: stored?.length || 0\n      });\n      \n      if (stored) {\n        // localStorage has been set - user has interacted with the app\n        // Don't load from URL - localStorage takes absolute priority\n        console.log('[üîÑ URL-ARCH-SERVICE] localStorage exists - BLOCKING URL load (localStorage priority)');\n        return false;\n      } else {\n        console.log('[üîÑ URL-ARCH-SERVICE] No localStorage - ALLOWING URL load');\n        return true;\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Error checking localStorage:', error);\n      // If localStorage check fails, allow URL loading as fallback\n      return true;\n    }\n  }",
    "start_line": 85,
    "end_line": 111,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method shouldLoadFromUrl",
    "component_id": "client.services.UrlArchitectureService.shouldLoadFromUrl"
  },
  "client.services.UrlArchitectureService.loadSharedAnonymousArchitecture": {
    "id": "client.services.UrlArchitectureService.loadSharedAnonymousArchitecture",
    "name": "loadSharedAnonymousArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private async loadSharedAnonymousArchitecture(architectureId: string): Promise<void> {\n    try {\n      // Double-check localStorage priority (redundant safety)\n      if (!this.shouldLoadFromUrl()) {\n        console.log('[üîÑ URL-ARCH-SERVICE] localStorage priority block - aborting URL load');\n        return;\n      }\n\n      let sharedArch = null;\n      const isLocalFallback = architectureId.startsWith('local-');\n\n      // Load from Firebase if not a local fallback\n      if (!isLocalFallback) {\n        sharedArch = await anonymousArchitectureService.loadAnonymousArchitectureById(architectureId);\n      }\n\n      // Try fallback storage (sessionStorage/localStorage)\n      let fallbackData: any = null;\n      const fallbackSources: Array<'session' | 'local'> = [];\n\n      if (typeof window !== 'undefined') {\n        const storageKey = `${EMBED_PENDING_ARCH_PREFIX}${architectureId}`;\n        \n        // Try sessionStorage first\n        try {\n          const sessionPayload = window.sessionStorage?.getItem(storageKey);\n          if (sessionPayload) {\n            fallbackData = JSON.parse(sessionPayload);\n            fallbackSources.push('session');\n          }\n        } catch (error) {\n          console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Failed to read sessionStorage fallback:', error);\n        }\n\n        // Try localStorage if sessionStorage failed\n        if (!fallbackData) {\n          try {\n            const localPayload = window.localStorage?.getItem(storageKey);\n            if (localPayload) {\n              fallbackData = JSON.parse(localPayload);\n              fallbackSources.push('local');\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Failed to read localStorage fallback:', error);\n          }\n        }\n      }\n\n      // Create default architecture if nothing found\n      if (!sharedArch && !fallbackData) {\n        console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Architecture not found, creating default:', architectureId);\n        sharedArch = this.createDefaultArchitecture(architectureId);\n      }\n\n      // Use fallback data if no Firebase data\n      if (!sharedArch && fallbackData?.rawGraph) {\n        sharedArch = this.createArchitectureFromFallback(architectureId, fallbackData);\n      } else if (sharedArch && fallbackData) {\n        // Merge Firebase data with fallback chat messages\n        sharedArch = this.mergeArchitectureWithFallback(sharedArch, fallbackData);\n      }\n\n      // Clean up fallback storage\n      this.cleanupFallbackStorage(architectureId, fallbackSources);\n\n      if (sharedArch?.rawGraph) {\n        await this.processLoadedArchitecture(sharedArch);\n      } else {\n        console.warn('üî• [URL-ARCH-SERVICE] No valid architecture found:', architectureId);\n      }\n    } catch (error) {\n      console.error('üî• [URL-ARCH-SERVICE] Failed to load architecture:', error);\n    }\n  }",
    "start_line": 116,
    "end_line": 189,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadSharedAnonymousArchitecture",
    "component_id": "client.services.UrlArchitectureService.loadSharedAnonymousArchitecture"
  },
  "client.services.UrlArchitectureService.processLoadedArchitecture": {
    "id": "client.services.UrlArchitectureService.processLoadedArchitecture",
    "name": "processLoadedArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private async processLoadedArchitecture(sharedArch: AnonymousArchitecture): Promise<void> {\n    // Handle chat messages\n    this.handleChatMessages(sharedArch);\n\n    const isAuthMode = this.deps.config.requiresAuth || false;\n\n    if (isAuthMode && this.deps.currentUser?.uid) {\n      // Auth mode: convert to Firebase architecture\n      await this.processForAuthenticatedUser(sharedArch);\n    } else {\n      // Canvas/embed mode: load directly\n      this.deps.loadArchitecture(sharedArch, 'URL_SHARED');\n    }\n  }",
    "start_line": 194,
    "end_line": 207,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sharedArch"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method processLoadedArchitecture",
    "component_id": "client.services.UrlArchitectureService.processLoadedArchitecture"
  },
  "client.services.UrlArchitectureService.processForAuthenticatedUser": {
    "id": "client.services.UrlArchitectureService.processForAuthenticatedUser",
    "name": "processForAuthenticatedUser",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private async processForAuthenticatedUser(sharedArch: AnonymousArchitecture): Promise<void> {\n    try {\n      const { ArchitectureService } = await import('./architectureService');\n      const { generateNameWithFallback } = await import('../utils/naming');\n\n      // Get user prompt from various sources\n      let userPrompt = sharedArch.userPrompt || '';\n      if (!userPrompt) {\n        const persistedMessages = getChatMessages();\n        const lastUserMessage = persistedMessages.filter(msg => msg.sender === 'user').pop();\n        userPrompt = lastUserMessage?.content || (window as any).originalChatTextInput || (window as any).chatTextInput || '';\n      }\n\n      // Generate name and save to Firebase\n      const baseChatName = await generateNameWithFallback(sharedArch.rawGraph, userPrompt);\n      \n      const savedArchId = await ArchitectureService.saveArchitecture({\n        name: baseChatName,\n        userId: this.deps.currentUser!.uid,\n        userEmail: this.deps.currentUser!.email,\n        rawGraph: sharedArch.rawGraph,\n        userPrompt: userPrompt,\n        nodes: [],\n        edges: []\n      });\n\n      // Set as priority architecture\n      localStorage.setItem('priority_architecture_id', savedArchId);\n\n      // Create Firebase architecture object\n      const firebaseArch = {\n        id: savedArchId,\n        name: baseChatName,\n        timestamp: new Date(),\n        rawGraph: sharedArch.rawGraph,\n        firebaseId: savedArchId,\n        userPrompt: userPrompt,\n        isFromFirebase: true\n      };\n\n      this.deps.loadArchitecture(firebaseArch, 'URL_AUTH_TRANSFER');\n    } catch (error) {\n      console.error('üî• [URL-ARCH-SERVICE] Failed to process for authenticated user:', error);\n      // Fallback to anonymous loading\n      this.deps.loadArchitecture(sharedArch, 'URL_SHARED');\n    }\n  }",
    "start_line": 212,
    "end_line": 258,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sharedArch"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method processForAuthenticatedUser",
    "component_id": "client.services.UrlArchitectureService.processForAuthenticatedUser"
  },
  "client.services.UrlArchitectureService.handleChatMessages": {
    "id": "client.services.UrlArchitectureService.handleChatMessages",
    "name": "handleChatMessages",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private handleChatMessages(sharedArch: AnonymousArchitecture): void {\n    try {\n      const transitionedFromEmbed = isEmbedToCanvasTransition();\n      const existingConversation = getCurrentConversation();\n      const normalizedArchMessages = normalizeChatMessages((sharedArch as any).chatMessages);\n      const mergedConversation = mergeChatMessages(existingConversation, normalizedArchMessages);\n\n      if (mergedConversation && mergedConversation.length > 0) {\n        localStorage.setItem('atelier_current_conversation', JSON.stringify(mergedConversation));\n      } else if (existingConversation.length === 0) {\n        localStorage.removeItem('atelier_current_conversation');\n      }\n    } catch (error) {\n      console.warn('Failed to restore/merge chat messages:', error);\n    }\n  }",
    "start_line": 263,
    "end_line": 278,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sharedArch"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method handleChatMessages",
    "component_id": "client.services.UrlArchitectureService.handleChatMessages"
  },
  "client.services.UrlArchitectureService.createDefaultArchitecture": {
    "id": "client.services.UrlArchitectureService.createDefaultArchitecture",
    "name": "createDefaultArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private createDefaultArchitecture(architectureId: string): AnonymousArchitecture {\n    const defaultGraph = {\n      id: 'root',\n      children: [\n        {\n          id: 'quickstart_node',\n          labels: [{ text: 'Quickstart Node' }],\n          children: [],\n          edges: [],\n          data: { label: 'Quickstart Node', icon: 'browser_client' },\n        },\n      ],\n      edges: [],\n    };\n\n    return {\n      id: architectureId,\n      name: 'Quickstart Architecture',\n      rawGraph: defaultGraph,\n      sessionId: 'default-fallback',\n      timestamp: Timestamp.now(),\n      isAnonymous: true,\n      userPrompt: '',\n      chatMessages: [],\n    } as AnonymousArchitecture;\n  }",
    "start_line": 283,
    "end_line": 308,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createDefaultArchitecture",
    "component_id": "client.services.UrlArchitectureService.createDefaultArchitecture"
  },
  "client.services.UrlArchitectureService.createArchitectureFromFallback": {
    "id": "client.services.UrlArchitectureService.createArchitectureFromFallback",
    "name": "createArchitectureFromFallback",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private createArchitectureFromFallback(architectureId: string, fallbackData: any): AnonymousArchitecture {\n    return {\n      id: architectureId,\n      name: fallbackData.name || 'Unsaved Architecture',\n      rawGraph: fallbackData.rawGraph,\n      sessionId: 'local-fallback',\n      timestamp: Timestamp.now(),\n      isAnonymous: true,\n      userPrompt: fallbackData.userPrompt || '',\n      chatMessages: fallbackData.chatMessages || [],\n      viewState: fallbackData.viewState || undefined,\n    } as AnonymousArchitecture;\n  }",
    "start_line": 313,
    "end_line": 325,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId",
      "fallbackData"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method createArchitectureFromFallback",
    "component_id": "client.services.UrlArchitectureService.createArchitectureFromFallback"
  },
  "client.services.UrlArchitectureService.mergeArchitectureWithFallback": {
    "id": "client.services.UrlArchitectureService.mergeArchitectureWithFallback",
    "name": "mergeArchitectureWithFallback",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private mergeArchitectureWithFallback(sharedArch: AnonymousArchitecture, fallbackData: any): AnonymousArchitecture {\n    const hasChatInDoc = Array.isArray((sharedArch as any).chatMessages) && (sharedArch as any).chatMessages.length > 0;\n    const fallbackChat = Array.isArray(fallbackData.chatMessages) ? fallbackData.chatMessages : [];\n    \n    if (!hasChatInDoc && fallbackChat.length > 0) {\n      return {\n        ...sharedArch,\n        chatMessages: fallbackChat,\n        userPrompt: sharedArch.userPrompt || fallbackData.userPrompt || sharedArch.userPrompt,\n        viewState: sharedArch.viewState || fallbackData.viewState || undefined,\n      } as AnonymousArchitecture;\n    }\n    \n    return sharedArch;\n  }",
    "start_line": 330,
    "end_line": 344,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sharedArch",
      "fallbackData"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method mergeArchitectureWithFallback",
    "component_id": "client.services.UrlArchitectureService.mergeArchitectureWithFallback"
  },
  "client.services.UrlArchitectureService.cleanupFallbackStorage": {
    "id": "client.services.UrlArchitectureService.cleanupFallbackStorage",
    "name": "cleanupFallbackStorage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "private cleanupFallbackStorage(architectureId: string, fallbackSources: Array<'session' | 'local'>): void {\n    if (fallbackSources.length && typeof window !== 'undefined') {\n      const storageKey = `${EMBED_PENDING_ARCH_PREFIX}${architectureId}`;\n      for (const source of fallbackSources) {\n        try {\n          if (source === 'session') {\n            window.sessionStorage?.removeItem(storageKey);\n          } else if (source === 'local') {\n            window.localStorage?.removeItem(storageKey);\n          }\n        } catch {}\n      }\n    }\n  }",
    "start_line": 349,
    "end_line": 362,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId",
      "fallbackSources"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method cleanupFallbackStorage",
    "component_id": "client.services.UrlArchitectureService.cleanupFallbackStorage"
  },
  "client.services.UrlArchitectureService.loadArchitectureFromUrl": {
    "id": "client.services.UrlArchitectureService.loadArchitectureFromUrl",
    "name": "loadArchitectureFromUrl",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [],
    "source_code": "loadArchitectureFromUrl(architecture: any, source: string): void {\n    if (!this.deps.setRawGraph || !this.deps.viewStateRef) {\n      console.error('[URL-ARCH-SERVICE] Missing dependencies for direct loading');\n      return;\n    }\n\n    // Check localStorage priority first\n    if (!this.shouldLoadFromUrl()) {\n      console.log('[üîÑ URL-ARCH-SERVICE] localStorage priority - blocking direct URL load');\n      return;\n    }\n\n    console.log('[üîÑ URL-ARCH-SERVICE] Direct loading architecture from URL:', architecture.id);\n\n    // Handle ViewState\n    let viewStateSnapshot = undefined;\n    if (architecture.viewState) {\n      try {\n        viewStateSnapshot = JSON.parse(JSON.stringify(architecture.viewState));\n      } catch (error) {\n        console.warn('‚ö†Ô∏è [URL-ARCH-SERVICE] Failed to clone viewState:', error);\n        viewStateSnapshot = architecture.viewState;\n      }\n      this.deps.viewStateRef.current = viewStateSnapshot ?? { node: {}, group: {}, edge: {} };\n    } else {\n      this.deps.viewStateRef.current = this.deps.viewStateRef.current || { node: {}, group: {}, edge: {} };\n    }\n\n    const graphWithViewState = viewStateSnapshot\n      ? { ...architecture.rawGraph, viewState: viewStateSnapshot }\n      : architecture.rawGraph;\n\n    // Set the content\n    if (this.deps.logPageLoad) {\n      this.deps.logPageLoad('URL', architecture.rawGraph, architecture.id);\n    }\n    this.deps.setRawGraph(graphWithViewState);\n    \n    if (this.deps.setCurrentChatName) {\n      this.deps.setCurrentChatName(architecture.name);\n    }\n\n    // Create architecture tab\n    const urlArch = {\n      id: architecture.id,\n      name: architecture.name,\n      timestamp: architecture.timestamp || new Date(),\n      rawGraph: graphWithViewState,\n      userPrompt: architecture.userPrompt || '',\n      firebaseId: architecture.firebaseId || architecture.id,\n      isFromFirebase: true,\n      viewState: viewStateSnapshot,\n      isFromUrl: true\n    };\n\n    if (this.deps.setSavedArchitectures && this.deps.setSelectedArchitectureId) {\n      this.deps.setSavedArchitectures(prev => {\n        const exists = prev.some(arch => arch.id === architecture.id);\n        if (!exists) {\n          return [urlArch, ...prev];\n        }\n        return prev;\n      });\n      this.deps.setSelectedArchitectureId(architecture.id);\n    }\n  }",
    "start_line": 368,
    "end_line": 433,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architecture",
      "source"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method loadArchitectureFromUrl",
    "component_id": "client.services.UrlArchitectureService.loadArchitectureFromUrl"
  },
  "client.services.UrlArchitectureService.createUrlArchitectureService": {
    "id": "client.services.UrlArchitectureService.createUrlArchitectureService",
    "name": "createUrlArchitectureService",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/UrlArchitectureService.ts",
    "relative_path": "client/services/UrlArchitectureService.ts",
    "depends_on": [
      "client.services.UrlArchitectureService.UrlArchitectureServiceDeps",
      "client.services.UrlArchitectureService.UrlArchitectureService"
    ],
    "source_code": "function createUrlArchitectureService(deps: UrlArchitectureServiceDeps): UrlArchitectureService {\n  return new UrlArchitectureService(deps);\n}",
    "start_line": 437,
    "end_line": 439,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "deps"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createUrlArchitectureService",
    "component_id": "client.services.UrlArchitectureService.createUrlArchitectureService"
  },
  "client.services.anonymousArchitectureService.AnonymousArchitecture": {
    "id": "client.services.anonymousArchitectureService.AnonymousArchitecture",
    "name": "AnonymousArchitecture",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "interface AnonymousArchitecture {\n  id?: string;\n  name: string;\n  rawGraph: any;\n  sessionId: string; // Unique session identifier for anonymous user\n  timestamp: Timestamp;\n  isAnonymous: true;\n  userAgent?: string;\n  ipHash?: string; // For cleanup purposes (hashed IP)\n  userPrompt?: string; // Original user prompt that created the architecture\n  chatMessages?: Array<{\n    id: string;\n    content: string;\n    timestamp: number;\n    sender: 'user' | 'assistant';\n  }>;\n}",
    "start_line": 9,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AnonymousArchitecture",
    "component_id": "client.services.anonymousArchitectureService.AnonymousArchitecture"
  },
  "client.services.anonymousArchitectureService.AnonymousArchitectureService": {
    "id": "client.services.anonymousArchitectureService.AnonymousArchitectureService",
    "name": "AnonymousArchitectureService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.chatPersistence.getCurrentConversation",
      "client.services.architectureService.saveArchitecture",
      "client.services.anonymousArchitectureService.getAnonymousArchitectures",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.services.anonymousArchitectureService.AnonymousArchitecture",
      "client.services.anonymousArchitectureService.updateUrlWithArchitectureId",
      "client.services.anonymousArchitectureService.getSessionId",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "class AnonymousArchitectureService {\n  private sessionId: string | null = null\n  private lastSaveTime: number = 0\n  private saveThrottleMs: number = 1000 // Minimum 1 second between saves (reasonable spam protection);\n\n  /**\n   * Get or create a session ID for anonymous user\n   */\n  private getSessionId(): string {\n    if (this.sessionId) {\n      return this.sessionId;\n    }\n\n    // Check localStorage first\n    let sessionId = localStorage.getItem('anonymous_session_id');\n    \n    if (!sessionId) {\n      // Generate new session ID\n      sessionId = `anon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      localStorage.setItem('anonymous_session_id', sessionId);\n    }\n\n    this.sessionId = sessionId;\n    return sessionId;\n  }\n\n  /**\n   * Save an anonymous architecture\n   */\n  async saveAnonymousArchitecture(name: string, rawGraph: any, userPrompt?: string): Promise<string> {\n    try {\n      // Ensure we're running on client side\n      if (typeof window === 'undefined') {\n        throw new Error('Anonymous architecture saving only works on client side');\n      }\n\n      // Ensure Firebase is initialized\n      if (!db) {\n        throw new Error('Firebase db is not initialized');\n      }\n\n      const now = Date.now();\n\n      // Light throttle to prevent spam clicking (1 second)\n      if (now - this.lastSaveTime < this.saveThrottleMs) {\n        console.log('‚è≥ Save throttled - too soon after last save');\n        throw new Error('Save throttled - please wait before saving again');\n      }\n\n      const sessionId = this.getSessionId();\n\n      // Try to get userPrompt from various sources if not provided\n      const finalUserPrompt = userPrompt\n        || (window as any).originalChatTextInput\n        || (window as any).chatTextInput\n        || '';\n\n      // Get chat messages from localStorage if available\n      let chatMessages: Array<{id: string; content: string; timestamp: number; sender: 'user' | 'assistant'}> | undefined;\n      try {\n        const { getCurrentConversation } = await import('../utils/chatPersistence');\n        const messages = getCurrentConversation();\n        if (messages && messages.length > 0) {\n          chatMessages = messages;\n        }\n      } catch (error) {\n        console.warn('Failed to get chat messages for architecture:', error);\n      }\n\n      const anonymousArch: Omit<AnonymousArchitecture, 'id'> = {\n        name,\n        rawGraph,\n        sessionId,\n        timestamp: Timestamp.now(),\n        isAnonymous: true,\n        userAgent: navigator.userAgent,\n        userPrompt: finalUserPrompt,\n        chatMessages,\n      };\n\n      console.log('üíæ Saving anonymous architecture:', name, 'for session:', sessionId);\n\n      const docRef = await addDoc(collection(db, 'anonymous_architectures'), anonymousArch);\n\n      console.log('‚úÖ Anonymous architecture saved with ID:', docRef.id);\n\n      // Update throttling state\n      this.lastSaveTime = now;\n\n      // Update URL with architecture ID for sharing\n      this.updateUrlWithArchitectureId(docRef.id);\n\n      return docRef.id;\n    } catch (error) {\n      console.error('‚ùå Error saving anonymous architecture:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load a specific anonymous architecture by ID (for shared URLs)\n   */\n  async loadAnonymousArchitectureById(architectureId: string): Promise<AnonymousArchitecture | null> {\n    try {\n      const docRef = doc(db, 'anonymous_architectures', architectureId);\n      const docSnap = await getDoc(docRef);\n      \n      if (docSnap.exists()) {\n        const data = docSnap.data();\n        console.log('üì• Loaded shared anonymous architecture:', architectureId);\n        return {\n          id: docSnap.id,\n          ...data,\n          timestamp: data.timestamp || Timestamp.now()\n        } as AnonymousArchitecture;\n      } else {\n        console.warn('‚ö†Ô∏è Anonymous architecture not found:', architectureId);\n        return null;\n      }\n    } catch (error) {\n      console.error('‚ùå Error loading anonymous architecture:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Update URL with architecture ID for sharing\n   */\n  private updateUrlWithArchitectureId(architectureId: string): void {\n    if (typeof window === 'undefined') return;\n    \n    const url = new URL(window.location.href);\n    url.searchParams.set('arch', architectureId);\n    \n    // Update URL without page reload\n    window.history.replaceState({}, '', url.toString());\n    console.log('üîó Updated URL for sharing:', url.toString());\n  }\n\n  /**\n   * Get architecture ID from URL parameters\n   */\n  getArchitectureIdFromUrl(): string | null {\n    if (typeof window === 'undefined') return null;\n    \n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('arch');\n  }\n\n  /**\n   * Clear architecture ID from URL\n   */\n  clearArchitectureIdFromUrl(): void {\n    if (typeof window === 'undefined') return;\n    \n    const url = new URL(window.location.href);\n    url.searchParams.delete('arch');\n    \n    // Update URL without page reload\n    window.history.replaceState({}, '', url.toString());\n    console.log('üßπ Cleared architecture ID from URL');\n  }\n\n  /**\n   * Get anonymous architectures for current session\n   */\n  async getAnonymousArchitectures(): Promise<AnonymousArchitecture[]> {\n    try {\n      const sessionId = this.getSessionId();\n      \n      const q = query(\n        collection(db, 'anonymous_architectures'),\n        where('sessionId', '==', sessionId),\n        where('isAnonymous', '==', true)\n      );\n\n      const querySnapshot = await getDocs(q);\n      const architectures: AnonymousArchitecture[] = [];\n\n      querySnapshot.forEach((doc) => {\n        const data = doc.data();\n        architectures.push({\n          id: doc.id,\n          ...data,\n          timestamp: data.timestamp || Timestamp.now()\n        } as AnonymousArchitecture);\n      });\n\n      console.log(`üì• Found ${architectures.length} anonymous architectures for session:`, sessionId);\n      return architectures.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());\n    } catch (error) {\n      console.error('‚ùå Error loading anonymous architectures:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Transfer anonymous architectures to signed-in user\n   */\n  async transferAnonymousArchitectures(userId: string, userEmail: string): Promise<{count: number, transferredIds: string[]}> {\n    try {\n      const sessionId = this.getSessionId();\n      console.log('üîÑ Transferring anonymous architectures to user:', userEmail, 'from session:', sessionId);\n\n      // Get all anonymous architectures for this session\n      const anonymousArchs = await this.getAnonymousArchitectures();\n      \n      if (anonymousArchs.length === 0) {\n        console.log('‚ÑπÔ∏è No anonymous architectures to transfer');\n        return {count: 0, transferredIds: []};\n      }\n\n      // Import ArchitectureService to save as regular architectures\n      const { default: ArchitectureService } = await import('./architectureService');\n\n      let transferredCount = 0;\n      const transferredIds: string[] = [];\n\n      for (const arch of anonymousArchs) {\n        try {\n          // üî• Generate AI name when transferring anonymous ‚Üí user architecture\n          console.log('üî• TRANSFER NAMING - Converting anonymous session architecture to user architecture');\n          console.log('üìù Anonymous arch name (should be generic):', arch.name);\n          \n          let architectureName = arch.name;\n          try {\n            console.log('üåê Making API request to /api/generateChatName...');\n            const response = await fetch('/api/generateChatName', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                architecture: arch.rawGraph,\n                nodeCount: arch.rawGraph?.children?.length || 0,\n                edgeCount: arch.rawGraph?.edges?.length || 0,\n                userPrompt: `Architecture with ${arch.rawGraph?.children?.length || 0} components from user session`\n              }),\n            });\n            \n            if (response.ok) {\n              const data = await response.json();\n              if (data.name && data.name.trim()) {\n                architectureName = data.name.trim();\n                console.log('‚úÖ Generated AI name for transferred architecture:', architectureName);\n              }\n            } else {\n              console.warn('‚ö†Ô∏è AI naming API failed, using original name');\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è AI naming failed for transfer, using original name:', error);\n          }\n          \n          // Save as regular user architecture with complete data\n          // Extract nodes and edges from rawGraph for compatibility\n          const nodes = arch.rawGraph?.children || [];\n          const edges = arch.rawGraph?.edges || [];\n          \n          const newArchId = await ArchitectureService.saveArchitecture({\n            name: architectureName,\n            userId,\n            userEmail,\n            rawGraph: arch.rawGraph,\n            nodes: nodes,\n            edges: edges,\n            userPrompt: `Architecture transferred from anonymous session`\n          });\n\n          console.log(`‚úÖ Transferred anonymous architecture \"${arch.name}\" ‚Üí \"${architectureName}\" to user architecture:`, newArchId);\n          transferredIds.push(newArchId);\n\n          // Delete the anonymous version\n          if (arch.id) {\n            await deleteDoc(doc(db, 'anonymous_architectures', arch.id));\n            console.log(`üóëÔ∏è Deleted anonymous architecture:`, arch.id);\n          }\n\n          transferredCount++;\n        } catch (error) {\n          console.error(`‚ùå Failed to transfer architecture \"${arch.name}\":`, error);\n        }\n      }\n\n      // Clear session ID after successful transfer\n      localStorage.removeItem('anonymous_session_id');\n      this.sessionId = null;\n\n      console.log(`üéâ Successfully transferred ${transferredCount}/${anonymousArchs.length} anonymous architectures`);\n      return {count: transferredCount, transferredIds};\n    } catch (error) {\n      console.error('‚ùå Error transferring anonymous architectures:', error);\n      return {count: 0, transferredIds: []};\n    }\n  }\n\n  /**\n   * Update an existing anonymous architecture\n   */\n  async updateAnonymousArchitecture(architectureId: string, updates: Partial<AnonymousArchitecture>): Promise<void> {\n    try {\n      const docRef = doc(db, 'anonymous_architectures', architectureId);\n      await updateDoc(docRef, {\n        ...updates,\n        timestamp: Timestamp.now() // Update timestamp\n      });\n      \n      console.log('‚úÖ Updated anonymous architecture:', architectureId);\n    } catch (error) {\n      console.error('‚ùå Error updating anonymous architecture:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cleanup old anonymous architectures (older than 7 days)\n   */\n  async cleanupOldAnonymousArchitectures(): Promise<void> {\n    try {\n      const sevenDaysAgo = new Date();\n      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n      \n      const q = query(\n        collection(db, 'anonymous_architectures'),\n        where('timestamp', '<', Timestamp.fromDate(sevenDaysAgo)),\n        where('isAnonymous', '==', true)\n      );\n\n      const querySnapshot = await getDocs(q);\n      \n      const deletePromises = querySnapshot.docs.map(doc => deleteDoc(doc.ref));\n      await Promise.all(deletePromises);\n      \n      console.log(`üßπ Cleaned up ${querySnapshot.size} old anonymous architectures`);\n    } catch (error: any) {\n      // Handle specific Firestore index errors gracefully\n      if (error?.code === 'failed-precondition' && error?.message?.includes('index')) {\n        console.log('‚ÑπÔ∏è Firestore index not ready for cleanup query - this is expected during initial setup');\n      } else {\n        console.error('‚ùå Error cleaning up anonymous architectures:', error);\n      }\n    }\n  }\n\n  /**\n   * Get current session ID (for debugging)\n   */\n  getCurrentSessionId(): string | null {\n    return this.sessionId || localStorage.getItem('anonymous_session_id');\n  }\n}",
    "start_line": 27,
    "end_line": 376,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class AnonymousArchitectureService",
    "component_id": "client.services.anonymousArchitectureService.AnonymousArchitectureService"
  },
  "client.services.anonymousArchitectureService.getSessionId": {
    "id": "client.services.anonymousArchitectureService.getSessionId",
    "name": "getSessionId",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "private getSessionId(): string {\n    if (this.sessionId) {\n      return this.sessionId;\n    }\n\n    // Check localStorage first\n    let sessionId = localStorage.getItem('anonymous_session_id');\n    \n    if (!sessionId) {\n      // Generate new session ID\n      sessionId = `anon_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      localStorage.setItem('anonymous_session_id', sessionId);\n    }\n\n    this.sessionId = sessionId;\n    return sessionId;\n  }",
    "start_line": 35,
    "end_line": 51,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getSessionId",
    "component_id": "client.services.anonymousArchitectureService.getSessionId"
  },
  "client.services.anonymousArchitectureService.saveAnonymousArchitecture": {
    "id": "client.services.anonymousArchitectureService.saveAnonymousArchitecture",
    "name": "saveAnonymousArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "async saveAnonymousArchitecture(name: string, rawGraph: any, userPrompt?: string): Promise<string> {\n    try {\n      // Ensure we're running on client side\n      if (typeof window === 'undefined') {\n        throw new Error('Anonymous architecture saving only works on client side');\n      }\n\n      // Ensure Firebase is initialized\n      if (!db) {\n        throw new Error('Firebase db is not initialized');\n      }\n\n      const now = Date.now();\n\n      // Light throttle to prevent spam clicking (1 second)\n      if (now - this.lastSaveTime < this.saveThrottleMs) {\n        console.log('‚è≥ Save throttled - too soon after last save');\n        throw new Error('Save throttled - please wait before saving again');\n      }\n\n      const sessionId = this.getSessionId();\n\n      // Try to get userPrompt from various sources if not provided\n      const finalUserPrompt = userPrompt\n        || (window as any).originalChatTextInput\n        || (window as any).chatTextInput\n        || '';\n\n      // Get chat messages from localStorage if available\n      let chatMessages: Array<{id: string; content: string; timestamp: number; sender: 'user' | 'assistant'}> | undefined;\n      try {\n        const { getCurrentConversation } = await import('../utils/chatPersistence');\n        const messages = getCurrentConversation();\n        if (messages && messages.length > 0) {\n          chatMessages = messages;\n        }\n      } catch (error) {\n        console.warn('Failed to get chat messages for architecture:', error);\n      }\n\n      const anonymousArch: Omit<AnonymousArchitecture, 'id'> = {\n        name,\n        rawGraph,\n        sessionId,\n        timestamp: Timestamp.now(),\n        isAnonymous: true,\n        userAgent: navigator.userAgent,\n        userPrompt: finalUserPrompt,\n        chatMessages,\n      };\n\n      console.log('üíæ Saving anonymous architecture:', name, 'for session:', sessionId);\n\n      const docRef = await addDoc(collection(db, 'anonymous_architectures'), anonymousArch);\n\n      console.log('‚úÖ Anonymous architecture saved with ID:', docRef.id);\n\n      // Update throttling state\n      this.lastSaveTime = now;\n\n      // Update URL with architecture ID for sharing\n      this.updateUrlWithArchitectureId(docRef.id);\n\n      return docRef.id;\n    } catch (error) {\n      console.error('‚ùå Error saving anonymous architecture:', error);\n      throw error;\n    }\n  }",
    "start_line": 56,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "rawGraph",
      "userPrompt"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method saveAnonymousArchitecture",
    "component_id": "client.services.anonymousArchitectureService.saveAnonymousArchitecture"
  },
  "client.services.anonymousArchitectureService.loadAnonymousArchitectureById": {
    "id": "client.services.anonymousArchitectureService.loadAnonymousArchitectureById",
    "name": "loadAnonymousArchitectureById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "async loadAnonymousArchitectureById(architectureId: string): Promise<AnonymousArchitecture | null> {\n    try {\n      const docRef = doc(db, 'anonymous_architectures', architectureId);\n      const docSnap = await getDoc(docRef);\n      \n      if (docSnap.exists()) {\n        const data = docSnap.data();\n        console.log('üì• Loaded shared anonymous architecture:', architectureId);\n        return {\n          id: docSnap.id,\n          ...data,\n          timestamp: data.timestamp || Timestamp.now()\n        } as AnonymousArchitecture;\n      } else {\n        console.warn('‚ö†Ô∏è Anonymous architecture not found:', architectureId);\n        return null;\n      }\n    } catch (error) {\n      console.error('‚ùå Error loading anonymous architecture:', error);\n      return null;\n    }\n  }",
    "start_line": 129,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadAnonymousArchitectureById",
    "component_id": "client.services.anonymousArchitectureService.loadAnonymousArchitectureById"
  },
  "client.services.anonymousArchitectureService.updateUrlWithArchitectureId": {
    "id": "client.services.anonymousArchitectureService.updateUrlWithArchitectureId",
    "name": "updateUrlWithArchitectureId",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "private updateUrlWithArchitectureId(architectureId: string): void {\n    if (typeof window === 'undefined') return;\n    \n    const url = new URL(window.location.href);\n    url.searchParams.set('arch', architectureId);\n    \n    // Update URL without page reload\n    window.history.replaceState({}, '', url.toString());\n    console.log('üîó Updated URL for sharing:', url.toString());\n  }",
    "start_line": 155,
    "end_line": 164,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method updateUrlWithArchitectureId",
    "component_id": "client.services.anonymousArchitectureService.updateUrlWithArchitectureId"
  },
  "client.services.anonymousArchitectureService.getArchitectureIdFromUrl": {
    "id": "client.services.anonymousArchitectureService.getArchitectureIdFromUrl",
    "name": "getArchitectureIdFromUrl",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "getArchitectureIdFromUrl(): string | null {\n    if (typeof window === 'undefined') return null;\n    \n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get('arch');\n  }",
    "start_line": 169,
    "end_line": 174,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getArchitectureIdFromUrl",
    "component_id": "client.services.anonymousArchitectureService.getArchitectureIdFromUrl"
  },
  "client.services.anonymousArchitectureService.clearArchitectureIdFromUrl": {
    "id": "client.services.anonymousArchitectureService.clearArchitectureIdFromUrl",
    "name": "clearArchitectureIdFromUrl",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "clearArchitectureIdFromUrl(): void {\n    if (typeof window === 'undefined') return;\n    \n    const url = new URL(window.location.href);\n    url.searchParams.delete('arch');\n    \n    // Update URL without page reload\n    window.history.replaceState({}, '', url.toString());\n    console.log('üßπ Cleared architecture ID from URL');\n  }",
    "start_line": 179,
    "end_line": 188,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clearArchitectureIdFromUrl",
    "component_id": "client.services.anonymousArchitectureService.clearArchitectureIdFromUrl"
  },
  "client.services.anonymousArchitectureService.getAnonymousArchitectures": {
    "id": "client.services.anonymousArchitectureService.getAnonymousArchitectures",
    "name": "getAnonymousArchitectures",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "async getAnonymousArchitectures(): Promise<AnonymousArchitecture[]> {\n    try {\n      const sessionId = this.getSessionId();\n      \n      const q = query(\n        collection(db, 'anonymous_architectures'),\n        where('sessionId', '==', sessionId),\n        where('isAnonymous', '==', true)\n      );\n\n      const querySnapshot = await getDocs(q);\n      const architectures: AnonymousArchitecture[] = [];\n\n      querySnapshot.forEach((doc) => {\n        const data = doc.data();\n        architectures.push({\n          id: doc.id,\n          ...data,\n          timestamp: data.timestamp || Timestamp.now()\n        } as AnonymousArchitecture);\n      });\n\n      console.log(`üì• Found ${architectures.length} anonymous architectures for session:`, sessionId);\n      return architectures.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());\n    } catch (error) {\n      console.error('‚ùå Error loading anonymous architectures:', error);\n      return [];\n    }\n  }",
    "start_line": 193,
    "end_line": 221,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getAnonymousArchitectures",
    "component_id": "client.services.anonymousArchitectureService.getAnonymousArchitectures"
  },
  "client.services.anonymousArchitectureService.transferAnonymousArchitectures": {
    "id": "client.services.anonymousArchitectureService.transferAnonymousArchitectures",
    "name": "transferAnonymousArchitectures",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "async transferAnonymousArchitectures(userId: string, userEmail: string): Promise<{count: number, transferredIds: string[]}> {\n    try {\n      const sessionId = this.getSessionId();\n      console.log('üîÑ Transferring anonymous architectures to user:', userEmail, 'from session:', sessionId);\n\n      // Get all anonymous architectures for this session\n      const anonymousArchs = await this.getAnonymousArchitectures();\n      \n      if (anonymousArchs.length === 0) {\n        console.log('‚ÑπÔ∏è No anonymous architectures to transfer');\n        return {count: 0, transferredIds: []};\n      }\n\n      // Import ArchitectureService to save as regular architectures\n      const { default: ArchitectureService } = await import('./architectureService');\n\n      let transferredCount = 0;\n      const transferredIds: string[] = [];\n\n      for (const arch of anonymousArchs) {\n        try {\n          // üî• Generate AI name when transferring anonymous ‚Üí user architecture\n          console.log('üî• TRANSFER NAMING - Converting anonymous session architecture to user architecture');\n          console.log('üìù Anonymous arch name (should be generic):', arch.name);\n          \n          let architectureName = arch.name;\n          try {\n            console.log('üåê Making API request to /api/generateChatName...');\n            const response = await fetch('/api/generateChatName', {\n              method: 'POST',\n              headers: {\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                architecture: arch.rawGraph,\n                nodeCount: arch.rawGraph?.children?.length || 0,\n                edgeCount: arch.rawGraph?.edges?.length || 0,\n                userPrompt: `Architecture with ${arch.rawGraph?.children?.length || 0} components from user session`\n              }),\n            });\n            \n            if (response.ok) {\n              const data = await response.json();\n              if (data.name && data.name.trim()) {\n                architectureName = data.name.trim();\n                console.log('‚úÖ Generated AI name for transferred architecture:', architectureName);\n              }\n            } else {\n              console.warn('‚ö†Ô∏è AI naming API failed, using original name');\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è AI naming failed for transfer, using original name:', error);\n          }\n          \n          // Save as regular user architecture with complete data\n          // Extract nodes and edges from rawGraph for compatibility\n          const nodes = arch.rawGraph?.children || [];\n          const edges = arch.rawGraph?.edges || [];\n          \n          const newArchId = await ArchitectureService.saveArchitecture({\n            name: architectureName,\n            userId,\n            userEmail,\n            rawGraph: arch.rawGraph,\n            nodes: nodes,\n            edges: edges,\n            userPrompt: `Architecture transferred from anonymous session`\n          });\n\n          console.log(`‚úÖ Transferred anonymous architecture \"${arch.name}\" ‚Üí \"${architectureName}\" to user architecture:`, newArchId);\n          transferredIds.push(newArchId);\n\n          // Delete the anonymous version\n          if (arch.id) {\n            await deleteDoc(doc(db, 'anonymous_architectures', arch.id));\n            console.log(`üóëÔ∏è Deleted anonymous architecture:`, arch.id);\n          }\n\n          transferredCount++;\n        } catch (error) {\n          console.error(`‚ùå Failed to transfer architecture \"${arch.name}\":`, error);\n        }\n      }\n\n      // Clear session ID after successful transfer\n      localStorage.removeItem('anonymous_session_id');\n      this.sessionId = null;\n\n      console.log(`üéâ Successfully transferred ${transferredCount}/${anonymousArchs.length} anonymous architectures`);\n      return {count: transferredCount, transferredIds};\n    } catch (error) {\n      console.error('‚ùå Error transferring anonymous architectures:', error);\n      return {count: 0, transferredIds: []};\n    }\n  }",
    "start_line": 226,
    "end_line": 320,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "userId",
      "userEmail"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method transferAnonymousArchitectures",
    "component_id": "client.services.anonymousArchitectureService.transferAnonymousArchitectures"
  },
  "client.services.anonymousArchitectureService.updateAnonymousArchitecture": {
    "id": "client.services.anonymousArchitectureService.updateAnonymousArchitecture",
    "name": "updateAnonymousArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "async updateAnonymousArchitecture(architectureId: string, updates: Partial<AnonymousArchitecture>): Promise<void> {\n    try {\n      const docRef = doc(db, 'anonymous_architectures', architectureId);\n      await updateDoc(docRef, {\n        ...updates,\n        timestamp: Timestamp.now() // Update timestamp\n      });\n      \n      console.log('‚úÖ Updated anonymous architecture:', architectureId);\n    } catch (error) {\n      console.error('‚ùå Error updating anonymous architecture:', error);\n      throw error;\n    }\n  }",
    "start_line": 325,
    "end_line": 338,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId",
      "updates"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method updateAnonymousArchitecture",
    "component_id": "client.services.anonymousArchitectureService.updateAnonymousArchitecture"
  },
  "client.services.anonymousArchitectureService.cleanupOldAnonymousArchitectures": {
    "id": "client.services.anonymousArchitectureService.cleanupOldAnonymousArchitectures",
    "name": "cleanupOldAnonymousArchitectures",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "async cleanupOldAnonymousArchitectures(): Promise<void> {\n    try {\n      const sevenDaysAgo = new Date();\n      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n      \n      const q = query(\n        collection(db, 'anonymous_architectures'),\n        where('timestamp', '<', Timestamp.fromDate(sevenDaysAgo)),\n        where('isAnonymous', '==', true)\n      );\n\n      const querySnapshot = await getDocs(q);\n      \n      const deletePromises = querySnapshot.docs.map(doc => deleteDoc(doc.ref));\n      await Promise.all(deletePromises);\n      \n      console.log(`üßπ Cleaned up ${querySnapshot.size} old anonymous architectures`);\n    } catch (error: any) {\n      // Handle specific Firestore index errors gracefully\n      if (error?.code === 'failed-precondition' && error?.message?.includes('index')) {\n        console.log('‚ÑπÔ∏è Firestore index not ready for cleanup query - this is expected during initial setup');\n      } else {\n        console.error('‚ùå Error cleaning up anonymous architectures:', error);\n      }\n    }\n  }",
    "start_line": 343,
    "end_line": 368,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method cleanupOldAnonymousArchitectures",
    "component_id": "client.services.anonymousArchitectureService.cleanupOldAnonymousArchitectures"
  },
  "client.services.anonymousArchitectureService.getCurrentSessionId": {
    "id": "client.services.anonymousArchitectureService.getCurrentSessionId",
    "name": "getCurrentSessionId",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/anonymousArchitectureService.ts",
    "relative_path": "client/services/anonymousArchitectureService.ts",
    "depends_on": [],
    "source_code": "getCurrentSessionId(): string | null {\n    return this.sessionId || localStorage.getItem('anonymous_session_id');\n  }",
    "start_line": 373,
    "end_line": 375,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getCurrentSessionId",
    "component_id": "client.services.anonymousArchitectureService.getCurrentSessionId"
  },
  "client.services.architectureService.SavedArchitecture": {
    "id": "client.services.architectureService.SavedArchitecture",
    "name": "SavedArchitecture",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "interface SavedArchitecture {\n  id?: string;\n  name: string;\n  description?: string;\n  rawGraph: any;\n  nodes: any[];\n  edges: any[];\n  timestamp: Timestamp;\n  userId: string;\n  userEmail: string;\n  userPrompt?: string;\n  chatMessages?: Array<{\n    id: string;\n    content: string;\n    timestamp: number;\n    sender: 'user' | 'assistant';\n  }>;\n  isPublic?: boolean;\n  tags?: string[];\n}",
    "start_line": 17,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SavedArchitecture",
    "component_id": "client.services.architectureService.SavedArchitecture"
  },
  "client.services.architectureService.ArchitectureService": {
    "id": "client.services.architectureService.ArchitectureService",
    "name": "ArchitectureService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.services.architectureService.cleanFirestoreData",
      "client.services.architectureService.SavedArchitecture"
    ],
    "source_code": "class ArchitectureService {\n  private static readonly COLLECTION_NAME = 'architectures';\n\n\n\n\n\n  /**\n   * Clean data recursively to remove undefined values and functions\n   */\n  private static cleanFirestoreData(obj: any): any {\n    if (obj === null || obj === undefined) {\n      return null;\n    }\n    \n    if (typeof obj === 'function') {\n      return null;\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj\n        .map(item => this.cleanFirestoreData(item))\n        .filter(item => item !== null && item !== undefined);\n    }\n    \n    if (typeof obj === 'object') {\n      const cleaned: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        const cleanedValue = this.cleanFirestoreData(value);\n        if (cleanedValue !== null && cleanedValue !== undefined) {\n          cleaned[key] = cleanedValue;\n        }\n      }\n      return cleaned;\n    }\n    \n    return obj;\n  }\n\n  /**\n   * Save complete ELK architecture data to Firebase\n   */\n  static async saveArchitecture(\n    architectureData: Omit<SavedArchitecture, 'id' | 'timestamp'>\n  ): Promise<string> {\n    try {\n      console.log('üíæ Saving complete ELK architecture to Firebase...');\n      \n      // Save the complete architecture data including ELK rawGraph\n      const completeData = {\n        name: architectureData.name, // No fallback - name must be provided\n        description: architectureData.description || `Architecture with ${architectureData.nodes?.length || 0} components`,\n        userId: architectureData.userId,\n        userEmail: architectureData.userEmail,\n        isPublic: architectureData.isPublic || false,\n        tags: architectureData.tags || [],\n        \n        // Save the complete ELK data\n        rawGraph: architectureData.rawGraph,\n        nodes: architectureData.nodes,\n        edges: architectureData.edges,\n        \n        // Metadata - preserve existing timestamps or use current time\n        nodeCount: architectureData.nodes?.length || 0,\n        edgeCount: architectureData.edges?.length || 0,\n        timestamp: architectureData.timestamp ? Timestamp.fromDate(new Date(architectureData.timestamp)) : Timestamp.now(),\n        createdAt: architectureData.createdAt ? Timestamp.fromDate(new Date(architectureData.createdAt)) : Timestamp.now(),\n        lastModified: Timestamp.now() // Always update lastModified\n      };\n      \n      // Clean the data to remove undefined values and functions\n      const cleanedData = this.cleanFirestoreData(completeData);\n      \n      console.log('üìä Saving ELK architecture:', cleanedData.name);\n      \n      // Save to Firebase\n      const docRef = await addDoc(collection(db, this.COLLECTION_NAME), cleanedData);\n      \n      console.log('‚úÖ ELK Architecture saved to Firebase with ID:', docRef.id);\n      \n      // Success message now handled by toast notifications in InteractiveCanvas\n      \n      return docRef.id;\n    } catch (error: any) {\n      console.error('‚ùå Error saving ELK architecture to Firebase:', error);\n      console.error('‚ùå Error code:', error?.code);\n      console.error('‚ùå Error message:', error?.message);\n      console.error('‚ùå Full error object:', error);\n      \n      // Provide helpful error messages based on common Firebase issues\n      let userMessage = 'Failed to save architecture to Firebase.';\n      \n      if (error?.message?.includes('Failed to fetch') || error?.message?.includes('network')) {\n        userMessage += ' Network connectivity issue - check your internet connection.';\n      } else if (error?.code === 'permission-denied') {\n        userMessage += ' Permission denied - check Firestore security rules.';\n      } else if (error?.code === 'unauthenticated') {\n        userMessage += ' Authentication required - please sign in again.';\n      } else if (error?.message?.includes('referrer') || error?.message?.includes('API key')) {\n        userMessage += ' API key configuration issue - check Firebase console settings.';\n      } else {\n        userMessage += ` Error: ${error?.message || 'Unknown error'}`;\n      }\n      \n      throw new Error(userMessage);\n    }\n  }\n\n\n\n  // REMOVED: generateArchitectureName function - all names must be AI-generated via generateChatName API\n\n  static async loadUserArchitectures(userId: string): Promise<SavedArchitecture[]> {\n    try {\n      console.log('üîÑ Loading architectures for user:', userId);\n      \n      const q = query(\n        collection(db, this.COLLECTION_NAME),\n        where('userId', '==', userId),\n        orderBy('timestamp', 'desc'),\n        limit(20) // Limit to recent 20 architectures\n      );\n      \n      const querySnapshot = await getDocs(q);\n      const architectures: SavedArchitecture[] = [];\n      \n      querySnapshot.forEach((doc) => {\n        const data = doc.data();\n        architectures.push({\n          id: doc.id,\n          ...data,\n          timestamp: data.timestamp || Timestamp.now()\n        } as SavedArchitecture);\n      });\n      \n      console.log(`‚úÖ Loaded ${architectures.length} architectures from Firebase`);\n      return architectures;\n    } catch (error) {\n      console.error('‚ùå Error loading user architectures:', error);\n      return [];\n    }\n  }\n\n  static async updateArchitecture(\n    architectureId: string, \n    updates: Partial<SavedArchitecture>\n  ): Promise<void> {\n    try {\n      console.log('üîÑ Updating architecture in Firebase:', architectureId);\n      \n      const docRef = doc(db, this.COLLECTION_NAME, architectureId);\n      \n      // Clean the update data\n      const cleanedUpdates = ArchitectureService.cleanFirestoreData({\n        ...updates,\n        timestamp: Timestamp.now(),\n        lastModified: Timestamp.now()\n      });\n      \n      await updateDoc(docRef, cleanedUpdates);\n      console.log('‚úÖ Architecture updated in Firebase:', architectureId);\n    } catch (error) {\n      console.error('‚ùå Error updating architecture:', error);\n      throw error;\n    }\n  }\n\n  static async cleanupInvalidArchitectures(userId: string): Promise<void> {\n    try {\n      console.log('üßπ Cleaning up invalid architectures for user:', userId);\n      \n      const q = query(\n        collection(db, this.COLLECTION_NAME),\n        where('userId', '==', userId)\n      );\n      \n      const querySnapshot = await getDocs(q);\n      const deletePromises: Promise<void>[] = [];\n      \n      querySnapshot.forEach((doc) => {\n        const data = doc.data();\n        \n        // Check if architecture is invalid (missing required fields)\n        const isInvalid = !data.name || !data.rawGraph || !data.userId;\n        \n        if (isInvalid) {\n          console.log('üóëÔ∏è Deleting invalid architecture:', doc.id, data);\n          deletePromises.push(deleteDoc(doc.ref));\n        }\n      });\n      \n      if (deletePromises.length > 0) {\n        await Promise.all(deletePromises);\n        console.log(`‚úÖ Cleaned up ${deletePromises.length} invalid architectures`);\n      } else {\n        console.log('‚úÖ No invalid architectures found');\n      }\n    } catch (error) {\n      console.error('‚ùå Error cleaning up architectures:', error);\n    }\n  }\n\n  static async deleteArchitecture(architectureId: string): Promise<void> {\n    try {\n      console.log('üóëÔ∏è Deleting architecture from Firebase:', architectureId);\n      \n      const docRef = doc(db, this.COLLECTION_NAME, architectureId);\n      await deleteDoc(docRef);\n      \n      console.log('‚úÖ Architecture deleted from Firebase:', architectureId);\n    } catch (error) {\n      console.error('‚ùå Error deleting architecture:', error);\n      throw error;\n    }\n  }\n\n  static async getArchitectureById(architectureId: string): Promise<SavedArchitecture | null> {\n    try {\n      const docRef = doc(db, this.COLLECTION_NAME, architectureId);\n      const docSnap = await getDoc(docRef);\n      \n      if (docSnap.exists()) {\n        const data = docSnap.data();\n        return {\n          id: docSnap.id,\n          ...data\n        } as SavedArchitecture;\n      } else {\n        console.log('‚ùå Architecture not found:', architectureId);\n        return null;\n      }\n    } catch (error) {\n      console.error('‚ùå Error fetching architecture by ID:', error);\n      throw error;\n    }\n  }\n}",
    "start_line": 38,
    "end_line": 274,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ArchitectureService",
    "component_id": "client.services.architectureService.ArchitectureService"
  },
  "client.services.architectureService.cleanFirestoreData": {
    "id": "client.services.architectureService.cleanFirestoreData",
    "name": "cleanFirestoreData",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "private static cleanFirestoreData(obj: any): any {\n    if (obj === null || obj === undefined) {\n      return null;\n    }\n    \n    if (typeof obj === 'function') {\n      return null;\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj\n        .map(item => this.cleanFirestoreData(item))\n        .filter(item => item !== null && item !== undefined);\n    }\n    \n    if (typeof obj === 'object') {\n      const cleaned: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        const cleanedValue = this.cleanFirestoreData(value);\n        if (cleanedValue !== null && cleanedValue !== undefined) {\n          cleaned[key] = cleanedValue;\n        }\n      }\n      return cleaned;\n    }\n    \n    return obj;\n  }",
    "start_line": 48,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "obj"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method cleanFirestoreData",
    "component_id": "client.services.architectureService.cleanFirestoreData"
  },
  "client.services.architectureService.saveArchitecture": {
    "id": "client.services.architectureService.saveArchitecture",
    "name": "saveArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "static async saveArchitecture(\n    architectureData: Omit<SavedArchitecture, 'id' | 'timestamp'>\n  ): Promise<string> {\n    try {\n      console.log('üíæ Saving complete ELK architecture to Firebase...');\n      \n      // Save the complete architecture data including ELK rawGraph\n      const completeData = {\n        name: architectureData.name, // No fallback - name must be provided\n        description: architectureData.description || `Architecture with ${architectureData.nodes?.length || 0} components`,\n        userId: architectureData.userId,\n        userEmail: architectureData.userEmail,\n        isPublic: architectureData.isPublic || false,\n        tags: architectureData.tags || [],\n        \n        // Save the complete ELK data\n        rawGraph: architectureData.rawGraph,\n        nodes: architectureData.nodes,\n        edges: architectureData.edges,\n        \n        // Metadata - preserve existing timestamps or use current time\n        nodeCount: architectureData.nodes?.length || 0,\n        edgeCount: architectureData.edges?.length || 0,\n        timestamp: architectureData.timestamp ? Timestamp.fromDate(new Date(architectureData.timestamp)) : Timestamp.now(),\n        createdAt: architectureData.createdAt ? Timestamp.fromDate(new Date(architectureData.createdAt)) : Timestamp.now(),\n        lastModified: Timestamp.now() // Always update lastModified\n      };\n      \n      // Clean the data to remove undefined values and functions\n      const cleanedData = this.cleanFirestoreData(completeData);\n      \n      console.log('üìä Saving ELK architecture:', cleanedData.name);\n      \n      // Save to Firebase\n      const docRef = await addDoc(collection(db, this.COLLECTION_NAME), cleanedData);\n      \n      console.log('‚úÖ ELK Architecture saved to Firebase with ID:', docRef.id);\n      \n      // Success message now handled by toast notifications in InteractiveCanvas\n      \n      return docRef.id;\n    } catch (error: any) {\n      console.error('‚ùå Error saving ELK architecture to Firebase:', error);\n      console.error('‚ùå Error code:', error?.code);\n      console.error('‚ùå Error message:', error?.message);\n      console.error('‚ùå Full error object:', error);\n      \n      // Provide helpful error messages based on common Firebase issues\n      let userMessage = 'Failed to save architecture to Firebase.';\n      \n      if (error?.message?.includes('Failed to fetch') || error?.message?.includes('network')) {\n        userMessage += ' Network connectivity issue - check your internet connection.';\n      } else if (error?.code === 'permission-denied') {\n        userMessage += ' Permission denied - check Firestore security rules.';\n      } else if (error?.code === 'unauthenticated') {\n        userMessage += ' Authentication required - please sign in again.';\n      } else if (error?.message?.includes('referrer') || error?.message?.includes('API key')) {\n        userMessage += ' API key configuration issue - check Firebase console settings.';\n      } else {\n        userMessage += ` Error: ${error?.message || 'Unknown error'}`;\n      }\n      \n      throw new Error(userMessage);\n    }\n  }",
    "start_line": 80,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureData"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method saveArchitecture",
    "component_id": "client.services.architectureService.saveArchitecture"
  },
  "client.services.architectureService.loadUserArchitectures": {
    "id": "client.services.architectureService.loadUserArchitectures",
    "name": "loadUserArchitectures",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "static async loadUserArchitectures(userId: string): Promise<SavedArchitecture[]> {\n    try {\n      console.log('üîÑ Loading architectures for user:', userId);\n      \n      const q = query(\n        collection(db, this.COLLECTION_NAME),\n        where('userId', '==', userId),\n        orderBy('timestamp', 'desc'),\n        limit(20) // Limit to recent 20 architectures\n      );\n      \n      const querySnapshot = await getDocs(q);\n      const architectures: SavedArchitecture[] = [];\n      \n      querySnapshot.forEach((doc) => {\n        const data = doc.data();\n        architectures.push({\n          id: doc.id,\n          ...data,\n          timestamp: data.timestamp || Timestamp.now()\n        } as SavedArchitecture);\n      });\n      \n      console.log(`‚úÖ Loaded ${architectures.length} architectures from Firebase`);\n      return architectures;\n    } catch (error) {\n      console.error('‚ùå Error loading user architectures:', error);\n      return [];\n    }\n  }",
    "start_line": 150,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "userId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method loadUserArchitectures",
    "component_id": "client.services.architectureService.loadUserArchitectures"
  },
  "client.services.architectureService.updateArchitecture": {
    "id": "client.services.architectureService.updateArchitecture",
    "name": "updateArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "static async updateArchitecture(\n    architectureId: string, \n    updates: Partial<SavedArchitecture>\n  ): Promise<void> {\n    try {\n      console.log('üîÑ Updating architecture in Firebase:', architectureId);\n      \n      const docRef = doc(db, this.COLLECTION_NAME, architectureId);\n      \n      // Clean the update data\n      const cleanedUpdates = ArchitectureService.cleanFirestoreData({\n        ...updates,\n        timestamp: Timestamp.now(),\n        lastModified: Timestamp.now()\n      });\n      \n      await updateDoc(docRef, cleanedUpdates);\n      console.log('‚úÖ Architecture updated in Firebase:', architectureId);\n    } catch (error) {\n      console.error('‚ùå Error updating architecture:', error);\n      throw error;\n    }\n  }",
    "start_line": 181,
    "end_line": 203,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId",
      "updates"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method updateArchitecture",
    "component_id": "client.services.architectureService.updateArchitecture"
  },
  "client.services.architectureService.cleanupInvalidArchitectures": {
    "id": "client.services.architectureService.cleanupInvalidArchitectures",
    "name": "cleanupInvalidArchitectures",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "static async cleanupInvalidArchitectures(userId: string): Promise<void> {\n    try {\n      console.log('üßπ Cleaning up invalid architectures for user:', userId);\n      \n      const q = query(\n        collection(db, this.COLLECTION_NAME),\n        where('userId', '==', userId)\n      );\n      \n      const querySnapshot = await getDocs(q);\n      const deletePromises: Promise<void>[] = [];\n      \n      querySnapshot.forEach((doc) => {\n        const data = doc.data();\n        \n        // Check if architecture is invalid (missing required fields)\n        const isInvalid = !data.name || !data.rawGraph || !data.userId;\n        \n        if (isInvalid) {\n          console.log('üóëÔ∏è Deleting invalid architecture:', doc.id, data);\n          deletePromises.push(deleteDoc(doc.ref));\n        }\n      });\n      \n      if (deletePromises.length > 0) {\n        await Promise.all(deletePromises);\n        console.log(`‚úÖ Cleaned up ${deletePromises.length} invalid architectures`);\n      } else {\n        console.log('‚úÖ No invalid architectures found');\n      }\n    } catch (error) {\n      console.error('‚ùå Error cleaning up architectures:', error);\n    }\n  }",
    "start_line": 205,
    "end_line": 238,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "userId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method cleanupInvalidArchitectures",
    "component_id": "client.services.architectureService.cleanupInvalidArchitectures"
  },
  "client.services.architectureService.deleteArchitecture": {
    "id": "client.services.architectureService.deleteArchitecture",
    "name": "deleteArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "static async deleteArchitecture(architectureId: string): Promise<void> {\n    try {\n      console.log('üóëÔ∏è Deleting architecture from Firebase:', architectureId);\n      \n      const docRef = doc(db, this.COLLECTION_NAME, architectureId);\n      await deleteDoc(docRef);\n      \n      console.log('‚úÖ Architecture deleted from Firebase:', architectureId);\n    } catch (error) {\n      console.error('‚ùå Error deleting architecture:', error);\n      throw error;\n    }\n  }",
    "start_line": 240,
    "end_line": 252,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method deleteArchitecture",
    "component_id": "client.services.architectureService.deleteArchitecture"
  },
  "client.services.architectureService.getArchitectureById": {
    "id": "client.services.architectureService.getArchitectureById",
    "name": "getArchitectureById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/architectureService.ts",
    "relative_path": "client/services/architectureService.ts",
    "depends_on": [],
    "source_code": "static async getArchitectureById(architectureId: string): Promise<SavedArchitecture | null> {\n    try {\n      const docRef = doc(db, this.COLLECTION_NAME, architectureId);\n      const docSnap = await getDoc(docRef);\n      \n      if (docSnap.exists()) {\n        const data = docSnap.data();\n        return {\n          id: docSnap.id,\n          ...data\n        } as SavedArchitecture;\n      } else {\n        console.log('‚ùå Architecture not found:', architectureId);\n        return null;\n      }\n    } catch (error) {\n      console.error('‚ùå Error fetching architecture by ID:', error);\n      throw error;\n    }\n  }",
    "start_line": 254,
    "end_line": 273,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method getArchitectureById",
    "component_id": "client.services.architectureService.getArchitectureById"
  },
  "client.services.canvasArchitectureService.CanvasArchitectureService": {
    "id": "client.services.canvasArchitectureService.CanvasArchitectureService",
    "name": "CanvasArchitectureService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/canvasArchitectureService.ts",
    "relative_path": "client/services/canvasArchitectureService.ts",
    "depends_on": [],
    "source_code": "class CanvasArchitectureService {\n  constructor(params: any) {}\n  handleDeleteArchitecture = () => {};\n  handleShareArchitecture = () => {};\n  handleEditArchitecture = () => {};\n}",
    "start_line": 1,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CanvasArchitectureService",
    "component_id": "client.services.canvasArchitectureService.CanvasArchitectureService"
  },
  "client.services.canvasChatService.CanvasChatService": {
    "id": "client.services.canvasChatService.CanvasChatService",
    "name": "CanvasChatService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/canvasChatService.ts",
    "relative_path": "client/services/canvasChatService.ts",
    "depends_on": [],
    "source_code": "class CanvasChatService {\n  constructor(params: any) {}\n}",
    "start_line": 1,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CanvasChatService",
    "component_id": "client.services.canvasChatService.CanvasChatService"
  },
  "client.services.canvasSaveService.CanvasSaveService": {
    "id": "client.services.canvasSaveService.CanvasSaveService",
    "name": "CanvasSaveService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/canvasSaveService.ts",
    "relative_path": "client/services/canvasSaveService.ts",
    "depends_on": [],
    "source_code": "class CanvasSaveService {\n  constructor(params: any) {}\n\n  markDirty() {\n    // No-op: mark canvas as dirty (can be implemented later if needed)\n  }\n\n  flushRemoteSave() {\n    // No-op: flush remote save (can be implemented later if needed)\n  }\n\n  requestRemoteSave() {\n    // No-op: request remote save (can be implemented later if needed)\n  }\n}",
    "start_line": 1,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CanvasSaveService",
    "component_id": "client.services.canvasSaveService.CanvasSaveService"
  },
  "client.services.canvasSaveService.markDirty": {
    "id": "client.services.canvasSaveService.markDirty",
    "name": "markDirty",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/canvasSaveService.ts",
    "relative_path": "client/services/canvasSaveService.ts",
    "depends_on": [],
    "source_code": "markDirty() {\n    // No-op: mark canvas as dirty (can be implemented later if needed)\n  }",
    "start_line": 4,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method markDirty",
    "component_id": "client.services.canvasSaveService.markDirty"
  },
  "client.services.canvasSaveService.flushRemoteSave": {
    "id": "client.services.canvasSaveService.flushRemoteSave",
    "name": "flushRemoteSave",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/canvasSaveService.ts",
    "relative_path": "client/services/canvasSaveService.ts",
    "depends_on": [],
    "source_code": "flushRemoteSave() {\n    // No-op: flush remote save (can be implemented later if needed)\n  }",
    "start_line": 8,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method flushRemoteSave",
    "component_id": "client.services.canvasSaveService.flushRemoteSave"
  },
  "client.services.canvasSaveService.requestRemoteSave": {
    "id": "client.services.canvasSaveService.requestRemoteSave",
    "name": "requestRemoteSave",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/canvasSaveService.ts",
    "relative_path": "client/services/canvasSaveService.ts",
    "depends_on": [],
    "source_code": "requestRemoteSave() {\n    // No-op: request remote save (can be implemented later if needed)\n  }",
    "start_line": 12,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method requestRemoteSave",
    "component_id": "client.services.canvasSaveService.requestRemoteSave"
  },
  "client.services.sharingService.SharingService": {
    "id": "client.services.sharingService.SharingService",
    "name": "SharingService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/sharingService.ts",
    "relative_path": "client/services/sharingService.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.services.sharingService.createShareableLink",
      "client.services.architectureService.SavedArchitecture"
    ],
    "source_code": "class SharingService {\n  private static readonly SHARE_DOMAIN = 'https://atelier.inc.net';\n  \n  /**\n   * Creates a shareable URL for an architecture\n   */\n  static async createShareableLink(architectureId: string): Promise<string> {\n    try {\n      // The URL format will be: https://atelier.inc.net/architecture/{architectureId}\n      // When someone visits this URL, they'll be prompted to sign in if not authenticated\n      // Then the architecture will be loaded as the top/selected one\n      const shareUrl = `${this.SHARE_DOMAIN}/architecture/${architectureId}`;\n      \n      console.log('üîó Created shareable link:', shareUrl);\n      return shareUrl;\n    } catch (error) {\n      console.error('‚ùå Error creating shareable link:', error);\n      throw new Error('Failed to create shareable link');\n    }\n  }\n\n  /**\n   * Copies the shareable link to clipboard\n   */\n  static async shareArchitecture(architectureId: string): Promise<void> {\n    try {\n      const shareUrl = await this.createShareableLink(architectureId);\n      \n      // Copy to clipboard\n      await navigator.clipboard.writeText(shareUrl);\n      console.log('‚úÖ Architecture link copied to clipboard:', shareUrl);\n      \n      return;\n    } catch (error) {\n      console.error('‚ùå Error sharing architecture:', error);\n      throw new Error('Failed to share architecture');\n    }\n  }\n\n  /**\n   * Loads a shared architecture by ID (for when someone visits the shared link)\n   */\n  static async loadSharedArchitecture(architectureId: string): Promise<SavedArchitecture | null> {\n    try {\n      // This would be called when someone visits https://atelier.inc.net/architecture/{architectureId}\n      // First ensure user is authenticated\n      if (!auth.currentUser) {\n        throw new Error('User must be signed in to view shared architectures');\n      }\n\n      // Load the architecture from Firebase\n      // Note: We'll need to modify ArchitectureService to allow loading any public architecture\n      // For now, this assumes the architecture is accessible to the current user\n      console.log('üîç Loading shared architecture:', architectureId);\n      \n      // This is a placeholder - we'd need to implement a method to load any architecture by ID\n      // regardless of ownership (if it's marked as shareable)\n      return null;\n    } catch (error) {\n      console.error('‚ùå Error loading shared architecture:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Checks if current URL contains a shared architecture ID\n   */\n  static getSharedArchitectureIdFromUrl(): string | null {\n    const urlPath = window.location.pathname;\n    const match = urlPath.match(/\\/architecture\\/([^\\/]+)$/);\n    return match ? match[1] : null;\n  }\n}",
    "start_line": 4,
    "end_line": 76,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class SharingService",
    "component_id": "client.services.sharingService.SharingService"
  },
  "client.services.sharingService.createShareableLink": {
    "id": "client.services.sharingService.createShareableLink",
    "name": "createShareableLink",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/sharingService.ts",
    "relative_path": "client/services/sharingService.ts",
    "depends_on": [],
    "source_code": "static async createShareableLink(architectureId: string): Promise<string> {\n    try {\n      // The URL format will be: https://atelier.inc.net/architecture/{architectureId}\n      // When someone visits this URL, they'll be prompted to sign in if not authenticated\n      // Then the architecture will be loaded as the top/selected one\n      const shareUrl = `${this.SHARE_DOMAIN}/architecture/${architectureId}`;\n      \n      console.log('üîó Created shareable link:', shareUrl);\n      return shareUrl;\n    } catch (error) {\n      console.error('‚ùå Error creating shareable link:', error);\n      throw new Error('Failed to create shareable link');\n    }\n  }",
    "start_line": 10,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method createShareableLink",
    "component_id": "client.services.sharingService.createShareableLink"
  },
  "client.services.sharingService.shareArchitecture": {
    "id": "client.services.sharingService.shareArchitecture",
    "name": "shareArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/sharingService.ts",
    "relative_path": "client/services/sharingService.ts",
    "depends_on": [],
    "source_code": "static async shareArchitecture(architectureId: string): Promise<void> {\n    try {\n      const shareUrl = await this.createShareableLink(architectureId);\n      \n      // Copy to clipboard\n      await navigator.clipboard.writeText(shareUrl);\n      console.log('‚úÖ Architecture link copied to clipboard:', shareUrl);\n      \n      return;\n    } catch (error) {\n      console.error('‚ùå Error sharing architecture:', error);\n      throw new Error('Failed to share architecture');\n    }\n  }",
    "start_line": 28,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method shareArchitecture",
    "component_id": "client.services.sharingService.shareArchitecture"
  },
  "client.services.sharingService.loadSharedArchitecture": {
    "id": "client.services.sharingService.loadSharedArchitecture",
    "name": "loadSharedArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/sharingService.ts",
    "relative_path": "client/services/sharingService.ts",
    "depends_on": [],
    "source_code": "static async loadSharedArchitecture(architectureId: string): Promise<SavedArchitecture | null> {\n    try {\n      // This would be called when someone visits https://atelier.inc.net/architecture/{architectureId}\n      // First ensure user is authenticated\n      if (!auth.currentUser) {\n        throw new Error('User must be signed in to view shared architectures');\n      }\n\n      // Load the architecture from Firebase\n      // Note: We'll need to modify ArchitectureService to allow loading any public architecture\n      // For now, this assumes the architecture is accessible to the current user\n      console.log('üîç Loading shared architecture:', architectureId);\n      \n      // This is a placeholder - we'd need to implement a method to load any architecture by ID\n      // regardless of ownership (if it's marked as shareable)\n      return null;\n    } catch (error) {\n      console.error('‚ùå Error loading shared architecture:', error);\n      throw error;\n    }\n  }",
    "start_line": 46,
    "end_line": 66,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architectureId"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static async method loadSharedArchitecture",
    "component_id": "client.services.sharingService.loadSharedArchitecture"
  },
  "client.services.sharingService.getSharedArchitectureIdFromUrl": {
    "id": "client.services.sharingService.getSharedArchitectureIdFromUrl",
    "name": "getSharedArchitectureIdFromUrl",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/sharingService.ts",
    "relative_path": "client/services/sharingService.ts",
    "depends_on": [],
    "source_code": "static getSharedArchitectureIdFromUrl(): string | null {\n    const urlPath = window.location.pathname;\n    const match = urlPath.match(/\\/architecture\\/([^\\/]+)$/);\n    return match ? match[1] : null;\n  }",
    "start_line": 71,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "static method getSharedArchitectureIdFromUrl",
    "component_id": "client.services.sharingService.getSharedArchitectureIdFromUrl"
  },
  "client.services.syncArchitectures.SyncArchitectureOptions": {
    "id": "client.services.syncArchitectures.SyncArchitectureOptions",
    "name": "SyncArchitectureOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/syncArchitectures.ts",
    "relative_path": "client/services/syncArchitectures.ts",
    "depends_on": [],
    "source_code": "interface SyncArchitectureOptions {\n  userId: string;\n  isPublicMode: boolean;\n  urlArchitectureProcessed: boolean;\n  callback: {\n    setIsLoadingArchitectures: (loading: boolean) => void;\n    setSavedArchitectures: (archs: any[]) => void;\n    setSelectedArchitectureId: (id: string) => void;\n    setCurrentChatName: (name: string) => void;\n    setRawGraph: (graph: any) => void;\n    setPendingArchitectureSelection: (id: string | null) => void;\n  };\n}",
    "start_line": 9,
    "end_line": 21,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface SyncArchitectureOptions",
    "component_id": "client.services.syncArchitectures.SyncArchitectureOptions"
  },
  "client.services.syncArchitectures.syncWithFirebase": {
    "id": "client.services.syncArchitectures.syncWithFirebase",
    "name": "syncWithFirebase",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/syncArchitectures.ts",
    "relative_path": "client/services/syncArchitectures.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.services.syncArchitectures.logTabOrder",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.services.syncArchitectures.convertFirebaseArch",
      "client.services.architectureService.cleanupInvalidArchitectures",
      "client.services.syncArchitectures.handleArchitectureSelection",
      "client.services.syncArchitectures.handlePriorityArchitecture",
      "client.services.syncArchitectures.SyncArchitectureOptions",
      "scripts.test-vercel-preview.error",
      "client.services.architectureService.loadUserArchitectures"
    ],
    "source_code": "async function syncWithFirebase(options: SyncArchitectureOptions): Promise<void> {\n  const {\n    userId,\n    isPublicMode,\n    urlArchitectureProcessed,\n    callback\n  } = options;\n\n  console.log('üîÑ [FIREBASE-SYNC] Starting sync with options:', {\n    userId,\n    isPublicMode,\n    urlArchitectureProcessed,\n    hasCallback: !!callback\n  });\n\n  // Don't load architectures in public mode\n  if (isPublicMode) {\n    console.log('üîí [FIREBASE-SYNC] Public mode - skipping Firebase sync');\n    return;\n  }\n  \n  // Always sync Firebase architectures, but handle URL architecture processing differently\n  if (urlArchitectureProcessed) {\n    console.log('üîó [FIREBASE-SYNC] URL architecture already processed - proceeding with Firebase sync for historical tabs');\n  }\n  \n  let timeoutId: NodeJS.Timeout;\n  \n  try {\n    console.log('üîÑ Syncing with Firebase for user:', userId);\n    console.log('üîÑ Setting loading state to true');\n    callback.setIsLoadingArchitectures(true);\n    \n    // Add timeout to prevent infinite loading\n    timeoutId = setTimeout(() => {\n      console.warn('‚ö†Ô∏è Firebase sync timeout - forcing loading state to false');\n      callback.setIsLoadingArchitectures(false);\n    }, 10000); // 10 second timeout\n    \n    // First, cleanup any invalid architectures\n    await ArchitectureService.cleanupInvalidArchitectures(userId);\n    \n    const firebaseArchs = await ArchitectureService.loadUserArchitectures(userId);\n    // Raw Firebase architectures loaded\n    \n    if (firebaseArchs.length > 0) {\n      // Convert Firebase architectures to local format with validation\n      const validArchs = firebaseArchs.filter(arch => {\n        const isValid = arch && arch.id && arch.name && arch.rawGraph;\n        if (!isValid) {\n          console.warn('‚ö†Ô∏è Invalid architecture found, skipping:', arch);\n        }\n        return isValid;\n      }).map(arch => {\n        return convertFirebaseArch(arch);\n      });\n      \n      // Keep \"New Architecture\" at top, add Firebase data after\n      const newArchTab = {\n        id: 'new-architecture',\n        name: 'New Architecture',\n        timestamp: new Date(),\n        rawGraph: { id: \"root\", children: [], edges: [] },\n        isNew: true\n      };\n      \n      // No mock architectures - only real user architectures from Firebase\n      const sortedValidArchs = validArchs.sort((a, b) => (b.createdAt || b.timestamp).getTime() - (a.createdAt || a.timestamp).getTime());\n      \n      // Handle priority architecture (transferred from anonymous session)\n      const { finalValidArchs, priorityArchId } = await handlePriorityArchitecture(sortedValidArchs);\n\n      // Only include \"New Architecture\" tab if user has no existing architectures\n      const allArchs = finalValidArchs.length > 0 ? finalValidArchs : [newArchTab];\n      callback.setSavedArchitectures(allArchs);\n\n      console.log(`‚úÖ Loaded ${validArchs.length} valid architectures from Firebase`);\n      console.log(`üìä Total architectures: ${allArchs.length}`);\n\n      // Log current tab order for debugging\n      logTabOrder(allArchs);\n\n      // Handle architecture selection\n      await handleArchitectureSelection(allArchs, finalValidArchs, priorityArchId, callback);\n    }\n  } catch (error) {\n    console.error('‚ùå Failed to sync with Firebase:', error);\n  } finally {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    console.log('üîÑ Setting loading state to false');\n    callback.setIsLoadingArchitectures(false);\n  }\n}",
    "start_line": 27,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function syncWithFirebase",
    "component_id": "client.services.syncArchitectures.syncWithFirebase"
  },
  "client.services.syncArchitectures.convertFirebaseArch": {
    "id": "client.services.syncArchitectures.convertFirebaseArch",
    "name": "convertFirebaseArch",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/syncArchitectures.ts",
    "relative_path": "client/services/syncArchitectures.ts",
    "depends_on": [
      "client.services.syncArchitectures.safeTimestampConversion"
    ],
    "source_code": "function convertFirebaseArch(arch: any) {\n  const safeTimestamp = safeTimestampConversion(arch.timestamp);\n  const safeCreatedAt = safeTimestampConversion(arch.createdAt) || safeTimestamp;\n  const safeLastModified = safeTimestampConversion(arch.lastModified) || safeTimestamp;\n  \n  return {\n    id: arch.id,\n    firebaseId: arch.id,\n    name: arch.name,\n    timestamp: safeTimestamp,\n    createdAt: safeCreatedAt,\n    lastModified: safeLastModified,\n    rawGraph: arch.rawGraph,\n    userPrompt: arch.userPrompt || '',\n    isFromFirebase: true\n  };\n}",
    "start_line": 126,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "arch"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convertFirebaseArch",
    "component_id": "client.services.syncArchitectures.convertFirebaseArch"
  },
  "client.services.syncArchitectures.safeTimestampConversion": {
    "id": "client.services.syncArchitectures.safeTimestampConversion",
    "name": "safeTimestampConversion",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/syncArchitectures.ts",
    "relative_path": "client/services/syncArchitectures.ts",
    "depends_on": [],
    "source_code": "function safeTimestampConversion(timestamp: any): Date {\n  try {\n    // Check if it's a Firebase Timestamp with seconds/nanoseconds\n    if (timestamp?.seconds !== undefined) {\n      return new Date(timestamp.seconds * 1000 + (timestamp.nanoseconds || 0) / 1000000);\n    }\n    // Check if it has toDate method\n    if (timestamp?.toDate) {\n      return timestamp.toDate();\n    }\n    // Check if it's already a Date\n    if (timestamp instanceof Date) {\n      return timestamp;\n    }\n    // Try to parse as string/number\n    if (timestamp) {\n      const converted = new Date(timestamp);\n      if (!isNaN(converted.getTime())) {\n        return converted;\n      }\n    }\n    // Fallback to current time\n    return new Date();\n  } catch (e) {\n    return new Date();\n  }\n}",
    "start_line": 147,
    "end_line": 173,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "timestamp"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function safeTimestampConversion",
    "component_id": "client.services.syncArchitectures.safeTimestampConversion"
  },
  "client.services.syncArchitectures.handlePriorityArchitecture": {
    "id": "client.services.syncArchitectures.handlePriorityArchitecture",
    "name": "handlePriorityArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/syncArchitectures.ts",
    "relative_path": "client/services/syncArchitectures.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.services.architectureService.getArchitectureById",
      "client.services.syncArchitectures.convertFirebaseArch"
    ],
    "source_code": "async function handlePriorityArchitecture(sortedValidArchs: any[]): Promise<{ finalValidArchs: any[], priorityArchId: string | null }> {\n  const priorityArchId = localStorage.getItem('priority_architecture_id');\n  console.log('üî• [PRIORITY-ARCH] Priority architecture ID from localStorage:', priorityArchId);\n  console.log('üî• [PRIORITY-ARCH] Available arch IDs:', sortedValidArchs.map(a => a.id));\n  console.log('üî• [PRIORITY-ARCH] Current localStorage keys:', Object.keys(localStorage));\n\n  let finalValidArchs = sortedValidArchs;\n\n  if (priorityArchId) {\n    console.log('üî• [PRIORITY-ARCH] üìå Checking for priority architecture:', priorityArchId);\n    const priorityArchIndex = sortedValidArchs.findIndex(arch => arch.id === priorityArchId);\n\n    if (priorityArchIndex >= 0) {\n      console.log('üî• [PRIORITY-ARCH] ‚úÖ Found priority architecture in existing list, moving to top');\n      const priorityArch = sortedValidArchs[priorityArchIndex];\n      finalValidArchs = [\n        priorityArch,\n        ...sortedValidArchs.filter(arch => arch.id !== priorityArchId)\n      ];\n      localStorage.removeItem('priority_architecture_id');\n      console.log('üî• [PRIORITY-ARCH] üßπ Cleared priority architecture flag');\n    } else {\n      console.log('üî• [PRIORITY-ARCH] ‚ö†Ô∏è Priority architecture not found in existing list, fetching directly...');\n\n      try {\n        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for Firebase consistency\n\n        const priorityArch = await ArchitectureService.getArchitectureById(priorityArchId);\n        if (priorityArch) {\n          console.log('üî• [PRIORITY-ARCH] ‚úÖ Found priority architecture via direct fetch:', priorityArch.name);\n          const convertedArch = convertFirebaseArch(priorityArch);\n          finalValidArchs = [convertedArch, ...sortedValidArchs];\n          localStorage.removeItem('priority_architecture_id');\n          console.log('üî• [PRIORITY-ARCH] üßπ Cleared priority architecture flag');\n        } else {\n          console.log('üî• [PRIORITY-ARCH] ‚ùå Priority architecture not found even with direct fetch');\n        }\n      } catch (error) {\n        console.error('üî• [PRIORITY-ARCH] ‚ùå Error fetching priority architecture:', error);\n      }\n    }\n  } else {\n    console.log('üî• [PRIORITY-ARCH] No priority architecture ID found in localStorage');\n  }\n\n  console.log('üî• [PRIORITY-ARCH] Final architectures after priority handling:', finalValidArchs.map(a => ({id: a.id, name: a.name})));\n  return { finalValidArchs, priorityArchId };\n}",
    "start_line": 179,
    "end_line": 226,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sortedValidArchs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handlePriorityArchitecture",
    "component_id": "client.services.syncArchitectures.handlePriorityArchitecture"
  },
  "client.services.syncArchitectures.logTabOrder": {
    "id": "client.services.syncArchitectures.logTabOrder",
    "name": "logTabOrder",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/syncArchitectures.ts",
    "relative_path": "client/services/syncArchitectures.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function logTabOrder(allArchs: any[]): void {\n  console.log('üîç Current tab order:', allArchs.map((arch, index) => {\n    let createdAtStr = 'null';\n    let timestampStr = 'null';\n    \n    try {\n      if (arch.createdAt) {\n        createdAtStr = new Date(arch.createdAt).toISOString();\n      }\n      if (arch.timestamp) {\n        timestampStr = new Date(arch.timestamp).toISOString();\n      }\n    } catch (e) {\n      createdAtStr = `invalid(${arch.createdAt})`;\n      timestampStr = `invalid(${arch.timestamp})`;\n    }\n    \n    return `${index + 1}. ${arch.name} (${arch.id}) - createdAt: ${createdAtStr}, timestamp: ${timestampStr}`;\n  }));\n}",
    "start_line": 231,
    "end_line": 250,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "allArchs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logTabOrder",
    "component_id": "client.services.syncArchitectures.logTabOrder"
  },
  "client.services.syncArchitectures.handleArchitectureSelection": {
    "id": "client.services.syncArchitectures.handleArchitectureSelection",
    "name": "handleArchitectureSelection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/services/syncArchitectures.ts",
    "relative_path": "client/services/syncArchitectures.ts",
    "depends_on": [
      "client.services.syncArchitectures.SyncArchitectureOptions",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "async function handleArchitectureSelection(\n  allArchs: any[],\n  finalValidArchs: any[],\n  priorityArchId: string | null,\n  callback: SyncArchitectureOptions['callback']\n): Promise<void> {\n  const { setSelectedArchitectureId, setCurrentChatName, setRawGraph, setPendingArchitectureSelection } = callback;\n\n  // Find priority architecture in final list using the ID we captured before removal\n  const foundPriorityArch = priorityArchId ? allArchs.find(arch => arch.id === priorityArchId) : null;\n\n  // Handle architecture selection\n  if (foundPriorityArch) {\n    console.log('‚úÖ User signed in - will auto-select transferred architecture after state update:', foundPriorityArch.id, foundPriorityArch.name);\n    setPendingArchitectureSelection(foundPriorityArch.id);\n  } else if (finalValidArchs.length > 0) {\n    // If user has architectures, auto-select the first one\n    const firstArch = finalValidArchs[0];\n    console.log('üìã User has existing architectures - auto-selecting first one:', firstArch.name);\n    setSelectedArchitectureId(firstArch.id);\n    setCurrentChatName(firstArch.name);\n\n    // Load the architecture content\n    if (firstArch.rawGraph) {\n      console.log('üìÇ Loading existing architecture content to replace empty canvas');\n      setRawGraph(firstArch.rawGraph);\n    }\n  } else {\n    console.log('üìã User has no existing architectures - will add New Architecture tab');\n    const newArchTab = {\n      id: 'new-architecture',\n      name: 'New Architecture',\n      timestamp: new Date(),\n      rawGraph: { id: \"root\", children: [], edges: [] },\n      isNew: true\n    };\n\n    setSelectedArchitectureId('new-architecture');\n    setCurrentChatName('New Architecture');\n  }\n}",
    "start_line": 255,
    "end_line": 295,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "allArchs",
      "finalValidArchs",
      "priorityArchId",
      "callback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function handleArchitectureSelection",
    "component_id": "client.services.syncArchitectures.handleArchitectureSelection"
  },
  "client.state.viewStateOrchestrator.mergeViewState": {
    "id": "client.state.viewStateOrchestrator.mergeViewState",
    "name": "mergeViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/state/viewStateOrchestrator.ts",
    "relative_path": "client/state/viewStateOrchestrator.ts",
    "depends_on": [],
    "source_code": "function mergeViewState(current: any, delta: any): any {\n  return { ...current, ...delta };\n}",
    "start_line": 1,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "current",
      "delta"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function mergeViewState",
    "component_id": "client.state.viewStateOrchestrator.mergeViewState"
  },
  "client.types.chat.ChatBoxProps": {
    "id": "client.types.chat.ChatBoxProps",
    "name": "ChatBoxProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/chat.ts",
    "relative_path": "client/types/chat.ts",
    "depends_on": [],
    "source_code": "interface ChatBoxProps {\n  onSubmit: (message: string) => void;\n  onProcessStart?: () => void;\n  isSessionActive?: boolean;\n  isConnecting?: boolean;\n  isAgentReady?: boolean;\n  onStartSession?: () => void;\n  onStopSession?: () => void;\n  onTriggerReasoning?: () => void;\n  isDisabled?: boolean;\n}",
    "start_line": 1,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChatBoxProps",
    "component_id": "client.types.chat.ChatBoxProps"
  },
  "client.types.chat.Message": {
    "id": "client.types.chat.Message",
    "name": "Message",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/chat.ts",
    "relative_path": "client/types/chat.ts",
    "depends_on": [],
    "source_code": "interface Message {\n  id: string;\n  content: string;\n  sender: 'user' | 'assistant' | 'system';\n  type?: 'radio-question' | 'checkbox-question' | 'reasoning' | 'function-calling' | 'process-complete';\n  question?: string;\n  options?: Array<{\n    id: string;\n    text: string;\n  }>;\n  // New fields for streaming messages\n  isStreaming?: boolean;\n  streamedContent?: string;\n  isDropdownOpen?: boolean;\n  animationType?: 'reasoning' | 'function-calling';\n}",
    "start_line": 13,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Message",
    "component_id": "client.types.chat.Message"
  },
  "client.types.chat.ChatWindowProps": {
    "id": "client.types.chat.ChatWindowProps",
    "name": "ChatWindowProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/chat.ts",
    "relative_path": "client/types/chat.ts",
    "depends_on": [
      "client.types.chat.Message"
    ],
    "source_code": "interface ChatWindowProps {\n  messages: Message[];\n  isMinimized?: boolean;\n}",
    "start_line": 30,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ChatWindowProps",
    "component_id": "client.types.chat.ChatWindowProps"
  },
  "client.types.chat.InteractiveCanvasProps": {
    "id": "client.types.chat.InteractiveCanvasProps",
    "name": "InteractiveCanvasProps",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/chat.ts",
    "relative_path": "client/types/chat.ts",
    "depends_on": [],
    "source_code": "interface InteractiveCanvasProps {\n  isSessionActive?: boolean;\n  isConnecting?: boolean;\n  isAgentReady?: boolean;\n  startSession?: () => void;\n  stopSession?: () => void;\n  sendTextMessage?: (message: string) => void;\n  sendClientEvent?: (message: any) => void;\n  events?: any[]; // Add events from the server\n  apiEndpoint?: string; // API endpoint for backend calls\n  isPublicMode?: boolean; // Enable public/embedded mode\n  rightPanelCollapsed?: boolean; // Right panel collapse state for button positioning\n}",
    "start_line": 35,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface InteractiveCanvasProps",
    "component_id": "client.types.chat.InteractiveCanvasProps"
  },
  "client.types.chat.ElkLabel": {
    "id": "client.types.chat.ElkLabel",
    "name": "ElkLabel",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/chat.ts",
    "relative_path": "client/types/chat.ts",
    "depends_on": [],
    "source_code": "interface ElkLabel {\n  text: string;\n  x?: number;\n  y?: number;\n}",
    "start_line": 49,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkLabel",
    "component_id": "client.types.chat.ElkLabel"
  },
  "client.types.global.d.Window": {
    "id": "client.types.global.d.Window",
    "name": "Window",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/global.d.ts",
    "relative_path": "client/types/global.d.ts",
    "depends_on": [],
    "source_code": "interface Window {\n    __RUNTIME_CONFIG__?: {\n      OPENAI_API_KEY?: string;\n    };\n  }",
    "start_line": 2,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Window",
    "component_id": "client.types.global.d.Window"
  },
  "client.types.graph.NodeID": {
    "id": "client.types.graph.NodeID",
    "name": "NodeID",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [],
    "source_code": "type NodeID = string;",
    "start_line": 3,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type NodeID",
    "component_id": "client.types.graph.NodeID"
  },
  "client.types.graph.EdgeID": {
    "id": "client.types.graph.EdgeID",
    "name": "EdgeID",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [],
    "source_code": "type EdgeID = string;",
    "start_line": 4,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type EdgeID",
    "component_id": "client.types.graph.EdgeID"
  },
  "client.types.graph.createNodeID": {
    "id": "client.types.graph.createNodeID",
    "name": "createNodeID",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [
      "client.types.graph.NodeID"
    ],
    "source_code": "createNodeID = (name: string): NodeID => {\n  if (typeof name !== 'string' || name === undefined || name === null) {\n    throw new Error(`createNodeID requires a valid string, got: ${typeof name} - ${JSON.stringify(name)}`);\n  }\n  return name.toLowerCase().replace(/\\s+/g, '_');\n}",
    "start_line": 6,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function createNodeID",
    "component_id": "client.types.graph.createNodeID"
  },
  "client.types.graph.createEdgeID": {
    "id": "client.types.graph.createEdgeID",
    "name": "createEdgeID",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [
      "client.types.graph.NodeID",
      "client.types.graph.EdgeID"
    ],
    "source_code": "createEdgeID = (source: NodeID, target: NodeID): EdgeID => `edge_${source}_to_${target}`",
    "start_line": 13,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "source",
      "target"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function createEdgeID",
    "component_id": "client.types.graph.createEdgeID"
  },
  "client.types.graph.CustomNode": {
    "id": "client.types.graph.CustomNode",
    "name": "CustomNode",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [],
    "source_code": "interface CustomNode extends Node {\n  parentId?: string;\n}",
    "start_line": 15,
    "end_line": 17,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CustomNode",
    "component_id": "client.types.graph.CustomNode"
  },
  "client.types.graph.NodeData": {
    "id": "client.types.graph.NodeData",
    "name": "NodeData",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [],
    "source_code": "interface NodeData {\n  label: string;\n  width?: number;\n  height?: number;\n  isParent?: boolean;\n  leftHandles?: string[];\n  rightHandles?: string[];\n  position?: { x: number; y: number };\n}",
    "start_line": 19,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeData",
    "component_id": "client.types.graph.NodeData"
  },
  "client.types.graph.EdgeData": {
    "id": "client.types.graph.EdgeData",
    "name": "EdgeData",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [],
    "source_code": "interface EdgeData {\n  bendPoints?: { x: number; y: number }[];\n}",
    "start_line": 29,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeData",
    "component_id": "client.types.graph.EdgeData"
  },
  "client.types.graph.ElkGraphNode": {
    "id": "client.types.graph.ElkGraphNode",
    "name": "ElkGraphNode",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [
      "client.types.graph.ElkGraphEdge",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "interface ElkGraphNode {\n  id: string;\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  labels?: { text: string }[];\n  children?: ElkGraphNode[];\n  edges?: ElkGraphEdge[];\n  mode?: 'FREE' | 'LOCK';  // default FREE - controls auto-layout behavior\n  data?: {\n    label?: string;\n    icon?: string;\n    [key: string]: any;\n  };\n}",
    "start_line": 33,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkGraphNode",
    "component_id": "client.types.graph.ElkGraphNode"
  },
  "client.types.graph.ElkGraphEdge": {
    "id": "client.types.graph.ElkGraphEdge",
    "name": "ElkGraphEdge",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [],
    "source_code": "interface ElkGraphEdge {\n  id: string;\n  sources: string[];\n  targets: string[];\n  labels?: { text: string }[];\n  sections?: {\n    startPoint: { x: number; y: number };\n    endPoint: { x: number; y: number };\n    bendPoints?: { x: number; y: number }[];\n  }[];\n  data?: {\n    sourceHandle?: string;\n    targetHandle?: string;\n    [key: string]: any;\n  };\n}",
    "start_line": 50,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkGraphEdge",
    "component_id": "client.types.graph.ElkGraphEdge"
  },
  "client.types.graph.ElkGraph": {
    "id": "client.types.graph.ElkGraph",
    "name": "ElkGraph",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/types/graph.ts",
    "relative_path": "client/types/graph.ts",
    "depends_on": [
      "client.types.graph.ElkGraphEdge",
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "interface ElkGraph {\n  id: string;\n  children?: ElkGraphNode[];\n  edges?: ElkGraphEdge[];\n}",
    "start_line": 67,
    "end_line": 71,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkGraph",
    "component_id": "client.types.graph.ElkGraph"
  },
  "client.utils.anonymousSave.AnonymousArchitectureService": {
    "id": "client.utils.anonymousSave.AnonymousArchitectureService",
    "name": "AnonymousArchitectureService",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/anonymousSave.ts",
    "relative_path": "client/utils/anonymousSave.ts",
    "depends_on": [],
    "source_code": "interface AnonymousArchitectureService {\n  getArchitectureIdFromUrl(): string | null;\n  saveAnonymousArchitecture(name: string, graph: any, userPrompt?: string): Promise<string>;\n  updateAnonymousArchitecture(id: string, payload: any): Promise<void>;\n}",
    "start_line": 15,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AnonymousArchitectureService",
    "component_id": "client.utils.anonymousSave.AnonymousArchitectureService"
  },
  "client.utils.anonymousSave.ensureAnonymousSaved": {
    "id": "client.utils.anonymousSave.ensureAnonymousSaved",
    "name": "ensureAnonymousSaved",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/anonymousSave.ts",
    "relative_path": "client/utils/anonymousSave.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.services.anonymousArchitectureService.getArchitectureIdFromUrl",
      "client.utils.naming.generateNameWithFallback",
      "client.utils.anonymousSave.AnonymousArchitectureService",
      "client.services.anonymousArchitectureService.saveAnonymousArchitecture",
      "client.services.anonymousArchitectureService.updateAnonymousArchitecture",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function ensureAnonymousSaved({\n  rawGraph,\n  userPrompt,\n  anonymousService,\n  existingId,\n  metadata = {},\n}: {\n  rawGraph: any;\n  userPrompt?: string;\n  anonymousService: AnonymousArchitectureService;\n  existingId?: string | null;\n  metadata?: any;\n}) {\n  console.log('üíæ ensureAnonymousSaved called with:', { \n    hasGraph: !!rawGraph,\n    hasPrompt: !!userPrompt,\n    hasExisting: !!existingId,\n    nodeCount: rawGraph?.children?.length || 0\n  });\n\n  try {\n    const id = existingId ?? anonymousService.getArchitectureIdFromUrl();\n    \n    if (id) {\n      // Update existing anonymous architecture\n      console.log('üîÑ Updating existing anonymous architecture:', id);\n      \n      const updatePayload = {\n        rawGraph,\n        timestamp: Timestamp.now(),\n        ...metadata\n      };\n      \n      await anonymousService.updateAnonymousArchitecture(id, updatePayload);\n      console.log('‚úÖ Anonymous architecture updated successfully');\n      return id;\n    }\n    \n    // Create new anonymous architecture with AI-generated name\n    console.log('ü§ñ Generating name for new anonymous architecture');\n    const name = await generateNameWithFallback(rawGraph, userPrompt);\n\n    const newId = await anonymousService.saveAnonymousArchitecture(name, rawGraph, userPrompt);\n    console.log('‚úÖ New anonymous architecture saved with ID:', newId, 'with userPrompt:', userPrompt ? 'YES' : 'NO');\n    return newId;\n    \n  } catch (error) {\n    console.error('‚ùå ensureAnonymousSaved failed:', error);\n    \n    // Check if this is the expected \"No document to update\" error after architecture transfer\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    if (errorMessage.includes('No document to update') || errorMessage.includes('Document does not exist')) {\n      console.log('üìù Architecture mayÂ∑≤Ë¢´ transferred to user account, this is expected');\n      return null;\n    }\n    \n    throw error;\n  }\n}",
    "start_line": 25,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function ensureAnonymousSaved",
    "component_id": "client.utils.anonymousSave.ensureAnonymousSaved"
  },
  "client.utils.anonymousSave.createAnonymousShare": {
    "id": "client.utils.anonymousSave.createAnonymousShare",
    "name": "createAnonymousShare",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/anonymousSave.ts",
    "relative_path": "client/utils/anonymousSave.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.services.anonymousArchitectureService.saveAnonymousArchitecture",
      "client.utils.anonymousSave.AnonymousArchitectureService"
    ],
    "source_code": "async function createAnonymousShare({\n  architectureName,\n  rawGraph,\n  anonymousService,\n}: {\n  architectureName: string;\n  rawGraph: any;\n  anonymousService: AnonymousArchitectureService;\n}) {\n  console.log('üì§ Creating anonymous share copy');\n  \n  const anonymousId = await anonymousService.saveAnonymousArchitecture(\n    `${architectureName} (Shared)`,\n    rawGraph\n  );\n  \n  console.log('‚úÖ Anonymous share created with ID:', anonymousId);\n  return anonymousId;\n}",
    "start_line": 89,
    "end_line": 107,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function createAnonymousShare",
    "component_id": "client.utils.anonymousSave.createAnonymousShare"
  },
  "client.utils.anonymousSave.autoSaveAnonymous": {
    "id": "client.utils.anonymousSave.autoSaveAnonymous",
    "name": "autoSaveAnonymous",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/anonymousSave.ts",
    "relative_path": "client/utils/anonymousSave.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.services.anonymousArchitectureService.saveAnonymousArchitecture",
      "client.utils.anonymousSave.AnonymousArchitectureService"
    ],
    "source_code": "async function autoSaveAnonymous({\n  rawGraph,\n  anonymousService,\n}: {\n  rawGraph: any;\n  anonymousService: AnonymousArchitectureService;\n}) {\n  console.log('‚è∞ Auto-saving anonymous architecture...');\n  \n  try {\n    const architectureName = `Architecture ${new Date().toLocaleDateString()}`;\n    const newArchId = await anonymousService.saveAnonymousArchitecture(\n      architectureName,\n      rawGraph\n    );\n    \n    console.log('‚úÖ Auto-save completed with ID:', newArchId);\n    return newArchId;\n  } catch (error) {\n    console.error('‚ùå Auto-save failed:', error);\n    return null;\n  }\n}",
    "start_line": 113,
    "end_line": 135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function autoSaveAnonymous",
    "component_id": "client.utils.anonymousSave.autoSaveAnonymous"
  },
  "client.utils.architectureSearchService.ReferenceArchitecture": {
    "id": "client.utils.architectureSearchService.ReferenceArchitecture",
    "name": "ReferenceArchitecture",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [],
    "source_code": "interface ReferenceArchitecture {\n  cloud: string;\n  group: string;\n  subgroup: string;\n  source: string;\n  description: string;\n  architecture: string;\n}",
    "start_line": 3,
    "end_line": 10,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ReferenceArchitecture",
    "component_id": "client.utils.architectureSearchService.ReferenceArchitecture"
  },
  "client.utils.architectureSearchService.ArchitectureSearchService": {
    "id": "client.utils.architectureSearchService.ArchitectureSearchService",
    "name": "ArchitectureSearchService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.architectureSearchService.initializeWithPrecomputedData",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.architectureSearchService.performSearch",
      "client.utils.architectureSearchService.embedQuery",
      "client.utils.architectureSearchService.cosineSimilarity",
      "client.utils.architectureSearchService.ReferenceArchitecture",
      "scripts.precompute-icon-embeddings.cosineSimilarity"
    ],
    "source_code": "class ArchitectureSearchService {\n  private architectures: ReferenceArchitecture[] = [];\n  private embeddings: Map<string, number[]> = new Map();\n  private queryCache: Map<string, number[]> = new Map();   // reuse queries\n  private isInitialized = false;\n  \n  constructor() {\n    this.initializeWithPrecomputedData();\n  }\n  \n  private initializeWithPrecomputedData(): void {\n    // Skip initialization in server environment\n    if (typeof window === 'undefined') {\n      console.log('üö´ ArchitectureSearchService: Skipping initialization in server environment');\n      return;\n    }\n\n\n    \n    // STRICT: Only work with pre-computed data - NO FALLBACKS\n    if (!precomputedEmbeddings) {\n      throw new Error('‚ùå FATAL: Pre-computed embeddings not found! Run `npm run precompute-embeddings` first.');\n    }\n    \n    if (!precomputedEmbeddings.architectures || precomputedEmbeddings.architectures.length === 0) {\n      throw new Error('‚ùå FATAL: Pre-computed embeddings file is empty! Run `npm run precompute-embeddings` first.');\n    }\n    \n    if (!precomputedEmbeddings.embeddings || Object.keys(precomputedEmbeddings.embeddings).length === 0) {\n      throw new Error('‚ùå FATAL: No embeddings found in pre-computed file! Run `npm run precompute-embeddings` first.');\n    }\n    \n    // Load architectures\n    this.architectures = precomputedEmbeddings.architectures;\n    \n    // Load embeddings\n    Object.entries(precomputedEmbeddings.embeddings).forEach(([text, embedding]) => {\n      this.embeddings.set(text, embedding as number[]);\n    });\n    \n\n\n    this.isInitialized = true;\n  }\n\n  /** Embed an arbitrary text once, then cache it. */\n  private async embedQuery(text: string): Promise<number[]> {\n    const key = text.toLowerCase();\n    if (this.queryCache.has(key)) {\n      console.log('üéØ Using cached embedding for:', key.substring(0, 50) + '...');\n      return this.queryCache.get(key)!;\n    }\n\n    console.log('üîÑ Generating new embedding for:', key.substring(0, 50) + '...');\n    const startTime = performance.now();\n\n    // Call the backend instead of the OpenAI SDK\n    const res = await fetch('/api/embed', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: key })\n    });\n\n    if (!res.ok) {\n      const detail = await res.text();\n      throw new Error(`‚ùå FATAL: Backend /api/embed failed ${res.status}: ${detail}. Check if server is running on correct port!`);\n    }\n\n    const { embedding } = await res.json();\n    const endTime = performance.now();\n    console.log(`‚ö° Embedding generated in ${(endTime - startTime).toFixed(0)}ms`);\n    \n    this.queryCache.set(key, embedding);\n    return embedding as number[];\n  }\n\n  private cosineSimilarity(a: number[], b: number[]): number {\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n    \n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n    \n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n\n  public async findMatchingArchitecture(userInput: string): Promise<ReferenceArchitecture | null> {\n    if (!this.isInitialized) {\n      throw new Error('‚ùå FATAL: ArchitectureSearchService not initialized! Pre-computed embeddings failed to load.');\n    }\n\n    console.log('üîç Starting architecture search for:', userInput);\n    return await this.performSearch(userInput);\n  }\n\n  private async performSearch(userInput: string): Promise<ReferenceArchitecture | null> {\n    // 1Ô∏è‚É£ embed the query\n    console.log('üîÑ Embedding user query...');\n    const queryVec = await this.embedQuery(userInput);\n    console.log('‚úÖ Query embedded successfully');\n\n    // 2Ô∏è‚É£ cosine-similarity over ALL reference vectors\n    let bestArch: ReferenceArchitecture | null = null;\n    let bestScore = -Infinity;\n\n    for (const arch of this.architectures) {\n      const key = `${arch.cloud} ${arch.group} ${arch.subgroup} ${arch.description}`.toLowerCase();\n      const vec = this.embeddings.get(key);\n      if (!vec) continue;                           // should not happen\n\n      const score = this.cosineSimilarity(queryVec, vec);\n      if (score > bestScore) {\n        bestScore = score;\n        bestArch  = arch;\n      }\n    }\n\n    if (bestArch) {\n\n    } else {\n      console.warn('‚ö†Ô∏è No architecture matched');\n    }\n    return bestArch;\n  }\n\n  public getAvailableArchitectures(): ReferenceArchitecture[] {\n    if (!this.isInitialized) {\n      throw new Error('‚ùå ArchitectureSearchService: Not initialized with pre-computed embeddings');\n    }\n    return this.architectures;\n  }\n}",
    "start_line": 12,
    "end_line": 147,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class ArchitectureSearchService",
    "component_id": "client.utils.architectureSearchService.ArchitectureSearchService"
  },
  "client.utils.architectureSearchService.initializeWithPrecomputedData": {
    "id": "client.utils.architectureSearchService.initializeWithPrecomputedData",
    "name": "initializeWithPrecomputedData",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [],
    "source_code": "private initializeWithPrecomputedData(): void {\n    // Skip initialization in server environment\n    if (typeof window === 'undefined') {\n      console.log('üö´ ArchitectureSearchService: Skipping initialization in server environment');\n      return;\n    }\n\n\n    \n    // STRICT: Only work with pre-computed data - NO FALLBACKS\n    if (!precomputedEmbeddings) {\n      throw new Error('‚ùå FATAL: Pre-computed embeddings not found! Run `npm run precompute-embeddings` first.');\n    }\n    \n    if (!precomputedEmbeddings.architectures || precomputedEmbeddings.architectures.length === 0) {\n      throw new Error('‚ùå FATAL: Pre-computed embeddings file is empty! Run `npm run precompute-embeddings` first.');\n    }\n    \n    if (!precomputedEmbeddings.embeddings || Object.keys(precomputedEmbeddings.embeddings).length === 0) {\n      throw new Error('‚ùå FATAL: No embeddings found in pre-computed file! Run `npm run precompute-embeddings` first.');\n    }\n    \n    // Load architectures\n    this.architectures = precomputedEmbeddings.architectures;\n    \n    // Load embeddings\n    Object.entries(precomputedEmbeddings.embeddings).forEach(([text, embedding]) => {\n      this.embeddings.set(text, embedding as number[]);\n    });\n    \n\n\n    this.isInitialized = true;\n  }",
    "start_line": 22,
    "end_line": 55,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method initializeWithPrecomputedData",
    "component_id": "client.utils.architectureSearchService.initializeWithPrecomputedData"
  },
  "client.utils.architectureSearchService.embedQuery": {
    "id": "client.utils.architectureSearchService.embedQuery",
    "name": "embedQuery",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [],
    "source_code": "private async embedQuery(text: string): Promise<number[]> {\n    const key = text.toLowerCase();\n    if (this.queryCache.has(key)) {\n      console.log('üéØ Using cached embedding for:', key.substring(0, 50) + '...');\n      return this.queryCache.get(key)!;\n    }\n\n    console.log('üîÑ Generating new embedding for:', key.substring(0, 50) + '...');\n    const startTime = performance.now();\n\n    // Call the backend instead of the OpenAI SDK\n    const res = await fetch('/api/embed', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ text: key })\n    });\n\n    if (!res.ok) {\n      const detail = await res.text();\n      throw new Error(`‚ùå FATAL: Backend /api/embed failed ${res.status}: ${detail}. Check if server is running on correct port!`);\n    }\n\n    const { embedding } = await res.json();\n    const endTime = performance.now();\n    console.log(`‚ö° Embedding generated in ${(endTime - startTime).toFixed(0)}ms`);\n    \n    this.queryCache.set(key, embedding);\n    return embedding as number[];\n  }",
    "start_line": 58,
    "end_line": 86,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method embedQuery",
    "component_id": "client.utils.architectureSearchService.embedQuery"
  },
  "client.utils.architectureSearchService.cosineSimilarity": {
    "id": "client.utils.architectureSearchService.cosineSimilarity",
    "name": "cosineSimilarity",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [],
    "source_code": "private cosineSimilarity(a: number[], b: number[]): number {\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n    \n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n    \n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }",
    "start_line": 88,
    "end_line": 100,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "a",
      "b"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method cosineSimilarity",
    "component_id": "client.utils.architectureSearchService.cosineSimilarity"
  },
  "client.utils.architectureSearchService.findMatchingArchitecture": {
    "id": "client.utils.architectureSearchService.findMatchingArchitecture",
    "name": "findMatchingArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [],
    "source_code": "public async findMatchingArchitecture(userInput: string): Promise<ReferenceArchitecture | null> {\n    if (!this.isInitialized) {\n      throw new Error('‚ùå FATAL: ArchitectureSearchService not initialized! Pre-computed embeddings failed to load.');\n    }\n\n    console.log('üîç Starting architecture search for:', userInput);\n    return await this.performSearch(userInput);\n  }",
    "start_line": 102,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "userInput"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method findMatchingArchitecture",
    "component_id": "client.utils.architectureSearchService.findMatchingArchitecture"
  },
  "client.utils.architectureSearchService.performSearch": {
    "id": "client.utils.architectureSearchService.performSearch",
    "name": "performSearch",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [],
    "source_code": "private async performSearch(userInput: string): Promise<ReferenceArchitecture | null> {\n    // 1Ô∏è‚É£ embed the query\n    console.log('üîÑ Embedding user query...');\n    const queryVec = await this.embedQuery(userInput);\n    console.log('‚úÖ Query embedded successfully');\n\n    // 2Ô∏è‚É£ cosine-similarity over ALL reference vectors\n    let bestArch: ReferenceArchitecture | null = null;\n    let bestScore = -Infinity;\n\n    for (const arch of this.architectures) {\n      const key = `${arch.cloud} ${arch.group} ${arch.subgroup} ${arch.description}`.toLowerCase();\n      const vec = this.embeddings.get(key);\n      if (!vec) continue;                           // should not happen\n\n      const score = this.cosineSimilarity(queryVec, vec);\n      if (score > bestScore) {\n        bestScore = score;\n        bestArch  = arch;\n      }\n    }\n\n    if (bestArch) {\n\n    } else {\n      console.warn('‚ö†Ô∏è No architecture matched');\n    }\n    return bestArch;\n  }",
    "start_line": 111,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "userInput"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method performSearch",
    "component_id": "client.utils.architectureSearchService.performSearch"
  },
  "client.utils.architectureSearchService.getAvailableArchitectures": {
    "id": "client.utils.architectureSearchService.getAvailableArchitectures",
    "name": "getAvailableArchitectures",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/architectureSearchService.ts",
    "relative_path": "client/utils/architectureSearchService.ts",
    "depends_on": [],
    "source_code": "public getAvailableArchitectures(): ReferenceArchitecture[] {\n    if (!this.isInitialized) {\n      throw new Error('‚ùå ArchitectureSearchService: Not initialized with pre-computed embeddings');\n    }\n    return this.architectures;\n  }",
    "start_line": 141,
    "end_line": 146,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getAvailableArchitectures",
    "component_id": "client.utils.architectureSearchService.getAvailableArchitectures"
  },
  "client.utils.canvas.canvasDeleteInteractions.DeleteInteractionsParams": {
    "id": "client.utils.canvas.canvasDeleteInteractions.DeleteInteractionsParams",
    "name": "DeleteInteractionsParams",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasDeleteInteractions.ts",
    "relative_path": "client/utils/canvas/canvasDeleteInteractions.ts",
    "depends_on": [
      "client.components.graph.types.index.RawGraph"
    ],
    "source_code": "interface DeleteInteractionsParams {\n  selectedNodes: Node[];\n  selectedEdges: Edge[];\n  rawGraph: RawGraph;\n  selectedArchitectureId?: string;\n  logDeletionAndSave?: (\n    deletedNodeIds: string[],\n    graphBeforeDelete: RawGraph,\n    graphAfterDelete: RawGraph,\n    architectureId?: string\n  ) => void;\n}",
    "start_line": 11,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface DeleteInteractionsParams",
    "component_id": "client.utils.canvas.canvasDeleteInteractions.DeleteInteractionsParams"
  },
  "client.utils.canvas.canvasDeleteInteractions.handleDeleteKey": {
    "id": "client.utils.canvas.canvasDeleteInteractions.handleDeleteKey",
    "name": "handleDeleteKey",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasDeleteInteractions.ts",
    "relative_path": "client/utils/canvas/canvasDeleteInteractions.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.canvas.canvasDeleteInteractions.DeleteInteractionsParams",
      "client.core.orchestration.Orchestrator.apply",
      "client.orchestration.types.EditIntent",
      "client.utils.viewstateDebug.logDeletionAndSave",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "function handleDeleteKey(\n  params: DeleteInteractionsParams\n): void {\n  const { selectedNodes, selectedEdges, rawGraph, selectedArchitectureId, logDeletionAndSave } = params;\n\n  if (selectedNodes.length === 0 && selectedEdges.length === 0) {\n    return;\n  }\n\n  // Delete selected nodes using Orchestrator - SEQUENTIALLY to avoid race conditions\n  const deletedNodeIds = selectedNodes.map(n => n.id);\n  const graphBeforeDelete = JSON.parse(JSON.stringify(rawGraph));\n\n  console.log(`[DELETE] Starting sequential deletion of ${selectedNodes.length} nodes and ${selectedEdges.length} edges`);\n\n  // Process deletions sequentially to avoid rendering race conditions\n  (async () => {\n    try {\n      // Delete nodes sequentially\n      for (const node of selectedNodes) {\n        const intent: EditIntent = {\n          source: 'user',\n          kind: 'free-structural',\n          scopeId: 'root',\n          payload: {\n            action: 'delete-node',\n            nodeId: node.id,\n          }\n        };\n        \n        try {\n          await apply(intent);\n          console.log(`[DELETE] ‚úÖ Successfully deleted node: ${node.id}`);\n        } catch (error) {\n          console.error(`‚ùå [DELETE] Error deleting node ${node.id}:`, error);\n        }\n      }\n\n      // Delete edges sequentially\n      for (const edge of selectedEdges) {\n        const intent: EditIntent = {\n          source: 'user',\n          kind: 'free-structural',\n          scopeId: 'root',\n          payload: {\n            action: 'delete-edge',\n            edgeId: edge.id,\n          }\n        };\n        \n        try {\n          await apply(intent);\n          console.log(`[DELETE] ‚úÖ Successfully deleted edge: ${edge.id}`);\n        } catch (error) {\n          console.error(`‚ùå [DELETE] Error deleting edge ${edge.id}:`, error);\n        }\n      }\n\n      console.log(`[DELETE] ‚úÖ Completed sequential deletion of all selected items`);\n      \n      // Log deletion after all operations complete\n      if (logDeletionAndSave) {\n        logDeletionAndSave(deletedNodeIds, graphBeforeDelete, rawGraph, selectedArchitectureId);\n      }\n    } catch (error) {\n      console.error(`‚ùå [DELETE] Fatal error during sequential deletion:`, error);\n    }\n  })();\n}",
    "start_line": 27,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handleDeleteKey",
    "component_id": "client.utils.canvas.canvasDeleteInteractions.handleDeleteKey"
  },
  "client.utils.canvas.canvasDragPersistence.persistViewStateAfterDrag": {
    "id": "client.utils.canvas.canvasDragPersistence.persistViewStateAfterDrag",
    "name": "persistViewStateAfterDrag",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasDragPersistence.ts",
    "relative_path": "client/utils/canvas/canvasDragPersistence.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState",
      "client.components.graph.types.index.RawGraph",
      "client.utils.canvasPersistence.saveCanvasSnapshot"
    ],
    "source_code": "function persistViewStateAfterDrag(\n  viewState: ViewState,\n  rawGraph: RawGraph | null,\n  selectedArchitectureId: string | undefined\n): void {\n  if (selectedArchitectureId && rawGraph) {\n    saveCanvasSnapshot(rawGraph, viewState, selectedArchitectureId);\n  }\n}",
    "start_line": 16,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "viewState",
      "rawGraph",
      "selectedArchitectureId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function persistViewStateAfterDrag",
    "component_id": "client.utils.canvas.canvasDragPersistence.persistViewStateAfterDrag"
  },
  "client.utils.canvas.canvasGroupInteractions.snapToGrid": {
    "id": "client.utils.canvas.canvasGroupInteractions.snapToGrid",
    "name": "snapToGrid",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasGroupInteractions.ts",
    "relative_path": "client/utils/canvas/canvasGroupInteractions.ts",
    "depends_on": [],
    "source_code": "snapToGrid = (value: number) => Math.round(value / GRID_SIZE) * GRID_SIZE",
    "start_line": 12,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function snapToGrid",
    "component_id": "client.utils.canvas.canvasGroupInteractions.snapToGrid"
  },
  "client.utils.canvas.canvasGroupInteractions.SetNodes": {
    "id": "client.utils.canvas.canvasGroupInteractions.SetNodes",
    "name": "SetNodes",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasGroupInteractions.ts",
    "relative_path": "client/utils/canvas/canvasGroupInteractions.ts",
    "depends_on": [],
    "source_code": "type SetNodes = React.Dispatch<React.SetStateAction<Node[]>>;",
    "start_line": 14,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type SetNodes",
    "component_id": "client.utils.canvas.canvasGroupInteractions.SetNodes"
  },
  "client.utils.canvas.canvasGroupInteractions.GroupToolPaneClickParams": {
    "id": "client.utils.canvas.canvasGroupInteractions.GroupToolPaneClickParams",
    "name": "GroupToolPaneClickParams",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasGroupInteractions.ts",
    "relative_path": "client/utils/canvas/canvasGroupInteractions.ts",
    "depends_on": [
      "client.utils.canvas.canvasGroupInteractions.SetNodes",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "interface GroupToolPaneClickParams {\n  event: ReactMouseEvent<HTMLDivElement, MouseEvent>;\n  selectedNodes: Node[];\n  reactFlowRef: MutableRefObject<ReactFlowInstance | null>;\n  handleGroupNodes: (nodeIds: string[], parentId: string, groupId: string, options?: unknown) => void;\n  handleBatchUpdate: (mutations: Array<Record<string, unknown>>) => void;\n  setNodes: SetNodes;\n  setSelectedNodes: React.Dispatch<React.SetStateAction<Node[]>>;\n  setSelectedTool: (tool: string) => void;\n  viewStateRef: MutableRefObject<ViewState | undefined>;\n  pendingSelectionRef: MutableRefObject<{ id: string; size?: { width: number; height: number } } | null>;\n  shouldSkipFitViewRef?: MutableRefObject<boolean | undefined>;\n}",
    "start_line": 16,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface GroupToolPaneClickParams",
    "component_id": "client.utils.canvas.canvasGroupInteractions.GroupToolPaneClickParams"
  },
  "client.utils.canvas.canvasGroupInteractions.groupSelectedNodes": {
    "id": "client.utils.canvas.canvasGroupInteractions.groupSelectedNodes",
    "name": "groupSelectedNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasGroupInteractions.ts",
    "relative_path": "client/utils/canvas/canvasGroupInteractions.ts",
    "depends_on": [
      "scripts.test-vercel-preview.error",
      "client.utils.canvas.canvasGroupInteractions.GroupToolPaneClickParams"
    ],
    "source_code": "groupSelectedNodes = ({\n  selectedNodes,\n  handleGroupNodes,\n  setNodes,\n  setSelectedNodes,\n  setSelectedTool,\n}: GroupToolPaneClickParams): boolean => {\n  if (selectedNodes.length === 0) {\n    return false;\n  }\n\n  const nodeIds = selectedNodes.map((node) => node.id);\n  const groupId = `group-${Date.now()}`;\n  const parentId = \"root\";\n\n  try {\n    handleGroupNodes(nodeIds, parentId, groupId, undefined);\n  } catch (error) {\n    console.error(\"[GroupTool] Failed to create group from selection:\", error);\n    return false;\n  }\n\n  setNodes((nodes) => nodes.map((node) => ({ ...node, selected: false })));\n  setSelectedNodes([]);\n  setSelectedTool(\"arrow\");\n\n  return true;\n}",
    "start_line": 30,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function groupSelectedNodes",
    "component_id": "client.utils.canvas.canvasGroupInteractions.groupSelectedNodes"
  },
  "client.utils.canvas.canvasGroupInteractions.createEmptyGroupAtPoint": {
    "id": "client.utils.canvas.canvasGroupInteractions.createEmptyGroupAtPoint",
    "name": "createEmptyGroupAtPoint",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasGroupInteractions.ts",
    "relative_path": "client/utils/canvas/canvasGroupInteractions.ts",
    "depends_on": [
      "scripts.test-vercel-preview.error",
      "client.utils.canvas.canvasGroupInteractions.GroupToolPaneClickParams",
      "client.utils.canvas.canvasGroupInteractions.snapToGrid",
      "client.types.graph.createNodeID"
    ],
    "source_code": "createEmptyGroupAtPoint = ({\n  event,\n  reactFlowRef,\n  viewStateRef,\n  shouldSkipFitViewRef,\n  handleBatchUpdate,\n  pendingSelectionRef,\n  setNodes,\n  setSelectedTool,\n}: GroupToolPaneClickParams): boolean => {\n  const reactFlow = reactFlowRef.current;\n  if (!reactFlow) {\n    return false;\n  }\n\n  const screenPoint = { x: event.clientX, y: event.clientY };\n  const flowPoint = reactFlow.screenToFlowPosition\n    ? reactFlow.screenToFlowPosition(screenPoint)\n    : reactFlow.project(screenPoint);\n\n  const topLeft = {\n    x: snapToGrid(flowPoint.x - GROUP_WIDTH / 2),\n    y: snapToGrid(flowPoint.y - GROUP_HEIGHT / 2),\n  };\n\n  const rawGroupName = `Draft group ${Date.now()}`;\n  const normalizedId = createNodeID(rawGroupName);\n\n  const view = viewStateRef.current ?? { node: {}, group: {}, edge: {} };\n  view.node = view.node || {};\n  view.group = view.group || {};\n  const groupGeometry = { x: topLeft.x, y: topLeft.y, w: GROUP_WIDTH, h: GROUP_HEIGHT };\n  view.node[normalizedId] = groupGeometry;\n  view.group[normalizedId] = groupGeometry;\n  viewStateRef.current = view;\n\n  if (shouldSkipFitViewRef?.current !== undefined) {\n    shouldSkipFitViewRef.current = true;\n  }\n\n  try {\n    handleBatchUpdate([\n      {\n        name: \"add_node\",\n        nodename: normalizedId,\n        parentId: \"root\",\n        data: {\n          label: \"Group\",\n          isGroup: true,\n          originalName: rawGroupName,\n        },\n      },\n    ]);\n  } catch (error) {\n    console.error(\"[GroupTool] Failed to add draft group node:\", error);\n    return false;\n  }\n\n  pendingSelectionRef.current = {\n    id: normalizedId,\n    size: { width: GROUP_WIDTH, height: GROUP_HEIGHT },\n  };\n\n  setSelectedTool(\"arrow\");\n\n  setTimeout(() => {\n    setNodes((nodes) => {\n      let found = false;\n      const updated = nodes.map((node) => {\n        if (node.id !== normalizedId) {\n          return node;\n        }\n        found = true;\n        return {\n          ...node,\n          selected: true,\n          position: topLeft,\n          data: {\n            ...node.data,\n            width: GROUP_WIDTH,\n            height: GROUP_HEIGHT,\n            isGroup: true,\n          },\n          style: {\n            ...(node.style || {}),\n            width: GROUP_WIDTH,\n            height: GROUP_HEIGHT,\n          },\n        };\n      });\n\n      if (found) {\n        return updated;\n      }\n\n      const placeholder: Node = {\n        id: normalizedId,\n        type: \"group\",\n        position: topLeft,\n        data: {\n          label: \"Group\",\n          width: GROUP_WIDTH,\n          height: GROUP_HEIGHT,\n          isGroup: true,\n        },\n        style: {\n          width: GROUP_WIDTH,\n          height: GROUP_HEIGHT,\n        },\n        selected: true,\n      };\n\n      return [...updated, placeholder];\n    });\n  }, 0);\n\n  return true;\n}",
    "start_line": 59,
    "end_line": 176,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function createEmptyGroupAtPoint",
    "component_id": "client.utils.canvas.canvasGroupInteractions.createEmptyGroupAtPoint"
  },
  "client.utils.canvas.canvasGroupInteractions.handleGroupToolPaneClick": {
    "id": "client.utils.canvas.canvasGroupInteractions.handleGroupToolPaneClick",
    "name": "handleGroupToolPaneClick",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasGroupInteractions.ts",
    "relative_path": "client/utils/canvas/canvasGroupInteractions.ts",
    "depends_on": [
      "client.utils.canvas.canvasGroupInteractions.createEmptyGroupAtPoint",
      "client.utils.canvas.canvasGroupInteractions.groupSelectedNodes",
      "client.utils.canvas.canvasGroupInteractions.GroupToolPaneClickParams"
    ],
    "source_code": "handleGroupToolPaneClick = (params: GroupToolPaneClickParams): boolean => {\n  return groupSelectedNodes(params) || createEmptyGroupAtPoint(params);\n}",
    "start_line": 178,
    "end_line": 180,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "params"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function handleGroupToolPaneClick",
    "component_id": "client.utils.canvas.canvasGroupInteractions.handleGroupToolPaneClick"
  },
  "client.utils.canvas.canvasInteractions.placeNodeOnCanvas": {
    "id": "client.utils.canvas.canvasInteractions.placeNodeOnCanvas",
    "name": "placeNodeOnCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasInteractions.ts",
    "relative_path": "client/utils/canvas/canvasInteractions.ts",
    "depends_on": [
      "client.core.orchestration.Orchestrator.apply",
      "scripts.test-vercel-preview.error",
      "client.core.viewstate.CoordinateService.snapPoint",
      "client.orchestration.types.EditIntent"
    ],
    "source_code": "function placeNodeOnCanvas(\n  e: MouseEvent,\n  selectedTool: 'arrow' | 'hand' | 'box' | 'connector' | 'group',\n  reactFlowRef: MutableRefObject<ReactFlowInstance | null>,\n  handleAddNode?: (id: string, position: { x: number; y: number }, parentId?: string) => void,\n  viewStateRef?: MutableRefObject<any>,\n  onDone?: (nextTool: 'arrow' | 'hand' | 'box' | 'connector' | 'group') => void,\n  parentId?: string | null,\n) {\n  if (selectedTool !== 'box' && !parentId) {\n    return;\n  }\n  const target = e.currentTarget as HTMLDivElement;\n  if (!target) return;\n  const rf = reactFlowRef.current;\n  if (!rf) return;\n  \n  // Convert screen coordinates to world coordinates\n  const screenPoint = { x: (e as any).clientX, y: (e as any).clientY };\n  const projected = (rf as any).screenToFlowPosition\n    ? (rf as any).screenToFlowPosition(screenPoint)\n    : rf.project(screenPoint);\n  \n  // Use CoordinateService to snap to grid\n  const snappedCenter = CoordinateService.snapPoint(projected, GRID_CONFIG.SIZE);\n  const NODE_SIZE = 96; // align to 16px grid\n  const half = NODE_SIZE / 2;\n  const topLeft = { x: snappedCenter.x - half, y: snappedCenter.y - half };\n  const id = `user-node-${Date.now()}`;\n\n  // Use Orchestrator for FREE structural edit (add node)\n  const intent: EditIntent = {\n    source: 'user',\n    kind: 'free-structural', \n    scopeId: parentId || 'root',\n    payload: {\n      action: 'add-node',\n      nodeId: id,\n      parentId: parentId || 'root',\n      position: { x: topLeft.x, y: topLeft.y },\n      size: { w: NODE_SIZE, h: NODE_SIZE },\n      data: {\n        label: '', // Empty label for \"Add text\" placeholder\n      }\n    }\n  };\n  \n  apply(intent).catch(error => {\n    console.error('[placeNodeOnCanvas] Orchestrator apply failed:', error);\n  });\n\n  // Auto-switch to select tool after creating a node\n  onDone?.('arrow');\n}",
    "start_line": 7,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "e",
      "selectedTool",
      "reactFlowRef",
      "handleAddNode",
      "viewStateRef",
      "onDone",
      "parentId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function placeNodeOnCanvas",
    "component_id": "client.utils.canvas.canvasInteractions.placeNodeOnCanvas"
  },
  "client.utils.canvas.canvasSelectionUtils.selectNodes": {
    "id": "client.utils.canvas.canvasSelectionUtils.selectNodes",
    "name": "selectNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasSelectionUtils.ts",
    "relative_path": "client/utils/canvas/canvasSelectionUtils.ts",
    "depends_on": [
      "client.core.orchestration.Orchestrator.apply",
      "scripts.test-vercel-preview.error",
      "client.orchestration.types.EditIntent"
    ],
    "source_code": "async function selectNodes(nodeIds: string[]): Promise<void> {\n  const intent: EditIntent = {\n    source: 'user',\n    kind: 'free-structural',\n    scopeId: 'root',\n    payload: {\n      action: 'select-nodes',\n      nodeIds\n    }\n  };\n  \n  try {\n    await apply(intent);\n  } catch (error) {\n    console.error('[Selection] Failed to select nodes:', error);\n  }\n}",
    "start_line": 14,
    "end_line": 30,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeIds"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function selectNodes",
    "component_id": "client.utils.canvas.canvasSelectionUtils.selectNodes"
  },
  "client.utils.canvas.canvasSelectionUtils.deselectAll": {
    "id": "client.utils.canvas.canvasSelectionUtils.deselectAll",
    "name": "deselectAll",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasSelectionUtils.ts",
    "relative_path": "client/utils/canvas/canvasSelectionUtils.ts",
    "depends_on": [
      "client.core.orchestration.Orchestrator.apply",
      "scripts.test-vercel-preview.error",
      "client.orchestration.types.EditIntent"
    ],
    "source_code": "async function deselectAll(): Promise<void> {\n  const intent: EditIntent = {\n    source: 'user',\n    kind: 'free-structural', \n    scopeId: 'root',\n    payload: {\n      action: 'deselect-all'\n    }\n  };\n  \n  try {\n    await apply(intent);\n  } catch (error) {\n    console.error('[Selection] Failed to deselect all:', error);\n  }\n}",
    "start_line": 35,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function deselectAll",
    "component_id": "client.utils.canvas.canvasSelectionUtils.deselectAll"
  },
  "client.utils.canvas.canvasSelectionUtils.toggleNodeSelection": {
    "id": "client.utils.canvas.canvasSelectionUtils.toggleNodeSelection",
    "name": "toggleNodeSelection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasSelectionUtils.ts",
    "relative_path": "client/utils/canvas/canvasSelectionUtils.ts",
    "depends_on": [
      "client.utils.canvas.canvasSelectionUtils.selectNodes",
      "client.utils.canvas.canvasSelectionUtils.deselectAll"
    ],
    "source_code": "async function toggleNodeSelection(nodeId: string, currentlySelected: boolean): Promise<void> {\n  if (currentlySelected) {\n    await deselectAll();\n  } else {\n    await selectNodes([nodeId]);\n  }\n}",
    "start_line": 55,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "currentlySelected"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function toggleNodeSelection",
    "component_id": "client.utils.canvas.canvasSelectionUtils.toggleNodeSelection"
  },
  "client.utils.canvas.canvasSelectionUtils.clearReactFlowSelection": {
    "id": "client.utils.canvas.canvasSelectionUtils.clearReactFlowSelection",
    "name": "clearReactFlowSelection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasSelectionUtils.ts",
    "relative_path": "client/utils/canvas/canvasSelectionUtils.ts",
    "depends_on": [
      "client.utils.canvas.canvasSelectionUtils.deselectAll"
    ],
    "source_code": "async function clearReactFlowSelection(): Promise<void> {\n  await deselectAll();\n}",
    "start_line": 67,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function clearReactFlowSelection",
    "component_id": "client.utils.canvas.canvasSelectionUtils.clearReactFlowSelection"
  },
  "client.utils.canvas.canvasSelectionUtils.selectSingleNode": {
    "id": "client.utils.canvas.canvasSelectionUtils.selectSingleNode",
    "name": "selectSingleNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/canvasSelectionUtils.ts",
    "relative_path": "client/utils/canvas/canvasSelectionUtils.ts",
    "depends_on": [
      "client.utils.canvas.canvasSelectionUtils.selectNodes"
    ],
    "source_code": "async function selectSingleNode(nodeId: string): Promise<void> {\n  await selectNodes([nodeId]);\n}",
    "start_line": 75,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function selectSingleNode",
    "component_id": "client.utils.canvas.canvasSelectionUtils.selectSingleNode"
  },
  "client.utils.canvas.gridSnapping.snap": {
    "id": "client.utils.canvas.gridSnapping.snap",
    "name": "snap",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/gridSnapping.ts",
    "relative_path": "client/utils/canvas/gridSnapping.ts",
    "depends_on": [],
    "source_code": "snap = (v: number) => Math.round(v / GRID_SIZE) * GRID_SIZE",
    "start_line": 12,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "v"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function snap",
    "component_id": "client.utils.canvas.gridSnapping.snap"
  },
  "client.utils.canvas.gridSnapping.snapPos": {
    "id": "client.utils.canvas.gridSnapping.snapPos",
    "name": "snapPos",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/gridSnapping.ts",
    "relative_path": "client/utils/canvas/gridSnapping.ts",
    "depends_on": [
      "client.utils.canvas.gridSnapping.snap"
    ],
    "source_code": "snapPos = (p: { x: number; y: number }) => ({ x: snap(p.x), y: snap(p.y) })",
    "start_line": 13,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "p"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function snapPos",
    "component_id": "client.utils.canvas.gridSnapping.snapPos"
  },
  "client.utils.canvas.gridSnapping.applyGridSnapping": {
    "id": "client.utils.canvas.gridSnapping.applyGridSnapping",
    "name": "applyGridSnapping",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/gridSnapping.ts",
    "relative_path": "client/utils/canvas/gridSnapping.ts",
    "depends_on": [
      "client.utils.canvas.gridSnapping.snapPos"
    ],
    "source_code": "function applyGridSnapping(changes: NodeChange[]): NodeChange[] {\n  return changes.map((ch) => {\n    if (ch.type === 'position' && (ch as any).position) {\n      const pos = (ch as any).position as { x: number; y: number };\n      const snapped = snapPos(pos);\n      return { ...ch, position: snapped } as NodeChange;\n    }\n    return ch;\n  });\n}",
    "start_line": 20,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "changes"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function applyGridSnapping",
    "component_id": "client.utils.canvas.gridSnapping.applyGridSnapping"
  },
  "client.utils.canvas.gridSnapping.createGridSnappingHandler": {
    "id": "client.utils.canvas.gridSnapping.createGridSnappingHandler",
    "name": "createGridSnappingHandler",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvas/gridSnapping.ts",
    "relative_path": "client/utils/canvas/gridSnapping.ts",
    "depends_on": [
      "client.utils.canvas.gridSnapping.applyGridSnapping"
    ],
    "source_code": "function createGridSnappingHandler(\n  setNodes: React.Dispatch<React.SetStateAction<any[]>>\n) {\n  return (changes: NodeChange[]) => {\n    const snappedChanges = applyGridSnapping(changes);\n    setNodes((nodesState) => applyNodeChanges(snappedChanges, nodesState));\n  };\n}",
    "start_line": 36,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "setNodes"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createGridSnappingHandler",
    "component_id": "client.utils.canvas.gridSnapping.createGridSnappingHandler"
  },
  "client.utils.canvasLayout.sanitizeStoredViewState": {
    "id": "client.utils.canvasLayout.sanitizeStoredViewState",
    "name": "sanitizeStoredViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasLayout.ts",
    "relative_path": "client/utils/canvasLayout.ts",
    "depends_on": [],
    "source_code": "function sanitizeStoredViewState(state: any): any {\n  return state;\n}",
    "start_line": 1,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "state"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sanitizeStoredViewState",
    "component_id": "client.utils.canvasLayout.sanitizeStoredViewState"
  },
  "client.utils.canvasLayout.restoreNodeVisuals": {
    "id": "client.utils.canvasLayout.restoreNodeVisuals",
    "name": "restoreNodeVisuals",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasLayout.ts",
    "relative_path": "client/utils/canvasLayout.ts",
    "depends_on": [],
    "source_code": "function restoreNodeVisuals(node: any): any {\n  return node;\n}",
    "start_line": 5,
    "end_line": 7,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function restoreNodeVisuals",
    "component_id": "client.utils.canvasLayout.restoreNodeVisuals"
  },
  "client.utils.canvasModals.CanvasModalManager": {
    "id": "client.utils.canvasModals.CanvasModalManager",
    "name": "CanvasModalManager",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasModals.ts",
    "relative_path": "client/utils/canvasModals.ts",
    "depends_on": [],
    "source_code": "class CanvasModalManager {\n  constructor(params: any) {}\n}",
    "start_line": 1,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class CanvasModalManager",
    "component_id": "client.utils.canvasModals.CanvasModalManager"
  },
  "client.utils.canvasPersistence.ViewStateGeometry": {
    "id": "client.utils.canvasPersistence.ViewStateGeometry",
    "name": "ViewStateGeometry",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [],
    "source_code": "interface ViewStateGeometry {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}",
    "start_line": 7,
    "end_line": 12,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ViewStateGeometry",
    "component_id": "client.utils.canvasPersistence.ViewStateGeometry"
  },
  "client.utils.canvasPersistence.ViewState": {
    "id": "client.utils.canvasPersistence.ViewState",
    "name": "ViewState",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [
      "client.utils.canvasPersistence.ViewStateGeometry"
    ],
    "source_code": "interface ViewState {\n  node: Record<string, ViewStateGeometry>;\n  group: Record<string, ViewStateGeometry>;\n  edge: Record<string, any>;\n  layout?: Record<string, { mode: 'FREE' | 'LOCK' }>;\n}",
    "start_line": 14,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ViewState",
    "component_id": "client.utils.canvasPersistence.ViewState"
  },
  "client.utils.canvasPersistence.CanvasSnapshot": {
    "id": "client.utils.canvasPersistence.CanvasSnapshot",
    "name": "CanvasSnapshot",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [
      "client.utils.canvasPersistence.ViewState"
    ],
    "source_code": "interface CanvasSnapshot {\n  rawGraph: any;\n  viewState: ViewState;\n  selectedArchitectureId: string;\n  timestamp: number;\n}",
    "start_line": 21,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CanvasSnapshot",
    "component_id": "client.utils.canvasPersistence.CanvasSnapshot"
  },
  "client.utils.canvasPersistence.createViewStateSnapshot": {
    "id": "client.utils.canvasPersistence.createViewStateSnapshot",
    "name": "createViewStateSnapshot",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [
      "client.utils.canvasPersistence.ViewState"
    ],
    "source_code": "function createViewStateSnapshot(\n  nodes: Node[],\n  viewStateRef: React.MutableRefObject<ViewState | undefined>,\n  isHydratingRef: React.MutableRefObject<boolean>\n): ViewState {\n  if (isHydratingRef.current && viewStateRef?.current) {\n    try {\n      return JSON.parse(JSON.stringify(viewStateRef.current));\n    } catch (error) {\n      return viewStateRef.current;\n    }\n  }\n\n  const base = viewStateRef?.current\n    ? (() => {\n        try {\n          return JSON.parse(JSON.stringify(viewStateRef.current));\n        } catch (error) {\n          return viewStateRef.current;\n        }\n      })()\n    : { node: {}, group: {}, edge: {} };\n\n  const snapshot = base || { node: {}, group: {}, edge: {} };\n\n  // Helper to calculate absolute position from node and all nodes\n  const getAbsolutePosition = (node: Node, allNodes: Node[]): { x: number; y: number } => {\n    let x = node.position?.x ?? 0;\n    let y = node.position?.y ?? 0;\n    \n    // If node has a parent, add parent's absolute position\n    if ((node as any).parentId) {\n      const parent = allNodes.find(n => n.id === (node as any).parentId);\n      if (parent) {\n        const parentAbs = getAbsolutePosition(parent, allNodes);\n        x += parentAbs.x;\n        y += parentAbs.y;\n      }\n    }\n    \n    return { x, y };\n  };\n\n\n  nodes.forEach((node) => {\n    const existingNodeView = viewStateRef?.current?.node?.[node.id];\n    const existingGroupView = viewStateRef?.current?.group?.[node.id];\n\n    const rawWidth =\n      (typeof node.data?.width === 'number' && node.data.width) ||\n      (typeof node.style?.width === 'number' && node.style.width) ||\n      (typeof node.style?.width === 'string' ? parseFloat(node.style.width) : undefined);\n    const rawHeight =\n      (typeof node.data?.height === 'number' && node.data.height) ||\n      (typeof node.style?.height === 'number' && node.style.height) ||\n      (typeof node.style?.height === 'string' ? parseFloat(node.style.height) : undefined);\n\n    // CRITICAL FIX: ALWAYS preserve existing ViewState positions if they exist\n    // ViewState is the source of truth, not ReactFlow positions\n    // Only calculate from ReactFlow if no existing ViewState geometry exists\n    const existingGeom = existingNodeView || existingGroupView;\n    \n    let finalX: number;\n    let finalY: number;\n    \n    if (existingGeom && existingGeom.x !== undefined && existingGeom.y !== undefined) {\n      // PRESERVE existing ViewState position - it's authoritative\n      finalX = existingGeom.x;\n      finalY = existingGeom.y;\n    } else {\n      // No existing ViewState - calculate from ReactFlow (only for new nodes)\n      const absolutePos = getAbsolutePosition(node, nodes);\n      finalX = absolutePos.x;\n      finalY = absolutePos.y;\n    }\n    \n    const width = rawWidth ?? existingNodeView?.w ?? existingGroupView?.w ?? 96;\n    const height = rawHeight ?? existingNodeView?.h ?? existingGroupView?.h ?? 96;\n\n    snapshot.node = snapshot.node || {};\n    snapshot.node[node.id] = {\n      x: finalX,\n      y: finalY,\n      w: width,\n      h: height,\n    };\n\n    if (node.type === 'group') {\n      snapshot.group = snapshot.group || {};\n      snapshot.group[node.id] = {\n        x: finalX,\n        y: finalY,\n        w: rawWidth ?? existingGroupView?.w ?? width,\n        h: rawHeight ?? existingGroupView?.h ?? height,\n      };\n    }\n  });\n\n  return snapshot;\n}",
    "start_line": 31,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodes",
      "viewStateRef",
      "isHydratingRef"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createViewStateSnapshot",
    "component_id": "client.utils.canvasPersistence.createViewStateSnapshot"
  },
  "client.utils.canvasPersistence.extractGroupIdsFromGraph": {
    "id": "client.utils.canvasPersistence.extractGroupIdsFromGraph",
    "name": "extractGroupIdsFromGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [],
    "source_code": "function extractGroupIdsFromGraph(graph: any): string[] {\n  const groupIds: string[] = [];\n  if (!graph) return groupIds;\n  \n  const traverse = (node: any) => {\n    if (node.type === 'group' || node.data?.isGroup || node.mode) {\n      groupIds.push(node.id);\n    }\n    if (node.children) {\n      node.children.forEach((child: any) => traverse(child));\n    }\n  };\n  \n  if (graph.children) {\n    graph.children.forEach((child: any) => traverse(child));\n  }\n  \n  return groupIds;\n}",
    "start_line": 135,
    "end_line": 153,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractGroupIdsFromGraph",
    "component_id": "client.utils.canvasPersistence.extractGroupIdsFromGraph"
  },
  "client.utils.canvasPersistence.saveCanvasSnapshot": {
    "id": "client.utils.canvasPersistence.saveCanvasSnapshot",
    "name": "saveCanvasSnapshot",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [
      "client.utils.canvasPersistence.ViewState",
      "scripts.test-vercel-preview.error",
      "client.utils.canvasPersistence.CanvasSnapshot"
    ],
    "source_code": "function saveCanvasSnapshot(\n  rawGraph: any,\n  viewState: ViewState,\n  selectedArchitectureId: string\n): void {\n  try {\n    const payload: CanvasSnapshot = {\n      rawGraph,\n      viewState,\n      selectedArchitectureId,\n      timestamp: Date.now(),\n    };\n    const serialized = JSON.stringify(payload);\n    localStorage.setItem(LOCAL_CANVAS_SNAPSHOT_KEY, serialized);\n    sessionStorage.setItem(LOCAL_CANVAS_SNAPSHOT_KEY, serialized);\n  } catch (error) {\n    console.error(\"‚ùå [saveCanvasSnapshot] Failed to persist local canvas snapshot:\", error);\n  }\n}",
    "start_line": 158,
    "end_line": 176,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawGraph",
      "viewState",
      "selectedArchitectureId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function saveCanvasSnapshot",
    "component_id": "client.utils.canvasPersistence.saveCanvasSnapshot"
  },
  "client.utils.canvasPersistence.restoreCanvasSnapshot": {
    "id": "client.utils.canvasPersistence.restoreCanvasSnapshot",
    "name": "restoreCanvasSnapshot",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [
      "client.utils.canvasPersistence.clearCanvasSnapshot",
      "client.utils.canvasPersistence.CanvasSnapshot",
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function restoreCanvasSnapshot(): CanvasSnapshot | null {\n  try {\n    const stored = localStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY) || sessionStorage.getItem(LOCAL_CANVAS_SNAPSHOT_KEY);\n    if (!stored) return null;\n\n    const parsed = JSON.parse(stored);\n    if (!parsed || !parsed.rawGraph || !parsed.rawGraph.children || parsed.rawGraph.children.length === 0) {\n      return null;\n    }\n\n    // Check if snapshot is recent (within 24 hours)\n    const ageInHours = (Date.now() - (parsed.timestamp || 0)) / (1000 * 60 * 60);\n    if (ageInHours > 24) {\n      console.log(\"üóëÔ∏è Local canvas snapshot expired, ignoring\");\n      clearCanvasSnapshot();\n      return null;\n    }\n\n    return parsed as CanvasSnapshot;\n  } catch (error) {\n    console.warn(\"‚ö†Ô∏è Failed to restore local canvas snapshot:\", error);\n    return null;\n  }\n}",
    "start_line": 181,
    "end_line": 204,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function restoreCanvasSnapshot",
    "component_id": "client.utils.canvasPersistence.restoreCanvasSnapshot"
  },
  "client.utils.canvasPersistence.clearCanvasSnapshot": {
    "id": "client.utils.canvasPersistence.clearCanvasSnapshot",
    "name": "clearCanvasSnapshot",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function clearCanvasSnapshot(): void {\n  try {\n    localStorage.removeItem(LOCAL_CANVAS_SNAPSHOT_KEY);\n    sessionStorage.removeItem(LOCAL_CANVAS_SNAPSHOT_KEY);\n  } catch (error) {\n    console.warn(\"‚ö†Ô∏è Failed to clear canvas snapshot:\", error);\n  }\n}",
    "start_line": 209,
    "end_line": 216,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clearCanvasSnapshot",
    "component_id": "client.utils.canvasPersistence.clearCanvasSnapshot"
  },
  "client.utils.canvasPersistence.hasValidCanvasSnapshot": {
    "id": "client.utils.canvasPersistence.hasValidCanvasSnapshot",
    "name": "hasValidCanvasSnapshot",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/canvasPersistence.ts",
    "relative_path": "client/utils/canvasPersistence.ts",
    "depends_on": [
      "client.utils.canvasPersistence.restoreCanvasSnapshot"
    ],
    "source_code": "function hasValidCanvasSnapshot(): boolean {\n  const snapshot = restoreCanvasSnapshot();\n  return snapshot !== null;\n}",
    "start_line": 221,
    "end_line": 224,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function hasValidCanvasSnapshot",
    "component_id": "client.utils.canvasPersistence.hasValidCanvasSnapshot"
  },
  "client.utils.chatPersistence.PersistedChatMessage": {
    "id": "client.utils.chatPersistence.PersistedChatMessage",
    "name": "PersistedChatMessage",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [],
    "source_code": "interface PersistedChatMessage {\n  id: string;\n  content: string;\n  timestamp: number;\n  sender: 'user' | 'assistant';\n}",
    "start_line": 6,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PersistedChatMessage",
    "component_id": "client.utils.chatPersistence.PersistedChatMessage"
  },
  "client.utils.chatPersistence.markEmbedToCanvasTransition": {
    "id": "client.utils.chatPersistence.markEmbedToCanvasTransition",
    "name": "markEmbedToCanvasTransition",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function markEmbedToCanvasTransition(): void {\n  try {\n    localStorage.setItem(EMBED_TO_CANVAS_FLAG_KEY, 'true');\n    console.log('üè∑Ô∏è Marked embed-to-canvas transition');\n  } catch (error) {\n    console.warn('Failed to mark embed-to-canvas transition:', error);\n  }\n}",
    "start_line": 22,
    "end_line": 29,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function markEmbedToCanvasTransition",
    "component_id": "client.utils.chatPersistence.markEmbedToCanvasTransition"
  },
  "client.utils.chatPersistence.isEmbedToCanvasTransition": {
    "id": "client.utils.chatPersistence.isEmbedToCanvasTransition",
    "name": "isEmbedToCanvasTransition",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function isEmbedToCanvasTransition(): boolean {\n  try {\n    return localStorage.getItem(EMBED_TO_CANVAS_FLAG_KEY) === 'true';\n  } catch (error) {\n    console.warn('Failed to check embed-to-canvas transition:', error);\n    return false;\n  }\n}",
    "start_line": 34,
    "end_line": 41,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isEmbedToCanvasTransition",
    "component_id": "client.utils.chatPersistence.isEmbedToCanvasTransition"
  },
  "client.utils.chatPersistence.clearEmbedToCanvasFlag": {
    "id": "client.utils.chatPersistence.clearEmbedToCanvasFlag",
    "name": "clearEmbedToCanvasFlag",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function clearEmbedToCanvasFlag(): void {\n  try {\n    localStorage.removeItem(EMBED_TO_CANVAS_FLAG_KEY);\n    console.log('üßπ Cleared embed-to-canvas transition flag');\n  } catch (error) {\n    console.warn('Failed to clear embed-to-canvas transition flag:', error);\n  }\n}",
    "start_line": 46,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clearEmbedToCanvasFlag",
    "component_id": "client.utils.chatPersistence.clearEmbedToCanvasFlag"
  },
  "client.utils.chatPersistence.saveChatMessage": {
    "id": "client.utils.chatPersistence.saveChatMessage",
    "name": "saveChatMessage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.chatPersistence.PersistedChatMessage",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.chatPersistence.getCurrentConversation"
    ],
    "source_code": "function saveChatMessage(message: string, sender: 'user' | 'assistant' = 'user'): void {\n  try {\n    const newMessage: PersistedChatMessage = {\n      id: crypto.randomUUID(),\n      content: message.trim(),\n      timestamp: Date.now(),\n      sender\n    };\n\n    // For new user messages, start a fresh conversation\n    if (sender === 'user') {\n      // Clear previous conversation and start with this message\n      localStorage.setItem(CURRENT_CONVERSATION_KEY, JSON.stringify([newMessage]));\n      console.log('üíæ Started new conversation with message:', newMessage);\n    } else {\n      // For assistant messages, add to current conversation\n      const currentConversation = getCurrentConversation();\n      const updatedConversation = [...currentConversation, newMessage];\n      localStorage.setItem(CURRENT_CONVERSATION_KEY, JSON.stringify(updatedConversation));\n      console.log('üíæ Added to current conversation:', newMessage);\n    }\n  } catch (error) {\n    console.warn('Failed to save chat message:', error);\n  }\n}",
    "start_line": 58,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message",
      "sender"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function saveChatMessage",
    "component_id": "client.utils.chatPersistence.saveChatMessage"
  },
  "client.utils.chatPersistence.getCurrentConversation": {
    "id": "client.utils.chatPersistence.getCurrentConversation",
    "name": "getCurrentConversation",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.utils.chatPersistence.PersistedChatMessage",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function getCurrentConversation(): PersistedChatMessage[] {\n  try {\n    const stored = localStorage.getItem(CURRENT_CONVERSATION_KEY);\n    if (!stored) return [];\n    \n    const messages = JSON.parse(stored) as PersistedChatMessage[];\n    return Array.isArray(messages) ? messages : [];\n  } catch (error) {\n    console.warn('Failed to load current conversation:', error);\n    return [];\n  }\n}",
    "start_line": 87,
    "end_line": 98,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getCurrentConversation",
    "component_id": "client.utils.chatPersistence.getCurrentConversation"
  },
  "client.utils.chatPersistence.getChatMessages": {
    "id": "client.utils.chatPersistence.getChatMessages",
    "name": "getChatMessages",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.utils.chatPersistence.isEmbedToCanvasTransition",
      "client.utils.chatPersistence.PersistedChatMessage",
      "client.utils.chatPersistence.getCurrentConversation"
    ],
    "source_code": "function getChatMessages(): PersistedChatMessage[] {\n  const messages = getCurrentConversation();\n  const isTransition = isEmbedToCanvasTransition();\n  \n  // console.log('üí¨ [CHAT-PERSISTENCE] getChatMessages called:', {\n  //   isEmbedToCanvas: isTransition,\n  //   messageCount: messages.length,\n  //   messages: messages.map(m => ({ sender: m.sender, content: m.content.substring(0, 50) + '...' }))\n  // });\n  \n  // ONLY return messages if user is coming from embed view (Edit button transition)\n  // Do NOT return messages for normal canvas/auth visits\n  if (isTransition) {\n    // console.log('üí¨ [CHAT-PERSISTENCE] Returning persisted messages from embed transition:', messages.length);\n    return messages;\n  } else {\n    // console.log('üí¨ [CHAT-PERSISTENCE] Not an embed transition - returning empty array');\n    return [];\n  }\n}",
    "start_line": 103,
    "end_line": 122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getChatMessages",
    "component_id": "client.utils.chatPersistence.getChatMessages"
  },
  "client.utils.chatPersistence.getLastChatMessage": {
    "id": "client.utils.chatPersistence.getLastChatMessage",
    "name": "getLastChatMessage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.utils.chatPersistence.PersistedChatMessage",
      "client.utils.chatPersistence.getCurrentConversation"
    ],
    "source_code": "function getLastChatMessage(): PersistedChatMessage | null {\n  const messages = getCurrentConversation();\n  return messages.length > 0 ? messages[messages.length - 1] : null;\n}",
    "start_line": 127,
    "end_line": 130,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getLastChatMessage",
    "component_id": "client.utils.chatPersistence.getLastChatMessage"
  },
  "client.utils.chatPersistence.clearChatMessages": {
    "id": "client.utils.chatPersistence.clearChatMessages",
    "name": "clearChatMessages",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function clearChatMessages(): void {\n  try {\n    localStorage.removeItem(CURRENT_CONVERSATION_KEY);\n    localStorage.removeItem(CHAT_STORAGE_KEY); // Clear legacy storage too\n    localStorage.removeItem(EMBED_TO_CANVAS_FLAG_KEY); // Clear embed-to-canvas flag\n    console.log('üóëÔ∏è Chat messages and embed-to-canvas flag cleared');\n  } catch (error) {\n    console.warn('Failed to clear chat messages:', error);\n  }\n}",
    "start_line": 135,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clearChatMessages",
    "component_id": "client.utils.chatPersistence.clearChatMessages"
  },
  "client.utils.chatPersistence.saveChatboxInput": {
    "id": "client.utils.chatPersistence.saveChatboxInput",
    "name": "saveChatboxInput",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function saveChatboxInput(input: string): void {\n  try {\n    if (input.trim()) {\n      localStorage.setItem('atelier_chatbox_input', input.trim());\n    } else {\n      localStorage.removeItem('atelier_chatbox_input');\n    }\n  } catch (error) {\n    console.warn('Failed to save chatbox input:', error);\n  }\n}",
    "start_line": 149,
    "end_line": 159,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "input"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function saveChatboxInput",
    "component_id": "client.utils.chatPersistence.saveChatboxInput"
  },
  "client.utils.chatPersistence.getChatboxInput": {
    "id": "client.utils.chatPersistence.getChatboxInput",
    "name": "getChatboxInput",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function getChatboxInput(): string {\n  try {\n    return localStorage.getItem('atelier_chatbox_input') || '';\n  } catch (error) {\n    console.warn('Failed to load chatbox input:', error);\n    return '';\n  }\n}",
    "start_line": 164,
    "end_line": 171,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getChatboxInput",
    "component_id": "client.utils.chatPersistence.getChatboxInput"
  },
  "client.utils.chatPersistence.clearChatboxInput": {
    "id": "client.utils.chatPersistence.clearChatboxInput",
    "name": "clearChatboxInput",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function clearChatboxInput(): void {\n  try {\n    localStorage.removeItem('atelier_chatbox_input');\n  } catch (error) {\n    console.warn('Failed to clear chatbox input:', error);\n  }\n}",
    "start_line": 176,
    "end_line": 182,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function clearChatboxInput",
    "component_id": "client.utils.chatPersistence.clearChatboxInput"
  },
  "client.utils.chatPersistence.startNewConversation": {
    "id": "client.utils.chatPersistence.startNewConversation",
    "name": "startNewConversation",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function startNewConversation(): void {\n  try {\n    localStorage.removeItem(CURRENT_CONVERSATION_KEY);\n    console.log('üÜï Started new conversation');\n  } catch (error) {\n    console.warn('Failed to start new conversation:', error);\n  }\n}",
    "start_line": 187,
    "end_line": 194,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function startNewConversation",
    "component_id": "client.utils.chatPersistence.startNewConversation"
  },
  "client.utils.chatPersistence.normalizeChatMessages": {
    "id": "client.utils.chatPersistence.normalizeChatMessages",
    "name": "normalizeChatMessages",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.utils.chatPersistence.PersistedChatMessage"
    ],
    "source_code": "function normalizeChatMessages(messages: any): PersistedChatMessage[] {\n  if (!messages || !Array.isArray(messages)) {\n    return [];\n  }\n  \n  return messages.map((msg: any) => {\n    if (typeof msg === 'string') {\n      // Simple string message - treat as user message\n      return {\n        id: crypto.randomUUID(),\n        content: msg,\n        timestamp: Date.now(),\n        sender: 'user' as const\n      };\n    }\n    \n    // Already in PersistedChatMessage format or similar\n    return {\n      id: msg.id || crypto.randomUUID(),\n      content: msg.content || msg.text || msg.message || String(msg),\n      timestamp: msg.timestamp || Date.now(),\n      sender: msg.sender === 'assistant' ? 'assistant' : 'user'\n    };\n  }).filter((msg: PersistedChatMessage) => msg.content && msg.content.trim().length > 0);\n}",
    "start_line": 199,
    "end_line": 223,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "messages"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function normalizeChatMessages",
    "component_id": "client.utils.chatPersistence.normalizeChatMessages"
  },
  "client.utils.chatPersistence.mergeChatMessages": {
    "id": "client.utils.chatPersistence.mergeChatMessages",
    "name": "mergeChatMessages",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatPersistence.ts",
    "relative_path": "client/utils/chatPersistence.ts",
    "depends_on": [
      "client.utils.chatPersistence.PersistedChatMessage"
    ],
    "source_code": "function mergeChatMessages(\n  existing: PersistedChatMessage[],\n  incoming: PersistedChatMessage[]\n): PersistedChatMessage[] {\n  if (!incoming || incoming.length === 0) {\n    return existing;\n  }\n  \n  if (!existing || existing.length === 0) {\n    return incoming;\n  }\n  \n  // Create a map of existing messages by ID to avoid duplicates\n  const existingMap = new Map<string, PersistedChatMessage>();\n  existing.forEach(msg => {\n    existingMap.set(msg.id, msg);\n  });\n  \n  // Add incoming messages that don't already exist\n  incoming.forEach(msg => {\n    if (!existingMap.has(msg.id)) {\n      existingMap.set(msg.id, msg);\n    }\n  });\n  \n  // Sort by timestamp\n  return Array.from(existingMap.values()).sort((a, b) => a.timestamp - b.timestamp);\n}",
    "start_line": 228,
    "end_line": 255,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "existing",
      "incoming"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function mergeChatMessages",
    "component_id": "client.utils.chatPersistence.mergeChatMessages"
  },
  "client.utils.chatUtils.generateChatName": {
    "id": "client.utils.chatUtils.generateChatName",
    "name": "generateChatName",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.utils.chatUtils.countEdges",
      "client.utils.chatUtils.countNodes"
    ],
    "source_code": "async function generateChatName(userPrompt: string, architecture: any): Promise<string> {\n  // Handle empty prompts gracefully\n  if (!userPrompt || userPrompt.trim() === '') {\n    console.log('üîß [generateChatName] Empty prompt provided, using fallback');\n    return \"New Architecture\";\n  }\n  \n  console.log('üîß [generateChatName] Starting with:', { userPrompt, hasArchitecture: !!architecture });\n  \n  try {\n    const nodeCount = countNodes(architecture);\n    const edgeCount = countEdges(architecture);\n    \n    console.log('üìä [generateChatName] Architecture stats:', { nodeCount, edgeCount });\n    \n    const requestBody = {\n      architecture,\n      userPrompt,\n      nodeCount,\n      edgeCount\n    };\n    \n    console.log('üì§ [generateChatName] Sending request to API:', {\n      url: `${window.location.origin}/api/generateChatName`,\n      body: { ...requestBody, architecture: architecture ? 'present' : 'missing' }\n    });\n    \n    const response = await fetch(`${window.location.origin}/api/generateChatName`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(requestBody)\n    });\n\n    console.log('üì• [generateChatName] API response status:', response.status);\n\n    if (response.ok) {\n      const data = await response.json();\n      console.log('üì• [generateChatName] API response data:', data);\n      \n      if (!data.name) {\n        throw new Error('API returned empty name');\n      }\n      \n      const cleanName = data.name.replace(/^[\"']|[\"']$/g, '').replace(/^[\"']|[\"']$/g, ''); // Remove quotes and extra quotes\n      console.log('‚úÖ [generateChatName] Final clean name:', cleanName);\n      return cleanName;\n    } else {\n      const errorText = await response.text();\n      console.error('‚ùå [generateChatName] API error:', response.status, errorText);\n      throw new Error(`API error: ${response.status} - ${errorText}`);\n    }\n  } catch (error) {\n    console.error('‚ùå [generateChatName] API failed:', error);\n    throw error; // Re-throw the error instead of using fallback\n  }\n}",
    "start_line": 10,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "userPrompt",
      "architecture"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function generateChatName",
    "component_id": "client.utils.chatUtils.generateChatName"
  },
  "client.utils.chatUtils.countNodes": {
    "id": "client.utils.chatUtils.countNodes",
    "name": "countNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "client.utils.chatUtils.countNodes"
    ],
    "source_code": "function countNodes(architecture: any): number {\n  if (!architecture) return 0;\n  let count = architecture.id ? 1 : 0;\n  if (architecture.children) {\n    count += architecture.children.reduce((sum: number, child: any) => sum + countNodes(child), 0);\n  }\n  return count;\n}",
    "start_line": 72,
    "end_line": 79,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architecture"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function countNodes",
    "component_id": "client.utils.chatUtils.countNodes"
  },
  "client.utils.chatUtils.countEdges": {
    "id": "client.utils.chatUtils.countEdges",
    "name": "countEdges",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "client.utils.chatUtils.countEdges"
    ],
    "source_code": "function countEdges(architecture: any): number {\n  if (!architecture) return 0;\n  let count = (architecture.edges || []).length;\n  if (architecture.children) {\n    count += architecture.children.reduce((sum: number, child: any) => sum + countEdges(child), 0);\n  }\n  return count;\n}",
    "start_line": 84,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "architecture"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function countEdges",
    "component_id": "client.utils.chatUtils.countEdges"
  },
  "client.utils.chatUtils.addUserDecisionToChat": {
    "id": "client.utils.chatUtils.addUserDecisionToChat",
    "name": "addUserDecisionToChat",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "client.types.chat.Message",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "addUserDecisionToChat = (decision: string): { success: boolean; message: string } => {\n  try {\n    const messageId = crypto.randomUUID();\n    const systemMessage: Message = {\n      id: messageId,\n      content: `${decision}`,\n      sender: 'system'\n    };\n    \n    const addMessageEvent = new CustomEvent('addChatMessage', {\n      detail: { message: systemMessage }\n    });\n    document.dispatchEvent(addMessageEvent);\n    \n    return { success: true, message: `Decision recorded: ${decision}` };\n  } catch (error) {\n    console.error('‚ùå Error adding user decision to chat:', error);\n    return { success: false, message: `Error recording decision: ${error}` };\n  }\n}",
    "start_line": 100,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "decision"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addUserDecisionToChat",
    "component_id": "client.utils.chatUtils.addUserDecisionToChat"
  },
  "client.utils.chatUtils.createFollowupQuestionsToChat": {
    "id": "client.utils.chatUtils.createFollowupQuestionsToChat",
    "name": "createFollowupQuestionsToChat",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "scripts.test-vercel-preview.error",
      "client.types.chat.Message"
    ],
    "source_code": "createFollowupQuestionsToChat = (questions: any[]): { success: boolean; message: string } => {\n  try {\n    if (!questions || !Array.isArray(questions) || questions.length === 0) {\n      return { success: false, message: 'Error: questions parameter must be a non-empty array' };\n    }\n    \n    questions.forEach((question, index) => {\n      if (!question || typeof question !== 'object' || !question.text) {\n        console.error(`‚ùå Invalid question at index ${index}:`, question);\n        return;\n      }\n      \n      const messageId = crypto.randomUUID();\n      const questionMessage: Message = {\n        id: messageId,\n        content: question.text,\n        sender: 'assistant',\n        type: question.type === 'multiselect' ? 'checkbox-question' : 'radio-question',\n        question: question.text,\n        options: (question.options || []).map((option: string, optIndex: number) => ({\n          id: `${messageId}_${optIndex}`,\n          text: option\n        }))\n      };\n      \n      const addQuestionEvent = new CustomEvent('addChatMessage', {\n        detail: { message: questionMessage }\n      });\n      document.dispatchEvent(addQuestionEvent);\n    });\n    \n    return { success: true, message: `Generated ${questions.length} follow-up questions` };\n  } catch (error) {\n    console.error('‚ùå Error creating follow-up questions:', error);\n    return { success: false, message: `Error creating questions: ${error}` };\n  }\n}",
    "start_line": 124,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "questions"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function createFollowupQuestionsToChat",
    "component_id": "client.utils.chatUtils.createFollowupQuestionsToChat"
  },
  "client.utils.chatUtils.addProcessCompleteMessage": {
    "id": "client.utils.chatUtils.addProcessCompleteMessage",
    "name": "addProcessCompleteMessage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "client.types.chat.Message"
    ],
    "source_code": "addProcessCompleteMessage = (): void => {\n  const messageId = crypto.randomUUID();\n  const completeMessage: Message = {\n    id: messageId,\n    content: \"Architecture processing complete!\",\n    sender: 'system',\n    type: 'process-complete'\n  };\n  \n  const addMessageEvent = new CustomEvent('addChatMessage', {\n    detail: { message: completeMessage }\n  });\n  document.dispatchEvent(addMessageEvent);\n}",
    "start_line": 165,
    "end_line": 178,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addProcessCompleteMessage",
    "component_id": "client.utils.chatUtils.addProcessCompleteMessage"
  },
  "client.utils.chatUtils.closeChatWindow": {
    "id": "client.utils.chatUtils.closeChatWindow",
    "name": "closeChatWindow",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "closeChatWindow = (): void => {\n  // Simple implementation - just log for now\n  console.log('üìû Chat window close requested');\n}",
    "start_line": 183,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function closeChatWindow",
    "component_id": "client.utils.chatUtils.closeChatWindow"
  },
  "client.utils.chatUtils.sendArchitectureCompleteToRealtimeAgent": {
    "id": "client.utils.chatUtils.sendArchitectureCompleteToRealtimeAgent",
    "name": "sendArchitectureCompleteToRealtimeAgent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "sendArchitectureCompleteToRealtimeAgent = (): void => {\n  const globalSendTextMessage = (window as any).realtimeAgentSendTextMessage;\n  const isSessionActive = (window as any).realtimeAgentSessionActive;\n  \n  if (!isSessionActive || !globalSendTextMessage) {\n    console.log('üì° Realtime agent not available');\n    return;\n  }\n  \n  try {\n    globalSendTextMessage(\"Architecture generation complete!\");\n    console.log('‚úÖ Architecture complete message sent to realtime agent');\n  } catch (error) {\n    console.error('‚ùå Failed to send architecture complete message:', error);\n  }\n}",
    "start_line": 191,
    "end_line": 206,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function sendArchitectureCompleteToRealtimeAgent",
    "component_id": "client.utils.chatUtils.sendArchitectureCompleteToRealtimeAgent"
  },
  "client.utils.chatUtils.registerChatVisibility": {
    "id": "client.utils.chatUtils.registerChatVisibility",
    "name": "registerChatVisibility",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "registerChatVisibility = (setter: (visible: boolean) => void) => {\n  console.log('üìû Chat visibility setter registered');\n}",
    "start_line": 211,
    "end_line": 213,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "setter"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function registerChatVisibility",
    "component_id": "client.utils.chatUtils.registerChatVisibility"
  },
  "client.utils.chatUtils.makeChatVisible": {
    "id": "client.utils.chatUtils.makeChatVisible",
    "name": "makeChatVisible",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "makeChatVisible = () => {\n  console.log('üëÅÔ∏è Making chat visible');\n}",
    "start_line": 218,
    "end_line": 220,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function makeChatVisible",
    "component_id": "client.utils.chatUtils.makeChatVisible"
  },
  "client.utils.chatUtils.addReasoningMessage": {
    "id": "client.utils.chatUtils.addReasoningMessage",
    "name": "addReasoningMessage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "client.types.chat.Message"
    ],
    "source_code": "addReasoningMessage = (initialContent: string = \"\"): string => {\n  const messageId = crypto.randomUUID();\n  const reasoningMessage: Message = {\n    id: messageId,\n    content: initialContent,\n    sender: 'system',\n    type: 'reasoning',\n    isStreaming: true,\n    streamedContent: \"\",\n    isDropdownOpen: true,\n    animationType: 'reasoning'\n  };\n  \n  const addMessageEvent = new CustomEvent('addChatMessage', {\n    detail: { message: reasoningMessage }\n  });\n  document.dispatchEvent(addMessageEvent);\n  \n  return messageId;\n}",
    "start_line": 225,
    "end_line": 244,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "initialContent"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addReasoningMessage",
    "component_id": "client.utils.chatUtils.addReasoningMessage"
  },
  "client.utils.chatUtils.updateStreamingMessage": {
    "id": "client.utils.chatUtils.updateStreamingMessage",
    "name": "updateStreamingMessage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [],
    "source_code": "updateStreamingMessage = (messageId: string, newContent: string, isComplete: boolean = false, currentFunction?: string): void => {\n  const updateEvent = new CustomEvent('updateStreamingMessage', {\n    detail: { \n      messageId, \n      streamedContent: newContent,\n      isStreaming: !isComplete,\n      currentFunction\n    }\n  });\n  document.dispatchEvent(updateEvent);\n}",
    "start_line": 249,
    "end_line": 259,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "messageId",
      "newContent",
      "isComplete",
      "currentFunction"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function updateStreamingMessage",
    "component_id": "client.utils.chatUtils.updateStreamingMessage"
  },
  "client.utils.chatUtils.addFunctionCallingMessage": {
    "id": "client.utils.chatUtils.addFunctionCallingMessage",
    "name": "addFunctionCallingMessage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/chatUtils.ts",
    "relative_path": "client/utils/chatUtils.ts",
    "depends_on": [
      "client.types.chat.Message"
    ],
    "source_code": "addFunctionCallingMessage = (initialContent: string = \"\"): string => {\n  const messageId = crypto.randomUUID();\n  const functionMessage: Message = {\n    id: messageId,\n    content: initialContent,\n    sender: 'system',\n    type: 'function-calling',\n    isStreaming: true,\n    streamedContent: \"\",\n    isDropdownOpen: false,\n    animationType: 'function-calling'\n  };\n  \n  const addMessageEvent = new CustomEvent('addChatMessage', {\n    detail: { message: functionMessage }\n  });\n  document.dispatchEvent(addMessageEvent);\n  \n  return messageId;\n}",
    "start_line": 264,
    "end_line": 283,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "initialContent"
    ],
    "node_type": "arrow_function",
    "base_classes": null,
    "class_name": null,
    "display_name": "arrow function addFunctionCallingMessage",
    "component_id": "client.utils.chatUtils.addFunctionCallingMessage"
  },
  "client.utils.containmentDetection.isPointInRect": {
    "id": "client.utils.containmentDetection.isPointInRect",
    "name": "isPointInRect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/containmentDetection.ts",
    "relative_path": "client/utils/containmentDetection.ts",
    "depends_on": [],
    "source_code": "function isPointInRect(\n  point: { x: number; y: number },\n  rect: { x: number; y: number; width: number; height: number }\n): boolean {\n  return (\n    point.x >= rect.x &&\n    point.x <= rect.x + rect.width &&\n    point.y >= rect.y &&\n    point.y <= rect.y + rect.height\n  );\n}",
    "start_line": 6,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "point",
      "rect"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isPointInRect",
    "component_id": "client.utils.containmentDetection.isPointInRect"
  },
  "client.utils.containmentDetection.isRectFullyContained": {
    "id": "client.utils.containmentDetection.isRectFullyContained",
    "name": "isRectFullyContained",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/containmentDetection.ts",
    "relative_path": "client/utils/containmentDetection.ts",
    "depends_on": [],
    "source_code": "function isRectFullyContained(\n  inner: { x: number; y: number; width: number; height: number },\n  outer: { x: number; y: number; width: number; height: number }\n): boolean {\n  return (\n    inner.x >= outer.x &&\n    inner.y >= outer.y &&\n    inner.x + inner.width <= outer.x + outer.width &&\n    inner.y + inner.height <= outer.y + outer.height\n  );\n}",
    "start_line": 21,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "inner",
      "outer"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isRectFullyContained",
    "component_id": "client.utils.containmentDetection.isRectFullyContained"
  },
  "client.utils.containmentDetection.getAbsolutePosition": {
    "id": "client.utils.containmentDetection.getAbsolutePosition",
    "name": "getAbsolutePosition",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/containmentDetection.ts",
    "relative_path": "client/utils/containmentDetection.ts",
    "depends_on": [
      "client.utils.containmentDetection.getAbsolutePosition"
    ],
    "source_code": "function getAbsolutePosition(\n  node: Node, \n  allNodes: Node[], \n  viewState?: { node: Record<string, { x: number; y: number; w: number; h: number }>; group: Record<string, { x: number; y: number; w: number; h: number }> },\n  useReactFlowPosition: boolean = false\n): { x: number; y: number } {\n  // If forcing ReactFlow position (e.g., during drag), use it directly\n  if (useReactFlowPosition) {\n    let x = node.position.x;\n    let y = node.position.y;\n    \n    // If node has a parent, add parent's absolute position\n    if (node.parentId) {\n      const parent = allNodes.find(n => n.id === node.parentId);\n      if (parent) {\n        // For parent, prefer ViewState (parents don't move during child drag)\n        const parentAbs = getAbsolutePosition(parent, allNodes, viewState, false);\n        x += parentAbs.x;\n        y += parentAbs.y;\n      }\n    }\n    \n    return { x, y };\n  }\n  \n  // Prefer ViewState positions (absolute coordinates) when not forcing ReactFlow\n  if (viewState) {\n    const nodeGeom = viewState.node[node.id] || viewState.group[node.id];\n    if (nodeGeom) {\n      return { x: nodeGeom.x, y: nodeGeom.y };\n    }\n  }\n  \n  // Fallback to ReactFlow positions (may be stale)\n  let x = node.position.x;\n  let y = node.position.y;\n  \n  // If node has a parent, add parent's absolute position\n  if (node.parentId) {\n    const parent = allNodes.find(n => n.id === node.parentId);\n    if (parent) {\n      const parentAbs = getAbsolutePosition(parent, allNodes, viewState, false);\n      x += parentAbs.x;\n      y += parentAbs.y;\n    }\n  }\n  \n  return { x, y };\n}",
    "start_line": 37,
    "end_line": 85,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "allNodes",
      "viewState",
      "useReactFlowPosition"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getAbsolutePosition",
    "component_id": "client.utils.containmentDetection.getAbsolutePosition"
  },
  "client.utils.containmentDetection.getNodeBounds": {
    "id": "client.utils.containmentDetection.getNodeBounds",
    "name": "getNodeBounds",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/containmentDetection.ts",
    "relative_path": "client/utils/containmentDetection.ts",
    "depends_on": [
      "client.utils.containmentDetection.getAbsolutePosition"
    ],
    "source_code": "function getNodeBounds(\n  node: Node, \n  allNodes: Node[], \n  viewState?: { node: Record<string, { x: number; y: number; w: number; h: number }>; group: Record<string, { x: number; y: number; w: number; h: number }> },\n  useReactFlowPosition: boolean = false\n): { x: number; y: number; width: number; height: number } | null {\n  const width = (node.data as any)?.width ?? (node.style as any)?.width ?? 96;\n  const height = (node.data as any)?.height ?? (node.style as any)?.height ?? 96;\n  \n  if (typeof width !== 'number' || typeof height !== 'number') {\n    return null;\n  }\n\n  // During drag operations, ReactFlow positions are more current than ViewState\n  // Use ReactFlow position directly for root nodes (already absolute)\n  // For child nodes, calculate absolute from ReactFlow position + parent\n  if (useReactFlowPosition || !viewState) {\n    const absPos = getAbsolutePosition(node, allNodes, viewState, useReactFlowPosition);\n    return {\n      x: absPos.x,\n      y: absPos.y,\n      width,\n      height,\n    };\n  }\n\n  // Prefer ViewState dimensions and positions (absolute coordinates) when not dragging\n    const nodeGeom = viewState.node[node.id] || viewState.group[node.id];\n    if (nodeGeom) {\n      return {\n        x: nodeGeom.x,\n        y: nodeGeom.y,\n        width: nodeGeom.w,\n        height: nodeGeom.h,\n      };\n    }\n  \n  // Final fallback: calculate from ReactFlow position\n  const absPos = getAbsolutePosition(node, allNodes, viewState);\n  \n  return {\n    x: absPos.x,\n    y: absPos.y,\n    width,\n    height,\n  };\n}",
    "start_line": 91,
    "end_line": 137,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "allNodes",
      "viewState",
      "useReactFlowPosition"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getNodeBounds",
    "component_id": "client.utils.containmentDetection.getNodeBounds"
  },
  "client.utils.containmentDetection.findContainingGroup": {
    "id": "client.utils.containmentDetection.findContainingGroup",
    "name": "findContainingGroup",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/containmentDetection.ts",
    "relative_path": "client/utils/containmentDetection.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.containmentDetection.isRectFullyContained",
      "client.utils.containmentDetection.getNodeBounds"
    ],
    "source_code": "function findContainingGroup(\n  node: Node,\n  allNodes: Node[],\n  viewState?: { node: Record<string, { x: number; y: number; w: number; h: number }>; group: Record<string, { x: number; y: number; w: number; h: number }> },\n  useReactFlowPosition: boolean = true\n): Node | null {\n  // Don't check containment for the node against itself\n  if (node.type === 'group') {\n    return null;\n  }\n\n  // Only log when there's a potential issue\n  const viewStatePos = viewState?.node?.[node.id] || viewState?.group?.[node.id];\n  if (!viewStatePos) {\n    console.log('[üéØCOORD] findContainingGroup - MISSING ViewState:', { nodeId: node.id });\n  }\n\n  const nodeBounds = getNodeBounds(node, allNodes, viewState, useReactFlowPosition);\n  if (!nodeBounds) {\n    console.log('[üéØCOORD] findContainingGroup - No node bounds:', { nodeId: node.id });\n    return null;\n  }\n\n  // Find all group nodes\n  const groups = allNodes.filter(n => n.type === 'group');\n  \n  for (const group of groups) {\n    // Skip if node is the group itself\n    if (node.id === group.id) {\n      continue;\n    }\n    \n    // For groups, prefer ViewState (groups don't move as frequently during drag)\n    const groupBounds = getNodeBounds(group, allNodes, viewState, false);\n    if (!groupBounds) {\n      continue;\n    }\n\n    // Check if ALL of the node is inside group bounds\n    // All four corners must be inside - using absolute coordinates\n    // We check even if node.parentId === group.id to detect when it moves out\n    const isFullyContained = isRectFullyContained(nodeBounds, groupBounds);\n    \n    if (isFullyContained) {\n      console.log('[üéØCOORD] FOUND containing group:', {\n        nodeId: node.id,\n        groupId: group.id,\n        nodeAbsolute: `${nodeBounds.x},${nodeBounds.y}`,\n        groupAbsolute: `${groupBounds.x},${groupBounds.y}`,\n      });\n      return group;\n    }\n  }\n\n  return null;\n}",
    "start_line": 145,
    "end_line": 200,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "allNodes",
      "viewState",
      "useReactFlowPosition"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findContainingGroup",
    "component_id": "client.utils.containmentDetection.findContainingGroup"
  },
  "client.utils.containmentDetection.findFullyContainedNodes": {
    "id": "client.utils.containmentDetection.findFullyContainedNodes",
    "name": "findFullyContainedNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/containmentDetection.ts",
    "relative_path": "client/utils/containmentDetection.ts",
    "depends_on": [
      "client.utils.containmentDetection.isRectFullyContained",
      "client.utils.containmentDetection.getNodeBounds"
    ],
    "source_code": "function findFullyContainedNodes(\n  group: Node,\n  allNodes: Node[],\n  viewState?: { node: Record<string, { x: number; y: number; w: number; h: number }>; group: Record<string, { x: number; y: number; w: number; h: number }> }\n): Node[] {\n  const groupBounds = getNodeBounds(group, allNodes, viewState);\n  if (!groupBounds) return [];\n\n  // Find all non-group nodes that are not already children of this group\n  const regularNodes = allNodes.filter(n => \n    n.type !== 'group' && \n    n.id !== group.id && \n    n.parentId !== group.id\n  );\n  const containedNodes: Node[] = [];\n\n  for (const node of regularNodes) {\n    const nodeBounds = getNodeBounds(node, allNodes, viewState);\n    if (!nodeBounds) continue;\n\n    // Check if node is fully contained within group (using absolute coordinates)\n    if (isRectFullyContained(nodeBounds, groupBounds)) {\n      containedNodes.push(node);\n    }\n  }\n\n  return containedNodes;\n}",
    "start_line": 207,
    "end_line": 234,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "group",
      "allNodes",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findFullyContainedNodes",
    "component_id": "client.utils.containmentDetection.findFullyContainedNodes"
  },
  "client.utils.copyToClipboard.CopyOptions": {
    "id": "client.utils.copyToClipboard.CopyOptions",
    "name": "CopyOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/copyToClipboard.ts",
    "relative_path": "client/utils/copyToClipboard.ts",
    "depends_on": [],
    "source_code": "interface CopyOptions {\n  /**\n   * Function to call on successful copy\n   */\n  onSuccess?: (method: 'clipboard' | 'execCommand') => void;\n  \n  /**\n   * Function to call on copy failure\n   */\n  onError?: (error: unknown) => void;\n  \n  /**\n   * Whether to show user feedback (default: true)\n   */\n  showFeedback?: boolean;\n  \n  /**\n   * Custom feedback message for success\n   */\n  successMessage?: string;\n  \n  /**\n   * Custom feedback message for failure\n   */\n  errorMessage?: string;\n}",
    "start_line": 6,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface CopyOptions",
    "component_id": "client.utils.copyToClipboard.CopyOptions"
  },
  "client.utils.copyToClipboard.isEmbedded": {
    "id": "client.utils.copyToClipboard.isEmbedded",
    "name": "isEmbedded",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/copyToClipboard.ts",
    "relative_path": "client/utils/copyToClipboard.ts",
    "depends_on": [],
    "source_code": "function isEmbedded(): boolean {\n  return (\n    window.location.hostname === 'archgen-ecru.vercel.app' ||\n    window.location.pathname === '/embed' ||\n    window.parent !== window\n  );\n}",
    "start_line": 36,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isEmbedded",
    "component_id": "client.utils.copyToClipboard.isEmbedded"
  },
  "client.utils.copyToClipboard.copyToClipboard": {
    "id": "client.utils.copyToClipboard.copyToClipboard",
    "name": "copyToClipboard",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/copyToClipboard.ts",
    "relative_path": "client/utils/copyToClipboard.ts",
    "depends_on": [
      "client.utils.copyToClipboard.copyWithExecCommand",
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.copyToClipboard.CopyOptions",
      "scripts.test-vercel-preview.error",
      "client.utils.copyToClipboard.isEmbedded"
    ],
    "source_code": "async function copyToClipboard(\n  text: string, \n  options: CopyOptions = {}\n): Promise<boolean> {\n  const {\n    onSuccess,\n    onError,\n    showFeedback = true,\n    successMessage = 'Copied to clipboard',\n    errorMessage = 'Failed to copy'\n  } = options;\n\n  if (!text || text.trim().length === 0) {\n    console.warn('‚ö†Ô∏è No text provided to copy');\n    return false;\n  }\n\n  try {\n    const embedded = isEmbedded();\n    let success = false;\n    let method: 'clipboard' | 'execCommand' = 'clipboard';\n\n    console.log(`üìã Copying text (embedded: ${embedded}):`, text.substring(0, 50) + '...');\n\n    if (embedded) {\n      // For embedded contexts, use execCommand for reliability\n      console.log('üîß Using execCommand for embedded context');\n      success = await copyWithExecCommand(text);\n      method = 'execCommand';\n    } else {\n      // For non-embedded contexts, try modern clipboard API first\n      try {\n        if (navigator.clipboard && window.isSecureContext) {\n          await navigator.clipboard.writeText(text);\n          success = true;\n          console.log('‚úÖ Modern clipboard API succeeded');\n        } else {\n          throw new Error('Clipboard API not available');\n        }\n      } catch (clipboardError) {\n        console.warn('‚ö†Ô∏è Modern clipboard API failed, trying fallback:', clipboardError);\n        \n        // Fallback to execCommand\n        success = await copyWithExecCommand(text);\n        method = 'execCommand';\n      }\n    }\n\n    if (success) {\n      console.log(`‚úÖ Copy succeeded using ${method}`);\n      if (showFeedback) {\n        // Could integrate with notification system here\n        console.log(`üìã ${successMessage}`);\n      }\n      onSuccess?.(method);\n      return true;\n    } else {\n      console.warn('‚ö†Ô∏è All copy methods failed');\n      if (showFeedback) {\n        console.warn(`‚ùå ${errorMessage}`);\n      }\n      onError?.(new Error('All copy methods failed'));\n      return false;\n    }\n  } catch (error) {\n    console.error('‚ùå Copy operation failed:', error);\n    if (showFeedback) {\n      console.error(`‚ùå ${errorMessage}`);\n    }\n    onError?.(error);\n    return false;\n  }\n}",
    "start_line": 48,
    "end_line": 120,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function copyToClipboard",
    "component_id": "client.utils.copyToClipboard.copyToClipboard"
  },
  "client.utils.copyToClipboard.copyWithExecCommand": {
    "id": "client.utils.copyToClipboard.copyWithExecCommand",
    "name": "copyWithExecCommand",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/copyToClipboard.ts",
    "relative_path": "client/utils/copyToClipboard.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function copyWithExecCommand(text: string): Promise<boolean> {\n  return new Promise((resolve) => {\n    try {\n      const textArea = document.createElement('textarea');\n      textArea.value = text;\n      \n      // Style for invisibility\n      textArea.style.position = 'fixed';\n      textArea.style.top = '0';\n      textArea.style.left = '0';\n      textArea.style.width = '2em';\n      textArea.style.height = '2em';\n      textArea.style.padding = '0';\n      textArea.style.border = 'none';\n      textArea.style.outline = 'none';\n      textArea.style.boxShadow = 'none';\n      textArea.style.background = 'transparent';\n      textArea.style.opacity = '0';\n      textArea.style.pointerEvents = 'none';\n      textArea.style.zIndex = '-1';\n      \n      document.body.appendChild(textArea);\n      textArea.focus();\n      textArea.select();\n      \n      const success = document.execCommand('copy');\n      document.body.removeChild(textArea);\n      \n      console.log(`‚úÖ ExecCommand copy ${success ? 'succeeded' : 'failed'}`);\n      resolve(success);\n    } catch (error) {\n      console.warn('‚ö†Ô∏è ExecCommand copy failed:', error);\n      resolve(false);\n    }\n  });\n}",
    "start_line": 125,
    "end_line": 160,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function copyWithExecCommand",
    "component_id": "client.utils.copyToClipboard.copyWithExecCommand"
  },
  "client.utils.copyToClipboard.useCopyToClipboard": {
    "id": "client.utils.copyToClipboard.useCopyToClipboard",
    "name": "useCopyToClipboard",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/copyToClipboard.ts",
    "relative_path": "client/utils/copyToClipboard.ts",
    "depends_on": [
      "client.utils.copyToClipboard.copyToClipboard",
      "client.utils.copyToClipboard.CopyOptions"
    ],
    "source_code": "function useCopyToClipboard() {\n  // This could be enhanced with React state if needed\n  // For now, keeping it simple as a pure function\n  \n  const copyWithState = async (\n    text: string, \n    options: CopyOptions = {}\n  ): Promise<{ success: boolean; method?: 'clipboard' | 'execCommand'; error?: unknown }> => {\n    try {\n      const success = await copyToClipboard(text, options);\n      return { \n        success, \n        method: success ? 'clipboard' : undefined,\n        error: undefined \n      };\n    } catch (error) {\n      return { \n        success: false, \n        error \n      };\n    }\n  };\n\n  return {\n    copy: copyToClipboard,\n    copyWithState\n  };\n}",
    "start_line": 166,
    "end_line": 193,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function useCopyToClipboard",
    "component_id": "client.utils.copyToClipboard.useCopyToClipboard"
  },
  "client.utils.edgeCollisionTest.Point": {
    "id": "client.utils.edgeCollisionTest.Point",
    "name": "Point",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeCollisionTest.ts",
    "relative_path": "client/utils/edgeCollisionTest.ts",
    "depends_on": [],
    "source_code": "interface Point {\n  x: number;\n  y: number;\n}",
    "start_line": 6,
    "end_line": 9,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Point",
    "component_id": "client.utils.edgeCollisionTest.Point"
  },
  "client.utils.edgeCollisionTest.Rectangle": {
    "id": "client.utils.edgeCollisionTest.Rectangle",
    "name": "Rectangle",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeCollisionTest.ts",
    "relative_path": "client/utils/edgeCollisionTest.ts",
    "depends_on": [],
    "source_code": "interface Rectangle {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}",
    "start_line": 11,
    "end_line": 16,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface Rectangle",
    "component_id": "client.utils.edgeCollisionTest.Rectangle"
  },
  "client.utils.edgeCollisionTest.lineIntersectsRect": {
    "id": "client.utils.edgeCollisionTest.lineIntersectsRect",
    "name": "lineIntersectsRect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeCollisionTest.ts",
    "relative_path": "client/utils/edgeCollisionTest.ts",
    "depends_on": [
      "client.utils.edgeCollisionTest.Rectangle",
      "client.utils.edgeCollisionTest.Point",
      "client.utils.edgeCollisionTest.lineIntersectsLine"
    ],
    "source_code": "function lineIntersectsRect(p1: Point, p2: Point, rect: Rectangle): boolean {\n  const left = rect.x;\n  const right = rect.x + rect.width;\n  const top = rect.y;\n  const bottom = rect.y + rect.height;\n\n  // First, check if the segment lies completely outside on one side\n  if ((p1.x < left && p2.x < left) || (p1.x > right && p2.x > right)) {\n    return false;\n  }\n  if ((p1.y < top && p2.y < top) || (p1.y > bottom && p2.y > bottom)) {\n    return false;\n  }\n\n  // If both points are inside, treat as non-intersection to allow hugging edges\n  const inside =\n    p1.x > left && p1.x < right && p1.y > top && p1.y < bottom &&\n    p2.x > left && p2.x < right && p2.y > top && p2.y < bottom;\n  if (inside) {\n    return false;\n  }\n\n  // Otherwise, check actual edge intersections with a tiny epsilon\n  const epsilon = 1e-6;\n  const horizontal = [\n    lineIntersectsLine(p1, p2, { x: left - epsilon, y: top }, { x: right + epsilon, y: top }),\n    lineIntersectsLine(p1, p2, { x: left - epsilon, y: bottom }, { x: right + epsilon, y: bottom }),\n  ];\n  if (horizontal.some(Boolean)) return true;\n\n  const vertical = [\n    lineIntersectsLine(p1, p2, { x: left, y: top - epsilon }, { x: left, y: bottom + epsilon }),\n    lineIntersectsLine(p1, p2, { x: right, y: top - epsilon }, { x: right, y: bottom + epsilon }),\n  ];\n  return vertical.some(Boolean);\n}",
    "start_line": 21,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "p1",
      "p2",
      "rect"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lineIntersectsRect",
    "component_id": "client.utils.edgeCollisionTest.lineIntersectsRect"
  },
  "client.utils.edgeCollisionTest.lineIntersectsLine": {
    "id": "client.utils.edgeCollisionTest.lineIntersectsLine",
    "name": "lineIntersectsLine",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeCollisionTest.ts",
    "relative_path": "client/utils/edgeCollisionTest.ts",
    "depends_on": [
      "client.utils.edgeCollisionTest.Point"
    ],
    "source_code": "function lineIntersectsLine(p1: Point, p2: Point, p3: Point, p4: Point): boolean {\n  const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);\n  if (Math.abs(denom) < 1e-10) return false; // parallel lines\n  \n  const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;\n  const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;\n  \n  return t >= 0 && t <= 1 && u >= 0 && u <= 1;\n}",
    "start_line": 61,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "p1",
      "p2",
      "p3",
      "p4"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lineIntersectsLine",
    "component_id": "client.utils.edgeCollisionTest.lineIntersectsLine"
  },
  "client.utils.edgeCollisionTest.testEdgeCollision": {
    "id": "client.utils.edgeCollisionTest.testEdgeCollision",
    "name": "testEdgeCollision",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeCollisionTest.ts",
    "relative_path": "client/utils/edgeCollisionTest.ts",
    "depends_on": [
      "client.utils.edgeCollisionTest.lineIntersectsRect",
      "client.utils.edgeCollisionTest.Rectangle",
      "client.utils.edgeCollisionTest.Point"
    ],
    "source_code": "function testEdgeCollision(\n  startPoint: Point,\n  endPoint: Point,\n  bendPoints: Point[],\n  nodes: Rectangle[]\n): { collides: boolean; details: string[] } {\n  // Create full path: start ‚Üí bend points ‚Üí end\n  const fullPath = [startPoint, ...bendPoints, endPoint];\n  \n  const details: string[] = [];\n  let collides = false;\n  \n  // Check each path segment against each node\n  for (let i = 0; i < fullPath.length - 1; i++) {\n    const p1 = fullPath[i];\n    const p2 = fullPath[i + 1];\n    \n    for (let j = 0; j < nodes.length; j++) {\n      const node = nodes[j];\n      \n      if (lineIntersectsRect(p1, p2, node)) {\n        details.push(`‚ùå Segment ${i} (${p1.x.toFixed(1)},${p1.y.toFixed(1)}) ‚Üí (${p2.x.toFixed(1)},${p2.y.toFixed(1)}) intersects node ${j} at (${node.x},${node.y})`);\n        collides = true;\n      }\n    }\n  }\n  \n  if (!collides) {\n    details.push('‚úÖ Edge successfully routes around all nodes');\n  }\n  \n  return { collides, details };\n}",
    "start_line": 74,
    "end_line": 106,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "startPoint",
      "endPoint",
      "bendPoints",
      "nodes"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function testEdgeCollision",
    "component_id": "client.utils.edgeCollisionTest.testEdgeCollision"
  },
  "client.utils.edgeRoutingMode.RoutingMode": {
    "id": "client.utils.edgeRoutingMode.RoutingMode",
    "name": "RoutingMode",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeRoutingMode.ts",
    "relative_path": "client/utils/edgeRoutingMode.ts",
    "depends_on": [],
    "source_code": "type RoutingMode = 'ELK' | 'libavoid';",
    "start_line": 20,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type RoutingMode",
    "component_id": "client.utils.edgeRoutingMode.RoutingMode"
  },
  "client.utils.edgeRoutingMode.getEdgeRoutingMode": {
    "id": "client.utils.edgeRoutingMode.getEdgeRoutingMode",
    "name": "getEdgeRoutingMode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeRoutingMode.ts",
    "relative_path": "client/utils/edgeRoutingMode.ts",
    "depends_on": [
      "client.core.viewstate.modeHelpers.getModeFromViewState",
      "client.components.graph.types.index.RawGraph",
      "client.viewstate.ViewState.ViewState",
      "client.components.graph.mutations.findLCG",
      "client.utils.edgeRoutingMode.RoutingMode"
    ],
    "source_code": "function getEdgeRoutingMode(\n  sourceNodeId: string,\n  targetNodeId: string,\n  rawGraph: RawGraph | null,\n  viewState: ViewState | null\n): RoutingMode {\n  // If no graph or viewState, default to libavoid (FREE mode)\n  if (!rawGraph || !viewState) {\n    return 'libavoid';\n  }\n\n  // Find the edge's parent group (LCG of source and target)\n  // The LCG is where the edge is stored in the domain graph\n  const edgeParent = findLCG(rawGraph, [sourceNodeId, targetNodeId]);\n\n  if (edgeParent) {\n    // Use the parent group's mode to determine routing\n    const parentMode = getModeFromViewState(viewState, edgeParent.id);\n    if (parentMode === 'LOCK') {\n      return 'ELK';\n    }\n  }\n\n  // If no parent found, or parent is 'FREE', use libavoid\n  return 'libavoid';\n}",
    "start_line": 38,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sourceNodeId",
      "targetNodeId",
      "rawGraph",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getEdgeRoutingMode",
    "component_id": "client.utils.edgeRoutingMode.getEdgeRoutingMode"
  },
  "client.utils.edgeVisibility.ensureEdgeVisibility": {
    "id": "client.utils.edgeVisibility.ensureEdgeVisibility",
    "name": "ensureEdgeVisibility",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeVisibility.ts",
    "relative_path": "client/utils/edgeVisibility.ts",
    "depends_on": [
      "client.components.graph.styles.canvasStyles.getEdgeZIndex",
      "client.components.graph.styles.canvasStyles.getEdgeStyle"
    ],
    "source_code": "function ensureEdgeVisibility(\n  edges: Edge[], \n  options: {\n    isConnectedToSelected?: boolean;\n    forceVisible?: boolean;\n    customZIndex?: number;\n  } = {}\n): Edge[] {\n  const {\n    isConnectedToSelected = false,\n    forceVisible = true,\n    customZIndex = undefined\n  } = options;\n\n  return edges.map(edge => {\n    const baseStyle = getEdgeStyle(false, isConnectedToSelected);\n    const zIndex = customZIndex ?? getEdgeZIndex(isConnectedToSelected);\n    \n    return {\n      ...edge,\n      hidden: forceVisible ? false : edge.hidden,\n      style: {\n        ...edge.style,\n        ...baseStyle,\n        opacity: forceVisible ? 1 : edge.style?.opacity ?? 1,\n        zIndex,\n      },\n      zIndex,\n      // Set the label from data\n      label: edge.data?.labelText || edge.label,\n      // Animations for connected edges\n      animated: isConnectedToSelected && CANVAS_STYLES.edges.connected.animated,\n    };\n  });\n}",
    "start_line": 14,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edges",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensureEdgeVisibility",
    "component_id": "client.utils.edgeVisibility.ensureEdgeVisibility"
  },
  "client.utils.edgeVisibility.updateEdgeStylingOnSelection": {
    "id": "client.utils.edgeVisibility.updateEdgeStylingOnSelection",
    "name": "updateEdgeStylingOnSelection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeVisibility.ts",
    "relative_path": "client/utils/edgeVisibility.ts",
    "depends_on": [
      "client.components.graph.styles.canvasStyles.getEdgeZIndex",
      "client.components.graph.styles.canvasStyles.getEdgeStyle"
    ],
    "source_code": "function updateEdgeStylingOnSelection(\n  edges: Edge[],\n  selectedNodeIds: string[]\n): Edge[] {\n  return edges.map(edge => {\n    // Check if edge connects to selected nodes\n    const isConnectedToSelected = selectedNodeIds.includes(edge.source) || \n                                 selectedNodeIds.includes(edge.target);\n    \n    return {\n      ...edge,\n      hidden: false, // Always force visibility\n      style: {\n        ...edge.style,\n        ...getEdgeStyle(false, isConnectedToSelected),\n        zIndex: getEdgeZIndex(isConnectedToSelected),\n      },\n      zIndex: getEdgeZIndex(isConnectedToSelected),\n      animated: isConnectedToSelected && CANVAS_STYLES.edges.connected.animated,\n    };\n  });\n}",
    "start_line": 53,
    "end_line": 74,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edges",
      "selectedNodeIds"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updateEdgeStylingOnSelection",
    "component_id": "client.utils.edgeVisibility.updateEdgeStylingOnSelection"
  },
  "client.utils.edgeVisibility.updateEdgeStylingOnDeselection": {
    "id": "client.utils.edgeVisibility.updateEdgeStylingOnDeselection",
    "name": "updateEdgeStylingOnDeselection",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/edgeVisibility.ts",
    "relative_path": "client/utils/edgeVisibility.ts",
    "depends_on": [
      "client.components.graph.styles.canvasStyles.getEdgeZIndex",
      "client.components.graph.styles.canvasStyles.getEdgeStyle"
    ],
    "source_code": "function updateEdgeStylingOnDeselection(edges: Edge[]): Edge[] {\n  return edges.map(edge => ({\n    ...edge,\n    hidden: false,\n    style: {\n      ...edge.style,\n      ...getEdgeStyle(false, false),\n      zIndex: getEdgeZIndex(false),\n    },\n    zIndex: getEdgeZIndex(false)\n  }));\n}",
    "start_line": 79,
    "end_line": 90,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edges"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updateEdgeStylingOnDeselection",
    "component_id": "client.utils.edgeVisibility.updateEdgeStylingOnDeselection"
  },
  "client.utils.elkOperations.test.ensureVisualizationFolder": {
    "id": "client.utils.elkOperations.test.ensureVisualizationFolder",
    "name": "ensureVisualizationFolder",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/elkOperations.test.ts",
    "relative_path": "client/utils/elkOperations.test.ts",
    "depends_on": [],
    "source_code": "function ensureVisualizationFolder() {\n    if (!fs.existsSync(VISUALIZATION_FOLDER)) {\n        fs.mkdirSync(VISUALIZATION_FOLDER);\n    }\n}",
    "start_line": 21,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensureVisualizationFolder",
    "component_id": "client.utils.elkOperations.test.ensureVisualizationFolder"
  },
  "client.utils.elkOperations.test.saveGraphToFile": {
    "id": "client.utils.elkOperations.test.saveGraphToFile",
    "name": "saveGraphToFile",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/elkOperations.test.ts",
    "relative_path": "client/utils/elkOperations.test.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.elkOperations.test.ensureVisualizationFolder",
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "function saveGraphToFile(graph: ElkNode, filename: string) {\n    ensureVisualizationFolder();\n    const outputPath = path.join(VISUALIZATION_FOLDER, filename);\n    fs.writeFileSync(outputPath, JSON.stringify(graph, null, 2));\n    console.log(`Graph saved to ${outputPath}`);\n}",
    "start_line": 27,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "filename"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function saveGraphToFile",
    "component_id": "client.utils.elkOperations.test.saveGraphToFile"
  },
  "client.utils.elkOperations.test.findNodeById": {
    "id": "client.utils.elkOperations.test.findNodeById",
    "name": "findNodeById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/elkOperations.test.ts",
    "relative_path": "client/utils/elkOperations.test.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.elkOperations.test.findNodeById"
    ],
    "source_code": "function findNodeById(node: ElkNode, id: string): ElkNode | null {\n    if (node.id === id) return node;\n    if (node.children) {\n        for (const child of node.children) {\n            const found = findNodeById(child, id);\n            if (found) return found;\n        }\n    }\n    return null;\n}",
    "start_line": 35,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findNodeById",
    "component_id": "client.utils.elkOperations.test.findNodeById"
  },
  "client.utils.elkOperations.test.findEdgeById": {
    "id": "client.utils.elkOperations.test.findEdgeById",
    "name": "findEdgeById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/elkOperations.test.ts",
    "relative_path": "client/utils/elkOperations.test.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkEdge",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.elkOperations.test.findEdgeById"
    ],
    "source_code": "function findEdgeById(node: ElkNode, edgeId: string): ElkEdge | null {\n    if (node.edges) {\n        for (const edge of node.edges) {\n            if (edge.id === edgeId) return edge;\n        }\n    }\n    if (node.children) {\n        for (const child of node.children) {\n            const result = findEdgeById(child, edgeId);\n            if (result) return result;\n        }\n    }\n    return null;\n}",
    "start_line": 47,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "edgeId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findEdgeById",
    "component_id": "client.utils.elkOperations.test.findEdgeById"
  },
  "client.utils.eventSender.sendEventWithAutoChunk": {
    "id": "client.utils.eventSender.sendEventWithAutoChunk",
    "name": "sendEventWithAutoChunk",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/eventSender.js",
    "relative_path": "client/utils/eventSender.js",
    "depends_on": [
      "scripts.test-vercel-preview.error",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.realtime.RtcClient.send"
    ],
    "source_code": "function sendEventWithAutoChunk(\n  dc,\n  evt\n) {\n  if (!dc || dc.readyState !== \"open\") {\n    console.warn(\"data-channel not ready ‚Äì caller should queue & retry\");\n    return false;\n  }\n\n  const payload = JSON.stringify(evt);\n  if (payload.length <= MAX_BYTES) {\n    dc.send(payload);\n    return true;\n  }\n\n  // ‚îÄ‚îÄ try text-chunking if the payload is a user-message ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  if (\n    evt.type === \"conversation.item.create\" &&\n    evt.item?.type === \"message\" &&\n    evt.item?.content?.[0]?.type === \"input_text\"\n  ) {\n    const fullText = evt.item.content[0].text;\n\n    // Rough slice ‚Äì we'll make sure each encoded chunk is ‚â§ MAX_BYTES\n    const CHUNK_SIZE = 800;                          // characters\n\n    let index = 0;\n    const totalChunks = Math.ceil(fullText.length / CHUNK_SIZE);\n\n    while (index < fullText.length) {\n      const slice = fullText.slice(index, index + CHUNK_SIZE);\n      index += CHUNK_SIZE;\n\n      // Duplicate the original event but replace the text with the slice\n      // and prepend a tiny marker so the assistant can join them.\n      const chunkEvt = {\n        ...evt,\n        // event_id per chunk is fine ‚Äì the assistant concatenates on content,\n        // not on ID.\n        event_id: crypto.randomUUID(),\n        item: {\n          ...evt.item,\n          content: [\n            {\n              ...evt.item.content[0],\n              text: `${CHUNK_PREFIX}${slice}`,\n            },\n          ],\n        },\n      };\n\n      // make sure we didn't blow the limit (very unlikely, but safe to test)\n      const wire = JSON.stringify(chunkEvt);\n      if (wire.length > MAX_BYTES) {\n        console.error(\"single chunk still too large\", wire.length);\n        return false;\n      }\n      dc.send(wire);\n    }\n\n    // ‚Ü≥ after *all* chunks send a bare \"response.create\" so the assistant\n    //    starts replying immediately (mirrors the open-source example)\n    dc.send(JSON.stringify({ type: \"response.create\" }));\n    return true;\n  }\n\n  console.error(\n    `event ${evt.type} is ${payload.length} B ‚Äì can't auto-chunk; ` +\n      \"shrink it before calling sendEventWithAutoChunk\"\n  );\n  return false;\n}",
    "start_line": 13,
    "end_line": 84,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "dc",
      "evt"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sendEventWithAutoChunk",
    "component_id": "client.utils.eventSender.sendEventWithAutoChunk"
  },
  "client.utils.exportPng.ExportOptions": {
    "id": "client.utils.exportPng.ExportOptions",
    "name": "ExportOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/exportPng.ts",
    "relative_path": "client/utils/exportPng.ts",
    "depends_on": [],
    "source_code": "interface ExportOptions {\n  scale?: number;\n  backgroundColor?: string;\n  imageTimeout?: number;\n  showNotification?: (type: string, title: string, message: string) => void;\n}",
    "start_line": 6,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ExportOptions",
    "component_id": "client.utils.exportPng.ExportOptions"
  },
  "client.utils.exportPng.exportArchitectureAsPNG": {
    "id": "client.utils.exportPng.exportArchitectureAsPNG",
    "name": "exportArchitectureAsPNG",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/exportPng.ts",
    "relative_path": "client/utils/exportPng.ts",
    "depends_on": [
      "client.utils.exportPng.ExportOptions",
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function exportArchitectureAsPNG(\n  nodes: any[],\n  options: ExportOptions = {}\n): Promise<void> {\n  const {\n    scale = 2,\n    backgroundColor = '#ffffff',\n    imageTimeout = 30000,\n    showNotification\n  } = options;\n\n  if (!nodes.length) {\n    console.warn('‚ö†Ô∏è No architecture to export');\n    return;\n  }\n\n  try {\n    console.log('üì∏ Starting PNG export...');\n    \n    // Temporarily hide sidebar during export to avoid interference\n    const sidebar = document.querySelector('[class*=\"w-80\"]') || document.querySelector('[class*=\"w-18\"]');\n    const originalSidebarDisplay = sidebar ? sidebar.style.display : '';\n    if (sidebar) {\n      sidebar.style.display = 'none';\n      console.log('üîß Temporarily hiding sidebar for export');\n    }\n    \n    // Small delay to ensure sidebar is hidden\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Get the main ReactFlow container (not viewport)\n    const reactFlowContainer = document.querySelector('.react-flow');\n    if (!reactFlowContainer) {\n      throw new Error('ReactFlow container not found');\n    }\n\n    console.log('üìê Capturing entire ReactFlow container');\n    console.log('üìê Container dimensions:', {\n      width: reactFlowContainer.clientWidth,\n      height: reactFlowContainer.clientHeight,\n      scrollWidth: reactFlowContainer.scrollWidth,\n      scrollHeight: reactFlowContainer.scrollHeight\n    });\n    \n    // Debug: Check what's in the original ReactFlow container\n    const originalNodes = reactFlowContainer.querySelectorAll('.react-flow__node');\n    const originalEdges = reactFlowContainer.querySelectorAll('.react-flow__edge');\n    const originalImages = reactFlowContainer.querySelectorAll('img');\n    \n    console.log(`üîç Original container contents:`, {\n      nodes: originalNodes.length,\n      edges: originalEdges.length,\n      images: originalImages.length,\n      totalElements: reactFlowContainer.querySelectorAll('*').length\n    });\n    \n    // Debug nodes in detail\n    originalNodes.forEach((node, index) => {\n      const nodeElement = node as HTMLElement;\n      const nodeText = nodeElement.textContent || nodeElement.innerText || '';\n      const nodeImages = nodeElement.querySelectorAll('img');\n      console.log(`üîç Original Node ${index + 1}:`, {\n        id: nodeElement.getAttribute('data-id') || 'no-id',\n        text: nodeText.substring(0, 50) + (nodeText.length > 50 ? '...' : ''),\n        classes: nodeElement.className,\n        visible: nodeElement.offsetWidth > 0 && nodeElement.offsetHeight > 0,\n        images: nodeImages.length,\n        imagesSrc: Array.from(nodeImages).map(img => img.src.substring(0, 100)),\n        position: {\n          left: nodeElement.style.left,\n          top: nodeElement.style.top,\n          transform: nodeElement.style.transform\n        },\n        styles: {\n          display: nodeElement.style.display,\n          visibility: nodeElement.style.visibility,\n          opacity: nodeElement.style.opacity\n        }\n      });\n    });\n    \n    // Debug edges in detail\n    originalEdges.forEach((edge, index) => {\n      const edgeElement = edge as HTMLElement;\n      console.log(`üîç Original Edge ${index + 1}:`, {\n        id: edgeElement.getAttribute('data-id') || 'no-id',\n        classes: edgeElement.className,\n        visible: edgeElement.offsetWidth > 0 && edgeElement.offsetHeight > 0,\n        pathElements: edgeElement.querySelectorAll('path').length,\n        styles: {\n          display: edgeElement.style.display,\n          visibility: edgeElement.style.visibility,\n          opacity: edgeElement.style.opacity\n        }\n      });\n    });\n    \n    // Debug images in detail\n    originalImages.forEach((img, index) => {\n      console.log(`üîç Original Image ${index + 1}:`, {\n        src: img.src.substring(0, 100) + (img.src.length > 100 ? '...' : ''),\n        alt: img.alt,\n        complete: img.complete,\n        naturalWidth: img.naturalWidth,\n        naturalHeight: img.naturalHeight,\n        width: img.width,\n        height: img.height,\n        visible: img.offsetWidth > 0 && img.offsetHeight > 0,\n        styles: {\n          display: img.style.display,\n          visibility: img.style.visibility,\n          opacity: img.style.opacity\n        }\n      });\n    });\n\n    // Import html2canvas\n    const html2canvas = (await import('html2canvas')).default;\n    \n    // Simple approach: capture the entire ReactFlow container\n    const captureCanvas = await html2canvas(reactFlowContainer as HTMLElement, {\n      backgroundColor,\n      scale, // 2x resolution for HD quality\n      useCORS: true,\n      allowTaint: true,\n      logging: false, // Disable logging to reduce noise\n      foreignObjectRendering: true, // Support for SVG text\n      imageTimeout, // 30 second timeout for images to load\n      removeContainer: false, // Keep container structure\n      ignoreElements: (element): boolean => {\n        // Only exclude UI controls and overlays, keep all content\n        return element.classList.contains('react-flow__controls') ||\n               element.classList.contains('react-flow__minimap') ||\n               element.classList.contains('react-flow__attribution') ||\n               element.classList.contains('react-flow__panel') ||\n               (element.tagName === 'BUTTON' && element.closest('.react-flow__controls') !== null) ||\n               (element.classList.contains('absolute') && (\n                 element.classList.contains('top-4') || \n                 element.classList.contains('bottom-4') ||\n                 element.textContent?.includes('Share') ||\n                 element.textContent?.includes('Export') ||\n                 element.textContent?.includes('Save')\n               ));\n      },\n      onclone: async (clonedDoc) => {\n        console.log('üîß Processing cloned document for export...');\n        \n        // Debug: Check what ReactFlow elements exist in the cloned document\n        const clonedContainer = clonedDoc.querySelector('.react-flow');\n        const clonedNodes = clonedDoc.querySelectorAll('.react-flow__node');\n        const clonedEdges = clonedDoc.querySelectorAll('.react-flow__edge');\n        const clonedImages = clonedDoc.querySelectorAll('img');\n        \n        console.log(`üîç Cloned document contents:`, {\n          hasContainer: !!clonedContainer,\n          nodes: clonedNodes.length,\n          edges: clonedEdges.length,\n          images: clonedImages.length,\n          totalElements: clonedDoc.querySelectorAll('*').length\n        });\n        \n        // Debug cloned nodes in detail\n        clonedNodes.forEach((node, index) => {\n          const nodeElement = node as HTMLElement;\n          const nodeText = nodeElement.textContent || nodeElement.innerText || '';\n          const nodeImages = nodeElement.querySelectorAll('img');\n          console.log(`üîç Cloned Node ${index + 1}:`, {\n            id: nodeElement.getAttribute('data-id') || 'no-id',\n            classes: nodeElement.className,\n            text: nodeText.substring(0, 50) + (nodeText.length > 50 ? '...' : ''),\n            images: nodeImages.length,\n            imagesSrc: Array.from(nodeImages).map(img => img.src.substring(0, 100)),\n            visible: nodeElement.offsetWidth > 0 && nodeElement.offsetHeight > 0,\n            position: {\n              left: nodeElement.style.left,\n              top: nodeElement.style.top,\n              transform: nodeElement.style.transform\n            },\n            innerHTML: nodeElement.innerHTML.substring(0, 200) + (nodeElement.innerHTML.length > 200 ? '...' : '')\n          });\n        });\n        \n        // Debug cloned edges in detail\n        clonedEdges.forEach((edge, index) => {\n          const edgeElement = edge as HTMLElement;\n          console.log(`üîç Cloned Edge ${index + 1}:`, {\n            id: edgeElement.getAttribute('data-id') || 'no-id',\n            classes: edgeElement.className,\n            visible: edgeElement.offsetWidth > 0 && edgeElement.offsetHeight > 0,\n            pathElements: edgeElement.querySelectorAll('path').length,\n            innerHTML: edgeElement.innerHTML.substring(0, 200) + (edgeElement.innerHTML.length > 200 ? '...' : '')\n          });\n        });\n        \n        // Debug cloned images in detail\n        clonedImages.forEach((img, index) => {\n          console.log(`üîç Cloned Image ${index + 1}:`, {\n            src: img.src.substring(0, 100) + (img.src.length > 100 ? '...' : ''),\n            alt: img.alt,\n            complete: img.complete,\n            naturalWidth: img.naturalWidth,\n            naturalHeight: img.naturalHeight,\n            width: img.width,\n            height: img.height,\n            visible: img.offsetWidth > 0 && img.offsetHeight > 0\n          });\n        });\n    \n        // Wait a moment for images to load in cloned document\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        \n        // Force all images to be visible and loaded\n        const images = clonedDoc.querySelectorAll('img');\n        console.log(`üñºÔ∏è Found ${images.length} images to process`);\n        \n        images.forEach((img, index) => {\n          console.log(`üîß Processing image ${index + 1} BEFORE:`, {\n            src: img.src.substring(0, 100),\n            complete: img.complete,\n            naturalWidth: img.naturalWidth,\n            naturalHeight: img.naturalHeight,\n            display: img.style.display,\n            visibility: img.style.visibility,\n            opacity: img.style.opacity\n          });\n          \n          // Force image visibility\n          img.style.display = 'block';\n          img.style.visibility = 'visible';\n          img.style.opacity = '1';\n          img.style.maxWidth = 'none';\n          img.style.maxHeight = 'none';\n          \n          // If image has no src or failed to load, try to fix it\n          if (!img.src || img.src.includes('data:') || !img.complete) {\n            console.log(`üîÑ Fixing image ${index + 1}:`, img.src);\n            \n            // Try to get the original src from data attributes or parent\n            const originalSrc = img.getAttribute('data-src') || \n                              img.getAttribute('data-original') ||\n                              img.src;\n            \n            if (originalSrc && !originalSrc.includes('data:')) {\n              img.src = originalSrc;\n              img.crossOrigin = 'anonymous';\n            }\n          }\n          \n          console.log(`üîß Processing image ${index + 1} AFTER:`, {\n            src: img.src.substring(0, 100),\n            complete: img.complete,\n            naturalWidth: img.naturalWidth,\n            naturalHeight: img.naturalHeight,\n            display: img.style.display,\n            visibility: img.style.visibility,\n            opacity: img.style.opacity\n          });\n        });\n    \n        // Ensure all text is visible and properly styled\n        const textElements = clonedDoc.querySelectorAll('text, span, div, p, h1, h2, h3, h4, h5, h6, label');\n        console.log(`üìù Found ${textElements.length} text elements to process`);\n        \n        textElements.forEach((textEl, index) => {\n          const htmlEl = textEl as HTMLElement;\n          const originalText = htmlEl.textContent || htmlEl.innerText || '';\n          const originalStyles = {\n            visibility: htmlEl.style.visibility,\n            opacity: htmlEl.style.opacity,\n            color: htmlEl.style.color,\n            fontSize: htmlEl.style.fontSize,\n            display: htmlEl.style.display,\n            position: htmlEl.style.position,\n            transform: htmlEl.style.transform\n          };\n          \n          console.log(`üìù Text element ${index + 1}:`, {\n            tagName: htmlEl.tagName,\n            text: originalText.substring(0, 50) + (originalText.length > 50 ? '...' : ''),\n            className: htmlEl.className,\n            originalStyles,\n            computedStyles: window.getComputedStyle ? {\n              visibility: window.getComputedStyle(htmlEl).visibility,\n              opacity: window.getComputedStyle(htmlEl).opacity,\n              color: window.getComputedStyle(htmlEl).color,\n              fontSize: window.getComputedStyle(htmlEl).fontSize\n            } : 'N/A'\n          });\n          \n          if (htmlEl.style) {\n            htmlEl.style.visibility = 'visible';\n            htmlEl.style.opacity = '1';\n            htmlEl.style.color = htmlEl.style.color || '#000000';\n            htmlEl.style.fontSize = htmlEl.style.fontSize || '14px';\n            htmlEl.style.display = htmlEl.style.display || 'block';\n            \n            // Force text to be on top\n            if (htmlEl.style.position === 'absolute' || htmlEl.style.position === 'relative') {\n              htmlEl.style.zIndex = '9999';\n            }\n          }\n        });\n        \n        // Remove any loading spinners or placeholders\n        const loadingElements = clonedDoc.querySelectorAll('.loading, .spinner, .placeholder');\n        loadingElements.forEach(el => el.remove());\n        \n        // Final debug: Check the final state before html2canvas captures\n        const finalNodes = clonedDoc.querySelectorAll('.react-flow__node');\n        const finalEdges = clonedDoc.querySelectorAll('.react-flow__edge');\n        const finalImages = clonedDoc.querySelectorAll('img');\n        \n        console.log('üèÅ FINAL STATE before html2canvas:', {\n          nodes: finalNodes.length,\n          edges: finalEdges.length,\n          images: finalImages.length,\n          visibleNodes: Array.from(finalNodes).filter(n => (n as HTMLElement).offsetWidth > 0).length,\n          visibleEdges: Array.from(finalEdges).filter(e => (e as HTMLElement).offsetWidth > 0).length,\n          visibleImages: Array.from(finalImages).filter(i => (i as HTMLElement).offsetWidth > 0).length,\n          loadedImages: Array.from(finalImages).filter(i => (i as HTMLImageElement).complete).length\n        });\n        \n        console.log('‚úÖ Cloned document processing complete');\n      }\n    });\n    \n    console.log('üìä Canvas capture completed:', {\n      width: captureCanvas.width,\n      height: captureCanvas.height,\n      dataURL: captureCanvas.toDataURL().substring(0, 100) + '...'\n    });\n    \n    // Convert to blob and download\n    captureCanvas.toBlob((blob) => {\n      if (!blob) {\n        console.error('‚ùå Failed to create PNG blob');\n        return;\n      }\n      \n      // Create download link\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `architecture-${new Date().toISOString().slice(0, 10)}.png`;\n      \n      // Trigger download\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      // Cleanup\n      URL.revokeObjectURL(url);\n      \n      console.log('‚úÖ PNG export completed successfully');\n      \n      // Restore sidebar after successful export\n      if (sidebar) {\n        sidebar.style.display = originalSidebarDisplay;\n        console.log('üîß Restored sidebar after export');\n      }\n      \n      // Show success notification if available\n      if (showNotification) {\n        showNotification('success', 'Export Complete', 'Architecture exported as PNG');\n      }\n    }, 'image/png', 1.0); // Max quality\n    \n  } catch (error) {\n    console.error('‚ùå PNG export failed:', error);\n    \n    // Restore sidebar after failed export\n    const sidebar = document.querySelector('[class*=\"w-80\"]') || document.querySelector('[class*=\"w-18\"]');\n    if (sidebar) {\n      sidebar.style.display = '';\n      console.log('üîß Restored sidebar after failed export');\n    }\n    \n    // Show error notification if available\n    if (showNotification) {\n      showNotification('error', 'Export Failed', 'Failed to export PNG. Please try again.');\n    }\n    \n    throw error;\n  }\n}",
    "start_line": 16,
    "end_line": 400,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodes",
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function exportArchitectureAsPNG",
    "component_id": "client.utils.exportPng.exportArchitectureAsPNG"
  },
  "client.utils.graph_helper_functions.ElkLabel": {
    "id": "client.utils.graph_helper_functions.ElkLabel",
    "name": "ElkLabel",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [],
    "source_code": "interface ElkLabel {\n  text: string;\n}",
    "start_line": 2,
    "end_line": 4,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkLabel",
    "component_id": "client.utils.graph_helper_functions.ElkLabel"
  },
  "client.utils.graph_helper_functions.ElkEdge": {
    "id": "client.utils.graph_helper_functions.ElkEdge",
    "name": "ElkEdge",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkLabel"
    ],
    "source_code": "interface ElkEdge {\n  id: string;\n  sources: string[];\n  targets: string[];\n  labels?: ElkLabel[];\n}",
    "start_line": 6,
    "end_line": 11,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkEdge",
    "component_id": "client.utils.graph_helper_functions.ElkEdge"
  },
  "client.utils.graph_helper_functions.ElkNode": {
    "id": "client.utils.graph_helper_functions.ElkNode",
    "name": "ElkNode",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkEdge",
      "client.utils.graph_helper_functions.ElkLabel",
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "interface ElkNode {\n  id: string;\n  labels: ElkLabel[];\n  children?: ElkNode[];\n  edges?: ElkEdge[];\n}",
    "start_line": 13,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface ElkNode",
    "component_id": "client.utils.graph_helper_functions.ElkNode"
  },
  "client.utils.graph_helper_functions.EdgeCollection": {
    "id": "client.utils.graph_helper_functions.EdgeCollection",
    "name": "EdgeCollection",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkEdge",
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "interface EdgeCollection {\n  edgeArr: ElkEdge[];\n  parent: ElkNode;\n}",
    "start_line": 21,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface EdgeCollection",
    "component_id": "client.utils.graph_helper_functions.EdgeCollection"
  },
  "client.utils.graph_helper_functions.findNodeById": {
    "id": "client.utils.graph_helper_functions.findNodeById",
    "name": "findNodeById",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.findNodeById",
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "function findNodeById(node: ElkNode, id: string): ElkNode | null {\n  if (node.id === id) return node;\n  if (node.children) {\n    for (const child of node.children) {\n      const found = findNodeById(child, id);\n      if (found) return found;\n    }\n  }\n  return null;\n}",
    "start_line": 33,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findNodeById",
    "component_id": "client.utils.graph_helper_functions.findNodeById"
  },
  "client.utils.graph_helper_functions.findParentOfNode": {
    "id": "client.utils.graph_helper_functions.findParentOfNode",
    "name": "findParentOfNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findParentOfNode"
    ],
    "source_code": "function findParentOfNode(\n  root: ElkNode,\n  id: string,\n  parent: ElkNode | null = null\n): ElkNode | null {\n  if (root.id === id) return parent;\n  if (root.children) {\n    for (const child of root.children) {\n      const result = findParentOfNode(child, id, root);\n      if (result) return result;\n    }\n  }\n  return null;\n}",
    "start_line": 47,
    "end_line": 60,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "root",
      "id",
      "parent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findParentOfNode",
    "component_id": "client.utils.graph_helper_functions.findParentOfNode"
  },
  "client.utils.graph_helper_functions.getPathToNode": {
    "id": "client.utils.graph_helper_functions.getPathToNode",
    "name": "getPathToNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.getPathToNode"
    ],
    "source_code": "function getPathToNode(\n  node: ElkNode,\n  nodeId: string,\n  path: ElkNode[] = []\n): ElkNode[] | null {\n  if (node.id === nodeId) return [...path, node];\n  if (node.children) {\n    for (const child of node.children) {\n      const result = getPathToNode(child, nodeId, [...path, node]);\n      if (result) return result;\n    }\n  }\n  return null;\n}",
    "start_line": 65,
    "end_line": 78,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "nodeId",
      "path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getPathToNode",
    "component_id": "client.utils.graph_helper_functions.getPathToNode"
  },
  "client.utils.graph_helper_functions.findCommonAncestor": {
    "id": "client.utils.graph_helper_functions.findCommonAncestor",
    "name": "findCommonAncestor",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.getPathToNode"
    ],
    "source_code": "function findCommonAncestor(\n  layout: ElkNode,\n  id1: string,\n  id2: string\n): ElkNode | null {\n  const path1 = getPathToNode(layout, id1);\n  const path2 = getPathToNode(layout, id2);\n  \n  if (!path1 || !path2) {\n    return null;\n  }\n  \n  // Find the longest common prefix\n  let commonAncestor = null;\n  for (let i = 0; i < Math.min(path1.length, path2.length); i++) {\n    if (path1[i].id === path2[i].id) {\n      commonAncestor = path1[i];\n    } else {\n      break;\n    }\n  }\n  \n  return commonAncestor;\n}",
    "start_line": 83,
    "end_line": 106,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout",
      "id1",
      "id2"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findCommonAncestor",
    "component_id": "client.utils.graph_helper_functions.findCommonAncestor"
  },
  "client.utils.graph_helper_functions.collectEdges": {
    "id": "client.utils.graph_helper_functions.collectEdges",
    "name": "collectEdges",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.EdgeCollection"
    ],
    "source_code": "function collectEdges(node: ElkNode, collection: EdgeCollection[] = []): EdgeCollection[] {\n  if (node.edges) {\n    collection.push({ edgeArr: node.edges, parent: node });\n  }\n  if (node.children) {\n    for (const child of node.children) {\n      collectEdges(child, collection);\n    }\n  }\n  return collection;\n}",
    "start_line": 111,
    "end_line": 121,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "node",
      "collection"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function collectEdges",
    "component_id": "client.utils.graph_helper_functions.collectEdges"
  },
  "client.utils.graph_helper_functions.updateEdgesForNode": {
    "id": "client.utils.graph_helper_functions.updateEdgesForNode",
    "name": "updateEdgesForNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkEdge",
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findCommonAncestor"
    ],
    "source_code": "function updateEdgesForNode(nodeId: string, layout: ElkNode): ElkNode {\n  const allEdges = collectEdges(layout);\n  const edgesToMove: { edge: ElkEdge; currentParent: ElkNode; newParent: ElkNode }[] = [];\n  \n  // First pass: identify edges that need to be moved\n  for (const { edgeArr, parent } of allEdges) {\n    for (const edge of edgeArr) {\n      if (edge.sources.includes(nodeId) || edge.targets.includes(nodeId)) {\n        const sourceId = edge.sources[0];\n        const targetId = edge.targets[0];\n        \n        const commonAncestor = findCommonAncestor(layout, sourceId, targetId);\n        if (commonAncestor && parent.id !== commonAncestor.id) {\n          edgesToMove.push({\n            edge: edge,\n            currentParent: parent,\n            newParent: commonAncestor\n          });\n        }\n      }\n    }\n  }\n  \n  // Second pass: actually move the edges\n  for (const { edge, currentParent, newParent } of edgesToMove) {\n    // Remove from current parent\n    if (currentParent.edges) {\n      currentParent.edges = currentParent.edges.filter(e => e.id !== edge.id);\n    }\n    \n    // Add to new parent\n    if (!newParent.edges) {\n      newParent.edges = [];\n    }\n    newParent.edges.push(edge);\n  }\n  \n  return layout;\n}",
    "start_line": 127,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function updateEdgesForNode",
    "component_id": "client.utils.graph_helper_functions.updateEdgesForNode"
  },
  "client.utils.graph_helper_functions.reattachAllEdges": {
    "id": "client.utils.graph_helper_functions.reattachAllEdges",
    "name": "reattachAllEdges",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkEdge",
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findCommonAncestor"
    ],
    "source_code": "function reattachAllEdges(layout: ElkNode): ElkNode {\n  const allEdges = collectEdges(layout);\n  const edgesToMove: { edge: ElkEdge; currentParent: ElkNode; newParent: ElkNode }[] = [];\n  \n  // First pass: identify ALL edges that need to be moved\n  for (const { edgeArr, parent } of allEdges) {\n    for (const edge of edgeArr) {\n      const sourceId = edge.sources[0];\n      const targetId = edge.targets[0];\n      \n      const commonAncestor = findCommonAncestor(layout, sourceId, targetId);\n      if (commonAncestor && parent.id !== commonAncestor.id) {\n        edgesToMove.push({\n          edge: edge,\n          currentParent: parent,\n          newParent: commonAncestor\n        });\n      }\n    }\n  }\n  \n  // Second pass: actually move the edges\n  for (const { edge, currentParent, newParent } of edgesToMove) {\n    // Remove from current parent\n    if (currentParent.edges) {\n      currentParent.edges = currentParent.edges.filter(e => e.id !== edge.id);\n    }\n    \n    // Add to new parent\n    if (!newParent.edges) {\n      newParent.edges = [];\n    }\n    newParent.edges.push(edge);\n  }\n  \n  return layout;\n}",
    "start_line": 172,
    "end_line": 208,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function reattachAllEdges",
    "component_id": "client.utils.graph_helper_functions.reattachAllEdges"
  },
  "client.utils.graph_helper_functions.validateGraphStructure": {
    "id": "client.utils.graph_helper_functions.validateGraphStructure",
    "name": "validateGraphStructure",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "scripts.test-vercel-preview.error",
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "function validateGraphStructure(layout: ElkNode): boolean {\n  const visited = new Set<string>();\n  const recursionStack = new Set<string>();\n  \n  function hasCircularReference(node: ElkNode): boolean {\n    if (recursionStack.has(node.id)) {\n      console.error(`‚ùå Circular reference detected: ${node.id}`);\n      return true;\n    }\n    \n    if (visited.has(node.id)) {\n      return false;\n    }\n    \n    visited.add(node.id);\n    recursionStack.add(node.id);\n    \n    if (node.children) {\n      for (const child of node.children) {\n        if (hasCircularReference(child)) {\n          return true;\n        }\n      }\n    }\n    \n    recursionStack.delete(node.id);\n    return false;\n  }\n  \n  return !hasCircularReference(layout);\n}",
    "start_line": 213,
    "end_line": 243,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validateGraphStructure",
    "component_id": "client.utils.graph_helper_functions.validateGraphStructure"
  },
  "client.utils.graph_helper_functions.addNode": {
    "id": "client.utils.graph_helper_functions.addNode",
    "name": "addNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.findNodeById",
      "scripts.test-vercel-preview.error",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.getPathToNode"
    ],
    "source_code": "function addNode(\n  nodename: string, \n  parentId: string, \n  layout: ElkNode, \n  data?: { label?: string; icon?: string; style?: any }\n): ElkNode {\n  const parent = findNodeById(layout, parentId);\n  if (!parent) {\n    const error = `Parent node not found: ${parentId}`;\n    console.error(`‚ùå [ADD-NODE] ${error}`);\n    throw new Error(error);\n  }\n  \n  // Check if node already exists ANYWHERE in the graph\n  const existingNode = findNodeById(layout, nodename);\n  if (existingNode) {\n    const path = getPathToNode(layout, nodename);\n    const error = `Node ${nodename} already exists at: ${path?.map(n => n.id).join(' ‚Üí ') || 'unknown'}`;\n    console.error(`‚ùå [ADD-NODE] ${error}`);\n    throw new Error(error);\n  }\n  \n  // Create new node: using data.label if provided, otherwise nodename\n  const label = data?.label || nodename;\n  // Don't include empty children/edges arrays - only groups have children\n  const newNode: ElkNode = {\n    id: nodename,\n    labels: [{ text: label }],\n  };\n  \n  // Add data properties if provided (for future compatibility)\n  if (data) {\n    (newNode as any).data = data;\n  }\n  \n  if (!parent.children) parent.children = [];\n  parent.children.push(newNode);\n  \n  return layout;\n}",
    "start_line": 257,
    "end_line": 296,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodename",
      "parentId",
      "layout",
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addNode",
    "component_id": "client.utils.graph_helper_functions.addNode"
  },
  "client.utils.graph_helper_functions.deleteNode": {
    "id": "client.utils.graph_helper_functions.deleteNode",
    "name": "deleteNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode",
      "scripts.test-vercel-preview.error",
      "client.utils.graph_helper_functions.findParentOfNode"
    ],
    "source_code": "function deleteNode(nodeId: string, layout: ElkNode): ElkNode {\n  // First, find and remove the node from its parent\n  const parent = findParentOfNode(layout, nodeId);\n  if (!parent || !parent.children) {\n    const error = `Node not found or trying to remove root: ${nodeId}`;\n    console.error(`‚ùå [DELETE-NODE] ${error}`);\n    throw new Error(error);\n  }\n  parent.children = parent.children.filter(child => child.id !== nodeId);\n\n  // Function to remove edges related to the deleted node\n  function removeEdges(node: ElkNode): void {\n    if (node.edges) {\n      node.edges = node.edges.filter(edge => \n        !edge.sources.includes(nodeId) && !edge.targets.includes(nodeId)\n      );\n    }\n    if (node.children) {\n      for (const child of node.children) {\n        removeEdges(child);\n      }\n    }\n  }\n\n  // Remove edges from all levels of the graph\n  removeEdges(layout);\n\n  return layout;\n}",
    "start_line": 302,
    "end_line": 330,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function deleteNode",
    "component_id": "client.utils.graph_helper_functions.deleteNode"
  },
  "client.utils.graph_helper_functions.moveNode": {
    "id": "client.utils.graph_helper_functions.moveNode",
    "name": "moveNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.updateEdgesForNode",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findNodeById",
      "scripts.test-vercel-preview.error",
      "client.utils.graph_helper_functions.findParentOfNode"
    ],
    "source_code": "function moveNode(\n  nodeId: string,\n  newParentId: string,\n  layout: ElkNode\n): ElkNode {\n  const node = findNodeById(layout, nodeId);\n  const newParent = findNodeById(layout, newParentId);\n  if (!node) {\n    const error = `Node not found: ${nodeId}`;\n    console.error(`‚ùå [MOVE-NODE] ${error}`);\n    throw new Error(error);\n  }\n  if (!newParent) {\n    const error = `New parent not found: ${newParentId}`;\n    console.error(`‚ùå [MOVE-NODE] ${error}`);\n    throw new Error(error);\n  }\n  const oldParent = findParentOfNode(layout, nodeId);\n  if (!oldParent || !oldParent.children) {\n    const error = `Node not found in any parent: ${nodeId}`;\n    console.error(`‚ùå [MOVE-NODE] ${error}`);\n    throw new Error(error);\n  }\n  // Remove the node from its old parent\n  oldParent.children = oldParent.children.filter(child => child.id !== nodeId);\n  // Add the node to the new parent\n  if (!newParent.children) newParent.children = [];\n  newParent.children.push(node);\n  layout = updateEdgesForNode(nodeId, layout);\n  return layout;\n}",
    "start_line": 336,
    "end_line": 366,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeId",
      "newParentId",
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function moveNode",
    "component_id": "client.utils.graph_helper_functions.moveNode"
  },
  "client.utils.graph_helper_functions.addEdge": {
    "id": "client.utils.graph_helper_functions.addEdge",
    "name": "addEdge",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkEdge",
      "client.utils.graph_helper_functions.findNodeById",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findCommonAncestor"
    ],
    "source_code": "function addEdge(\n  edgeId: string,\n  sourceId: string,\n  targetId: string,\n  layout: ElkNode,\n  label?: string\n): ElkNode {\n  // Validate that both endpoints exist before attempting LCA\n  const sourceNode = findNodeById(layout, sourceId);\n  const targetNode = findNodeById(layout, targetId);\n  if (!sourceNode && !targetNode) {\n    const error = `Nodes not found: ${sourceId}, ${targetId}`;\n\n    throw new Error(error);\n  }\n  if (!sourceNode) {\n    const error = `Node not found: ${sourceId}`;\n\n    throw new Error(error);\n  }\n  if (!targetNode) {\n    const error = `Node not found: ${targetId}`;\n\n    throw new Error(error);\n  }\n\n  const commonAncestor = findCommonAncestor(layout, sourceId, targetId);\n  if (!commonAncestor) {\n    const error = `Common ancestor not found for nodes: ${sourceId}, ${targetId}`;\n\n    throw new Error(error);\n  }\n  \n  const newEdge: ElkEdge = {\n    id: edgeId,\n    sources: [sourceId],\n    targets: [targetId]\n  };\n  \n  // Add label if provided\n  if (label) {\n    newEdge.labels = [{ text: label }];\n  }\n  \n  if (!commonAncestor.edges) commonAncestor.edges = [];\n  commonAncestor.edges.push(newEdge);\n  \n  return layout;\n}",
    "start_line": 377,
    "end_line": 425,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edgeId",
      "sourceId",
      "targetId",
      "layout",
      "label"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function addEdge",
    "component_id": "client.utils.graph_helper_functions.addEdge"
  },
  "client.utils.graph_helper_functions.deleteEdge": {
    "id": "client.utils.graph_helper_functions.deleteEdge",
    "name": "deleteEdge",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "function deleteEdge(edgeId: string, layout: ElkNode): ElkNode {\n  function removeEdge(node: ElkNode): void {\n    if (node.edges) {\n      node.edges = node.edges.filter(edge => edge.id !== edgeId);\n    }\n    if (node.children) {\n      for (const child of node.children) {\n        removeEdge(child);\n      }\n    }\n  }\n  removeEdge(layout);\n  return layout;\n}",
    "start_line": 431,
    "end_line": 444,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "edgeId",
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function deleteEdge",
    "component_id": "client.utils.graph_helper_functions.deleteEdge"
  },
  "client.utils.graph_helper_functions.groupNodes": {
    "id": "client.utils.graph_helper_functions.groupNodes",
    "name": "groupNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.reattachAllEdges",
      "client.utils.graph_helper_functions.findNodeById",
      "client.utils.graph_helper_functions.getPathToNode",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "function groupNodes(\n  nodeIds: string[],\n  parentId: string,\n  groupId: string,\n  layout: ElkNode,\n  style?: any,\n  groupIconName?: string\n): ElkNode {\n  const parent = findNodeById(layout, parentId);\n  if (!parent) {\n    console.error(`‚ùå [GROUP-NODES] Parent node not found: ${parentId}`);\n    return layout;\n  }\n  \n  // Check if group already exists ANYWHERE in the graph\n  const existingGroup = findNodeById(layout, groupId);\n  if (existingGroup) {\n    const path = getPathToNode(layout, groupId);\n    const error = `Group ${groupId} already exists at: ${path?.map(n => n.id).join(' ‚Üí ') || 'unknown'}`;\n\n    throw new Error(error);\n  }\n  \n  // Create the group node\n  const groupNode: ElkNode = {\n    id: groupId,\n    labels: [{ text: groupId }],\n    children: [],\n    edges: []\n  };\n  \n  // Add style if provided\n  if (style) {\n    (groupNode as any).style = style;\n  }\n  \n  // Add groupIconName if provided\n  if (groupIconName) {\n    (groupNode as any).groupIconName = groupIconName;\n  }\n  \n  // Move nodes to the group\n  const movedNodes: ElkNode[] = [];\n  const failedNodes: string[] = [];\n  \n  if (parent.children) {\n    for (const nodeId of nodeIds) {\n      const nodeIndex = parent.children.findIndex(child => child.id === nodeId);\n      if (nodeIndex >= 0) {\n        const [node] = parent.children.splice(nodeIndex, 1);\n        movedNodes.push(node);\n      } else {\n  \n        failedNodes.push(nodeId);\n      }\n    }\n  }\n  \n  // If some nodes failed to move, provide detailed feedback\n  if (failedNodes.length > 0) {\n    const availableNodes = parent.children?.map(c => c.id).join(', ') || 'none';\n    const error = `FAILED to move ${failedNodes.length} nodes: ${failedNodes.join(', ')}. Available nodes in parent ${parentId}: ${availableNodes}`;\n\n    \n    // If no nodes were moved, this is a complete failure\n    if (movedNodes.length === 0) {\n      throw new Error(`No nodes could be moved to group ${groupId}. ${error}`);\n    } else {\n      // Partial failure - still throw error but mention what succeeded\n      throw new Error(`Partial failure: ${error}. Successfully moved: ${movedNodes.map(n => n.id).join(', ')}`);\n    }\n  }\n  \n  // Add moved nodes to the group\n  groupNode.children = movedNodes;\n  \n  // Add the group to the parent\n  if (!parent.children) parent.children = [];\n  parent.children.push(groupNode);\n  \n  // Log edge distribution before reattachment\n  const edgesBefore = collectEdges(layout);\n  for (const { parent: container, edgeArr } of edgesBefore) {\n    if (edgeArr.length > 0) {\n\n    }\n  }\n  \n  // Perform comprehensive edge reattachment for ALL edges\n  layout = reattachAllEdges(layout);\n  \n  // Log edge distribution after reattachment\n  const edgesAfter = collectEdges(layout);\n  for (const { parent: container, edgeArr } of edgesAfter) {\n    if (edgeArr.length > 0) {\n\n    }\n  }\n  \n  return layout;\n}",
    "start_line": 456,
    "end_line": 556,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "nodeIds",
      "parentId",
      "groupId",
      "layout",
      "style",
      "groupIconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function groupNodes",
    "component_id": "client.utils.graph_helper_functions.groupNodes"
  },
  "client.utils.graph_helper_functions.removeGroup": {
    "id": "client.utils.graph_helper_functions.removeGroup",
    "name": "removeGroup",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.reattachAllEdges",
      "client.utils.graph_helper_functions.findNodeById",
      "scripts.test-vercel-preview.error",
      "client.utils.graph_helper_functions.findParentOfNode"
    ],
    "source_code": "function removeGroup(groupId: string, layout: ElkNode): ElkNode {\n  const groupNode = findNodeById(layout, groupId);\n  if (!groupNode) {\n    const error = `Group not found: ${groupId}`;\n    console.error(`‚ùå [REMOVE-GROUP] ${error}`);\n    throw new Error(error);\n  }\n  const parent = findParentOfNode(layout, groupId);\n  if (!parent || !parent.children) {\n    const error = `The group node does not have a parent (maybe it is the root): ${groupId}`;\n    console.error(`‚ùå [REMOVE-GROUP] ${error}`);\n    throw new Error(error);\n  }\n  \n  if (groupNode.children) {\n    for (const child of groupNode.children) {\n      parent.children.push(child);\n    }\n  }\n  \n  // Remove the group node\n  parent.children = parent.children.filter(child => child.id !== groupId);\n  \n  // Perform comprehensive edge reattachment since ungrouping can affect edge placement\n  layout = reattachAllEdges(layout);\n  \n  return layout;\n}",
    "start_line": 562,
    "end_line": 589,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "groupId",
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function removeGroup",
    "component_id": "client.utils.graph_helper_functions.removeGroup"
  },
  "client.utils.graph_helper_functions.batchUpdate": {
    "id": "client.utils.graph_helper_functions.batchUpdate",
    "name": "batchUpdate",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.moveNode",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.addEdge",
      "client.utils.graph_helper_functions.groupNodes",
      "client.utils.graph_helper_functions.addNode",
      "client.utils.graph_helper_functions.removeGroup",
      "client.utils.graph_helper_functions.deleteEdge",
      "client.utils.graph_helper_functions.deleteNode"
    ],
    "source_code": "function batchUpdate(\n  operations: Array<{name: string, [key: string]: any}>,\n  layout: ElkNode\n): ElkNode {\n  const results = [];\n  const errors = [];\n  \n  \n  \n  for (let i = 0; i < operations.length; i++) {\n    const operation = operations[i];\n    \n    try {\n      switch (operation.name) {\n        case 'add_node':\n          addNode(\n            operation.nodename,\n            operation.parentId,\n            layout,\n            operation.data\n          );\n          break;\n          \n        case 'delete_node':\n          deleteNode(operation.nodeId, layout);\n          break;\n          \n        case 'move_node':\n          moveNode(operation.nodeId, operation.newParentId, layout);\n          break;\n          \n        case 'add_edge':\n          addEdge(\n            operation.edgeId,\n            operation.sourceId,\n            operation.targetId,\n            layout,\n            operation.label\n          );\n          break;\n          \n        case 'delete_edge':\n          deleteEdge(operation.edgeId, layout);\n          break;\n          \n        case 'group_nodes':\n          groupNodes(\n            operation.nodeIds,\n            operation.parentId,\n            operation.groupId,\n            layout,\n            operation.groupIconName\n          );\n          break;\n          \n        case 'remove_group':\n          removeGroup(operation.groupId, layout);\n          break;\n          \n        default:\n          const error = `Unknown operation: ${(operation as any).name}`;\n\n          errors.push(`Operation ${i + 1}/${operations.length}: ${error}`);\n          continue;\n      }\n      \n      // Operation succeeded\n      results.push(`‚úÖ Operation ${i + 1}/${operations.length} (${operation.name}) succeeded`);\n\n      \n    } catch (error) {\n      const errorMsg = `Operation ${i + 1}/${operations.length} (${operation.name}) failed: ${error instanceof Error ? error.message : String(error)}`;\n\n\n      errors.push(errorMsg);\n      \n      // Continue with next operation instead of stopping\n      continue;\n    }\n  }\n  \n  // Log summary\n\n  \n  if (errors.length > 0) {\n    console.warn(`‚ö†Ô∏è Some operations failed:`, errors);\n    // Don't throw error, just log the issues\n  }\n  \n  return layout;\n}",
    "start_line": 596,
    "end_line": 686,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operations",
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function batchUpdate",
    "component_id": "client.utils.graph_helper_functions.batchUpdate"
  },
  "client.utils.graph_helper_functions.analyzeGraphState": {
    "id": "client.utils.graph_helper_functions.analyzeGraphState",
    "name": "analyzeGraphState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findCommonAncestor"
    ],
    "source_code": "function analyzeGraphState(layout: ElkNode): void {\n  const allEdges = collectEdges(layout);\n  const edgeDistribution: { [containerId: string]: number } = {};\n  const potentialMisalignments: string[] = [];\n  \n  // Count edges per container\n  for (const { edgeArr, parent } of allEdges) {\n    edgeDistribution[parent.id] = edgeArr.length;\n    \n    // Check each edge for potential misalignment\n    for (const edge of edgeArr) {\n      const sourceId = edge.sources[0];\n      const targetId = edge.targets[0];\n      const correctAncestor = findCommonAncestor(layout, sourceId, targetId);\n      \n      if (correctAncestor && parent.id !== correctAncestor.id) {\n        potentialMisalignments.push(\n          `Edge ${edge.id} (${sourceId} -> ${targetId}) is at ${parent.id} but should be at ${correctAncestor.id}`\n        );\n      }\n    }\n  }\n  \n  if (potentialMisalignments.length > 0) {\n    console.log(`‚ö†Ô∏è [POTENTIAL-MISALIGNMENTS] Found ${potentialMisalignments.length} potential issues:`);\n    potentialMisalignments.forEach(issue => console.log(`  - ${issue}`));\n  } else {\n    console.log(`‚úÖ [EDGE-ALIGNMENT] All edges appear to be correctly aligned`);\n  }\n}",
    "start_line": 695,
    "end_line": 724,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function analyzeGraphState",
    "component_id": "client.utils.graph_helper_functions.analyzeGraphState"
  },
  "client.utils.graph_helper_functions.forceEdgeReattachmentAnalysis": {
    "id": "client.utils.graph_helper_functions.forceEdgeReattachmentAnalysis",
    "name": "forceEdgeReattachmentAnalysis",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.ElkEdge",
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findCommonAncestor"
    ],
    "source_code": "function forceEdgeReattachmentAnalysis(layout: ElkNode): ElkNode {\n  const allEdges = collectEdges(layout);\n  const edgesToMove: { edge: ElkEdge; currentParent: ElkNode; newParent: ElkNode }[] = [];\n  \n  // Check all edges in the graph\n  for (const { edgeArr, parent } of allEdges) {\n    for (const edge of edgeArr) {\n      const sourceId = edge.sources[0];\n      const targetId = edge.targets[0];\n      \n      const commonAncestor = findCommonAncestor(layout, sourceId, targetId);\n      if (commonAncestor && parent.id !== commonAncestor.id) {\n        edgesToMove.push({\n          edge: edge,\n          currentParent: parent,\n          newParent: commonAncestor\n        });\n      }\n    }\n  }\n  \n  // Actually move the edges if any need moving\n  for (const { edge, currentParent, newParent } of edgesToMove) {\n    // Remove from current parent\n    if (currentParent.edges) {\n      currentParent.edges = currentParent.edges.filter(e => e.id !== edge.id);\n    }\n    \n    // Add to new parent\n    if (!newParent.edges) {\n      newParent.edges = [];\n    }\n    newParent.edges.push(edge);\n  }\n  \n  return layout;\n}",
    "start_line": 729,
    "end_line": 765,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function forceEdgeReattachmentAnalysis",
    "component_id": "client.utils.graph_helper_functions.forceEdgeReattachmentAnalysis"
  },
  "client.utils.graph_helper_functions.showGraphStructure": {
    "id": "client.utils.graph_helper_functions.showGraphStructure",
    "name": "showGraphStructure",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "function showGraphStructure(layout: ElkNode): void {\n  // Function to show hierarchy\n  function showHierarchy(node: ElkNode, indent = 0) {\n    const spacing = '  '.repeat(indent);\n    const edgeCount = node.edges?.length || 0;\n    const childCount = node.children?.length || 0;\n    \n    console.log(`${spacing}üìÅ ${node.id} (${childCount} children, ${edgeCount} edges)`);\n    \n    // Show edges at this level\n    if (node.edges && node.edges.length > 0) {\n      for (const edge of node.edges) {\n        console.log(`${spacing}  üîó ${edge.id}: ${edge.sources[0]} -> ${edge.targets[0]}`);\n      }\n    }\n    \n    // Show children\n    if (node.children && node.children.length > 0) {\n      for (const child of node.children) {\n        showHierarchy(child, indent + 1);\n      }\n    }\n  }\n  \n  showHierarchy(layout);\n  \n  // Show edge distribution summary\n  const allEdges = collectEdges(layout);\n  let totalEdges = 0;\n  for (const { parent, edgeArr } of allEdges) {\n    if (edgeArr.length > 0) {\n      totalEdges += edgeArr.length;\n      console.log(`  üìç ${parent.id}: ${edgeArr.length} edges`);\n    }\n  }\n  console.log(`  üî¢ Total edges: ${totalEdges}`);\n}",
    "start_line": 770,
    "end_line": 806,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function showGraphStructure",
    "component_id": "client.utils.graph_helper_functions.showGraphStructure"
  },
  "client.utils.graph_helper_functions.validateBatchOperations": {
    "id": "client.utils.graph_helper_functions.validateBatchOperations",
    "name": "validateBatchOperations",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [],
    "source_code": "function validateBatchOperations(operations: Array<{name: string, [key: string]: any}>): string[] {\n  const warnings: string[] = [];\n  \n  // Count grouping operations that could affect edge placement\n  const groupingOps = operations.filter(op => op.name === 'group_nodes').length;\n  const edgeOps = operations.filter(op => op.name === 'add_edge').length;\n  \n  if (groupingOps > 0 && edgeOps > 0) {\n    warnings.push(\n      `‚ÑπÔ∏è EDGE REATTACHMENT REQUIRED: This operation sequence includes ${groupingOps} grouping operations ` +\n      `and ${edgeOps} edge creation operations. Ensure edge reattachment is working properly during grouping.`\n    );\n  }\n  \n  return warnings;\n}",
    "start_line": 811,
    "end_line": 826,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "operations"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validateBatchOperations",
    "component_id": "client.utils.graph_helper_functions.validateBatchOperations"
  },
  "client.utils.graph_helper_functions.validateGraphState": {
    "id": "client.utils.graph_helper_functions.validateGraphState",
    "name": "validateGraphState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.utils.graph_helper_functions.collectEdges",
      "client.utils.graph_helper_functions.ElkNode",
      "client.utils.graph_helper_functions.findCommonAncestor"
    ],
    "source_code": "function validateGraphState(layout: ElkNode): string[] {\n  const issues: string[] = [];\n  const allEdges = collectEdges(layout);\n  \n  // Count edges at root level\n  const rootEdges = allEdges.find(({ parent }) => parent.id === 'root')?.edgeArr || [];\n  const totalEdges = allEdges.reduce((sum, { edgeArr }) => sum + edgeArr.length, 0);\n  \n  // If more than 50% of edges are at root, likely reattachment failure\n  if (rootEdges.length > totalEdges * 0.5 && totalEdges > 5) {\n    issues.push(\n      `üö® SUSPECTED EDGE REATTACHMENT FAILURE: ${rootEdges.length}/${totalEdges} edges are at root level. ` +\n      `This suggests automatic edge reattachment during grouping operations may have failed. ` +\n      `Run forceEdgeReattachmentAnalysis() to fix.`\n    );\n  }\n  \n  // Check for specific misalignment patterns\n  for (const { parent, edgeArr } of allEdges) {\n    if (parent.id === 'root' && edgeArr.length > 0) {\n      for (const edge of edgeArr) {\n        const correctAncestor = findCommonAncestor(layout, edge.sources[0], edge.targets[0]);\n        if (correctAncestor && correctAncestor.id !== 'root') {\n          issues.push(\n            `‚ö†Ô∏è MISALIGNED EDGE: Edge ${edge.id} (${edge.sources[0]} -> ${edge.targets[0]}) ` +\n            `is at root but should be at ${correctAncestor.id}`\n          );\n        }\n      }\n    }\n  }\n  \n  return issues;\n}",
    "start_line": 831,
    "end_line": 864,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validateGraphState",
    "component_id": "client.utils.graph_helper_functions.validateGraphState"
  },
  "client.utils.graph_helper_functions.diagnoseStateSynchronization": {
    "id": "client.utils.graph_helper_functions.diagnoseStateSynchronization",
    "name": "diagnoseStateSynchronization",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.utils.graph_helper_functions.showGraphStructure"
    ],
    "source_code": "function diagnoseStateSynchronization(): void {\n  console.log(`üîç [STATE-SYNC-DIAGNOSIS] Analyzing graph state synchronization issues`);\n  \n  // Check different potential graph state sources\n  const sources = [\n    { name: 'window.currentElkGraph', value: (window as any).currentElkGraph },\n    { name: 'window.elkGraphForDiagnostics', value: (window as any).elkGraphForDiagnostics },\n    { name: 'window.getCurrentGraph()', value: (window as any).getCurrentGraph?.() }\n  ];\n  \n  console.log(`üìä [STATE-SYNC] Found ${sources.length} potential graph state sources:`);\n  \n  sources.forEach((source, index) => {\n    if (source.value) {\n      const nodeCount = source.value.children?.length || 0;\n      const edgeCount = source.value.edges?.length || 0;\n      const nodeIds = source.value.children?.map((n: any) => n.id) || [];\n      \n      console.log(`  ${index + 1}. ${source.name}:`);\n      console.log(`     üìç Node count: ${nodeCount}`);\n      console.log(`     üîó Edge count: ${edgeCount}`);\n      console.log(`     üìù Node IDs: [${nodeIds.join(', ')}]`);\n      \n      if (nodeCount > 0) {\n        console.log(`     üèóÔ∏è Graph structure:`);\n        showGraphStructure(source.value);\n      }\n    } else {\n      console.log(`  ${index + 1}. ${source.name}: ‚ùå NOT AVAILABLE`);\n    }\n  });\n  \n  // Check for mismatches\n  const availableSources = sources.filter(s => s.value);\n  if (availableSources.length > 1) {\n    console.log(`‚ö†Ô∏è [STATE-SYNC] MULTIPLE GRAPH STATES DETECTED - POTENTIAL RACE CONDITION!`);\n    \n    const referenceCounts = availableSources.map(s => ({\n      name: s.name,\n      nodes: s.value.children?.length || 0,\n      edges: s.value.edges?.length || 0\n    }));\n    \n    const nodeCountsMatch = referenceCounts.every(rc => rc.nodes === referenceCounts[0].nodes);\n    const edgeCountsMatch = referenceCounts.every(rc => rc.edges === referenceCounts[0].edges);\n    \n    if (!nodeCountsMatch || !edgeCountsMatch) {\n      console.error(`‚ùå [STATE-SYNC] STATE MISMATCH DETECTED:`);\n      referenceCounts.forEach(rc => {\n        console.error(`  - ${rc.name}: ${rc.nodes} nodes, ${rc.edges} edges`);\n      });\n    } else {\n      console.log(`‚úÖ [STATE-SYNC] All available sources have consistent counts`);\n    }\n  }\n}",
    "start_line": 869,
    "end_line": 924,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function diagnoseStateSynchronization",
    "component_id": "client.utils.graph_helper_functions.diagnoseStateSynchronization"
  },
  "client.utils.graph_helper_functions.cleanupDuplicateGroups": {
    "id": "client.utils.graph_helper_functions.cleanupDuplicateGroups",
    "name": "cleanupDuplicateGroups",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/graph_helper_functions.ts",
    "relative_path": "client/utils/graph_helper_functions.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.graph_helper_functions.ElkNode"
    ],
    "source_code": "function cleanupDuplicateGroups(layout: ElkNode): ElkNode {\n  const seenGroupIds = new Set<string>();\n  const duplicatesToRemove: { parent: ElkNode, childIndex: number }[] = [];\n  \n  // Recursive function to find duplicates\n  function findDuplicates(node: ElkNode, parent: ElkNode | null = null, childIndex: number = -1) {\n    if (parent && childIndex >= 0) {\n      if (seenGroupIds.has(node.id)) {\n        console.warn(`üîç [CLEANUP-DUPLICATES] Found duplicate: ${node.id} at ${parent.id}[${childIndex}]`);\n        duplicatesToRemove.push({ parent, childIndex });\n        return; // Don't process children of duplicates\n      } else {\n        seenGroupIds.add(node.id);\n      }\n    }\n    \n    if (node.children) {\n      // Process children (iterate backwards since we might remove some)\n      for (let i = node.children.length - 1; i >= 0; i--) {\n        findDuplicates(node.children[i], node, i);\n      }\n    }\n  }\n  \n  // Start the search\n  findDuplicates(layout);\n  \n  // Remove duplicates\n  for (const { parent, childIndex } of duplicatesToRemove) {\n    if (parent.children && childIndex < parent.children.length) {\n      const removed = parent.children.splice(childIndex, 1)[0];\n    }\n  }\n  \n  return layout;\n}",
    "start_line": 929,
    "end_line": 964,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cleanupDuplicateGroups",
    "component_id": "client.utils.graph_helper_functions.cleanupDuplicateGroups"
  },
  "client.utils.iconCacheService.IconCacheEntry": {
    "id": "client.utils.iconCacheService.IconCacheEntry",
    "name": "IconCacheEntry",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "interface IconCacheEntry {\n  url: string;\n  timestamp: number;\n}",
    "start_line": 5,
    "end_line": 8,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface IconCacheEntry",
    "component_id": "client.utils.iconCacheService.IconCacheEntry"
  },
  "client.utils.iconCacheService.IconCacheService": {
    "id": "client.utils.iconCacheService.IconCacheService",
    "name": "IconCacheService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [
      "client.utils.iconCacheService.IconCacheEntry",
      "scripts.test-vercel-preview.success",
      "scripts.test-vercel-preview.log",
      "client.utils.iconCacheService.cacheIcon",
      "client.utils.iconCacheService.isIconCached",
      "client.utils.iconCacheService.getCachedIcon",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "class IconCacheService {\n  private cache: Map<string, IconCacheEntry> = new Map();\n  private readonly CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\n  /**\n   * Get cached icon URL if available and not expired\n   */\n  getCachedIcon(iconName: string): string | null {\n    const entry = this.cache.get(iconName);\n    \n    if (!entry) {\n      return null;\n    }\n\n    // Check if cache entry is expired\n    const now = Date.now();\n    if (now - entry.timestamp > this.CACHE_DURATION) {\n      this.cache.delete(iconName);\n      return null;\n    }\n\n    return entry.url;\n  }\n\n  /**\n   * Cache a successfully loaded icon\n   */\n  cacheIcon(iconName: string, url: string): void {\n    this.cache.set(iconName, {\n      url,\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Check if icon is cached (without returning the URL)\n   */\n  isIconCached(iconName: string): boolean {\n    return this.getCachedIcon(iconName) !== null;\n  }\n\n  /**\n   * Clear expired cache entries\n   */\n  clearExpiredEntries(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > this.CACHE_DURATION) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): { size: number; entries: string[] } {\n    return {\n      size: this.cache.size,\n      entries: Array.from(this.cache.keys())\n    };\n  }\n\n  /**\n   * Preload icons into cache (useful for warming up cache)\n   */\n  async preloadIcons(iconNames: string[], tryLoadIconFn: (iconName: string) => Promise<string>): Promise<void> {\n    const uncachedIcons = iconNames.filter(name => !this.isIconCached(name));\n    \n    if (uncachedIcons.length === 0) {\n      console.log('üéØ All icons already cached, skipping preload');\n      return;\n    }\n\n    console.log(`üîÑ Preloading ${uncachedIcons.length} icons into cache...`);\n    \n    const loadPromises = uncachedIcons.map(async (iconName) => {\n      try {\n        const url = await tryLoadIconFn(iconName);\n        this.cacheIcon(iconName, url);\n        return { iconName, success: true };\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Failed to preload icon: ${iconName}`, error);\n        return { iconName, success: false };\n      }\n    });\n\n    const results = await Promise.allSettled(loadPromises);\n    const successful = results.filter(r => r.status === 'fulfilled' && r.value.success).length;\n    \n    console.log(`‚úÖ Preloaded ${successful}/${uncachedIcons.length} icons into cache`);\n  }\n}",
    "start_line": 10,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class IconCacheService",
    "component_id": "client.utils.iconCacheService.IconCacheService"
  },
  "client.utils.iconCacheService.getCachedIcon": {
    "id": "client.utils.iconCacheService.getCachedIcon",
    "name": "getCachedIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "getCachedIcon(iconName: string): string | null {\n    const entry = this.cache.get(iconName);\n    \n    if (!entry) {\n      return null;\n    }\n\n    // Check if cache entry is expired\n    const now = Date.now();\n    if (now - entry.timestamp > this.CACHE_DURATION) {\n      this.cache.delete(iconName);\n      return null;\n    }\n\n    return entry.url;\n  }",
    "start_line": 17,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getCachedIcon",
    "component_id": "client.utils.iconCacheService.getCachedIcon"
  },
  "client.utils.iconCacheService.cacheIcon": {
    "id": "client.utils.iconCacheService.cacheIcon",
    "name": "cacheIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "cacheIcon(iconName: string, url: string): void {\n    this.cache.set(iconName, {\n      url,\n      timestamp: Date.now()\n    });\n  }",
    "start_line": 37,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName",
      "url"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method cacheIcon",
    "component_id": "client.utils.iconCacheService.cacheIcon"
  },
  "client.utils.iconCacheService.isIconCached": {
    "id": "client.utils.iconCacheService.isIconCached",
    "name": "isIconCached",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "isIconCached(iconName: string): boolean {\n    return this.getCachedIcon(iconName) !== null;\n  }",
    "start_line": 47,
    "end_line": 49,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method isIconCached",
    "component_id": "client.utils.iconCacheService.isIconCached"
  },
  "client.utils.iconCacheService.clearExpiredEntries": {
    "id": "client.utils.iconCacheService.clearExpiredEntries",
    "name": "clearExpiredEntries",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "clearExpiredEntries(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > this.CACHE_DURATION) {\n        this.cache.delete(key);\n      }\n    }\n  }",
    "start_line": 54,
    "end_line": 61,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clearExpiredEntries",
    "component_id": "client.utils.iconCacheService.clearExpiredEntries"
  },
  "client.utils.iconCacheService.clearCache": {
    "id": "client.utils.iconCacheService.clearCache",
    "name": "clearCache",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "clearCache(): void {\n    this.cache.clear();\n  }",
    "start_line": 66,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method clearCache",
    "component_id": "client.utils.iconCacheService.clearCache"
  },
  "client.utils.iconCacheService.getCacheStats": {
    "id": "client.utils.iconCacheService.getCacheStats",
    "name": "getCacheStats",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "getCacheStats(): { size: number; entries: string[] } {\n    return {\n      size: this.cache.size,\n      entries: Array.from(this.cache.keys())\n    };\n  }",
    "start_line": 73,
    "end_line": 78,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method getCacheStats",
    "component_id": "client.utils.iconCacheService.getCacheStats"
  },
  "client.utils.iconCacheService.preloadIcons": {
    "id": "client.utils.iconCacheService.preloadIcons",
    "name": "preloadIcons",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconCacheService.ts",
    "relative_path": "client/utils/iconCacheService.ts",
    "depends_on": [],
    "source_code": "async preloadIcons(iconNames: string[], tryLoadIconFn: (iconName: string) => Promise<string>): Promise<void> {\n    const uncachedIcons = iconNames.filter(name => !this.isIconCached(name));\n    \n    if (uncachedIcons.length === 0) {\n      console.log('üéØ All icons already cached, skipping preload');\n      return;\n    }\n\n    console.log(`üîÑ Preloading ${uncachedIcons.length} icons into cache...`);\n    \n    const loadPromises = uncachedIcons.map(async (iconName) => {\n      try {\n        const url = await tryLoadIconFn(iconName);\n        this.cacheIcon(iconName, url);\n        return { iconName, success: true };\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è Failed to preload icon: ${iconName}`, error);\n        return { iconName, success: false };\n      }\n    });\n\n    const results = await Promise.allSettled(loadPromises);\n    const successful = results.filter(r => r.status === 'fulfilled' && r.value.success).length;\n    \n    console.log(`‚úÖ Preloaded ${successful}/${uncachedIcons.length} icons into cache`);\n  }",
    "start_line": 83,
    "end_line": 108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconNames",
      "tryLoadIconFn"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method preloadIcons",
    "component_id": "client.utils.iconCacheService.preloadIcons"
  },
  "client.utils.iconFallbackService.PrecomputedData": {
    "id": "client.utils.iconFallbackService.PrecomputedData",
    "name": "PrecomputedData",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [],
    "source_code": "interface PrecomputedData {\n  embeddings: { [iconName: string]: number[] };\n  similarities: { [provider: string]: { [iconName: string]: { [otherIcon: string]: number } } };\n}",
    "start_line": 3,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface PrecomputedData",
    "component_id": "client.utils.iconFallbackService.PrecomputedData"
  },
  "client.utils.iconFallbackService.IconFallbackService": {
    "id": "client.utils.iconFallbackService.IconFallbackService",
    "name": "IconFallbackService",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [
      "client.utils.iconFallbackService.cosineSimilarity",
      "scripts.test-vercel-preview.log",
      "client.utils.iconFallbackService.findNextBestMatch",
      "client.utils.iconFallbackService.verifyIconExists",
      "client.utils.iconFallbackService.PrecomputedData",
      "client.utils.iconFallbackService.getEmbedding",
      "client.utils.iconFallbackService.loadPrecomputedData",
      "scripts.precompute-icon-embeddings.cosineSimilarity"
    ],
    "source_code": "class IconFallbackService {\n  private fallbackCache: { [key: string]: string } = {};\n  private embeddingCache: { [key: string]: number[] } = {};\n  private precomputedData: PrecomputedData | null = null;\n\n  constructor() {\n    if (typeof window === 'undefined') {\n      return;\n    }\n    \n    this.loadPrecomputedData();\n  }\n\n  private async loadPrecomputedData() {\n    try {\n      const response = await fetch('/precomputed-icon-embeddings.json');\n      if (!response.ok) {\n        throw new Error(`Failed to load precomputed data: ${response.status}`);\n      }\n      this.precomputedData = await response.json();\n    } catch (error) {\n      this.precomputedData = null;\n    }\n  }\n\n  private async getEmbedding(text: string): Promise<number[] | null> {\n    const cacheKey = `embedding_${text.toLowerCase()}`;\n    if (this.embeddingCache[cacheKey]) {\n      return this.embeddingCache[cacheKey];\n    }\n\n    try {\n      const response = await fetch('/api/embed', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ text })\n      });\n\n      if (!response.ok) {\n        throw new Error(`Embedding API failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n      const embedding = data.embedding;\n      this.embeddingCache[cacheKey] = embedding;\n      return embedding;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  private cosineSimilarity(a: number[], b: number[]): number {\n    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n    return dotProduct / (magnitudeA * magnitudeB);\n  }\n\n  public async findFallbackIcon(missingIconName: string): Promise<string | null> {\n    if (typeof window === 'undefined') {\n      return null;\n    }\n\n    // Check cache first\n    if (this.fallbackCache[missingIconName]) {\n      return this.fallbackCache[missingIconName];\n    }\n\n    // Wait for precomputed data if not loaded yet\n    if (!this.precomputedData) {\n      await this.loadPrecomputedData();\n    }\n\n    if (!this.precomputedData) {\n      return null;\n    }\n\n    try {\n      // Searching fallback silently\n      \n      // Handle both prefixed (gcp_compute) and non-prefixed (server) icon names\n      let provider: string;\n      let searchTerm: string;\n      \n      const prefixMatch = missingIconName.match(/^(aws|gcp|azure)_(.+)$/);\n      if (prefixMatch) {\n        [, provider, searchTerm] = prefixMatch;\n        // Prefixed name detected\n      } else {\n        // For non-prefixed names, search across all providers to find the best semantic match\n        provider = 'gcp'; // Default to GCP for result formatting, but we'll search all\n        searchTerm = missingIconName;\n        // Non-prefixed name detected\n      }\n\n      // Get embedding for search term (only 1 API call)\n      const searchEmbedding = await this.getEmbedding(searchTerm.replace(/_/g, ' '));\n      if (!searchEmbedding) {\n        console.log(`‚ùå IconFallback: Could not get embedding for \"${searchTerm}\"`);\n        return null;\n      }\n\n      // For non-prefixed names, prioritize general icons first, then cloud provider icons\n      let globalBestMatch: { icon: string; similarity: number; provider: string } | null = null;\n      let searchProviders: string[] = [];\n      \n      if (prefixMatch) {\n        // Prefixed names: search only the specified provider\n        searchProviders = [provider];\n      } else {\n        // Non-prefixed names: first search general icons, then cloud providers\n        // Search through all embeddings to find general icons (no provider prefix)\n        for (const [iconName, iconEmbedding] of Object.entries(this.precomputedData.embeddings)) {\n          // General icons don't have provider prefixes (aws_, gcp_, azure_)\n          if (!iconName.match(/^(aws|gcp|azure)_/)) {\n            const similarity = this.cosineSimilarity(searchEmbedding, iconEmbedding);\n            if (!globalBestMatch || similarity > globalBestMatch.similarity) {\n              globalBestMatch = { icon: iconName, similarity, provider: 'general' };\n            }\n          }\n        }\n        \n        // Also search cloud providers to find the absolute best match across all icons\n        searchProviders = ['gcp', 'aws', 'azure'];\n      }\n\n      // Search cloud provider icons to find absolute best match across all providers\n      if (searchProviders.length > 0) {\n        for (const currentProvider of searchProviders) {\n          const providerIcons = iconLists[currentProvider as keyof typeof iconLists];\n          if (!providerIcons) {\n            continue;\n          }\n\n          const availableIcons = Object.values(providerIcons).flat();\n          if (availableIcons.length === 0) {\n            continue;\n          }\n\n          // Compare against precomputed icon embeddings (no API calls)\n          for (const icon of availableIcons) {\n            const iconEmbedding = this.precomputedData.embeddings[icon];\n            if (iconEmbedding) {\n              const similarity = this.cosineSimilarity(searchEmbedding, iconEmbedding);\n              if (!globalBestMatch || similarity > globalBestMatch.similarity) {\n                globalBestMatch = { icon, similarity, provider: currentProvider };\n              }\n            }\n          }\n        }\n      }\n\n      if (globalBestMatch) { // Always use best match, no matter how low similarity\n        // For general icons, don't add provider prefix\n        const fallbackIcon = globalBestMatch.provider === 'general' \n          ? globalBestMatch.icon \n          : `${globalBestMatch.provider}_${globalBestMatch.icon}`;\n        \n        // CRITICAL: Verify the fallback icon actually exists as a file\n        const iconExists = await this.verifyIconExists(fallbackIcon);\n        if (!iconExists) {\n          // Try to find the next best match that actually exists\n          return await this.findNextBestMatch(missingIconName, searchEmbedding, globalBestMatch);\n        }\n        \n        // Found valid fallback\n        this.fallbackCache[missingIconName] = fallbackIcon;\n        return fallbackIcon;\n      } else {\n        return null;\n      }\n\n    } catch (error) {\n      return null;\n    }\n  }\n\n  private async verifyIconExists(iconName: string): Promise<boolean> {\n    try {\n      // Check if it's a general icon (no provider prefix)\n      if (!iconName.includes('_') || (!iconName.startsWith('aws_') && !iconName.startsWith('gcp_') && !iconName.startsWith('azure_'))) {\n        // Try both PNG and SVG for general icons\n        const pngPath = `/assets/canvas/${iconName}.png`;\n        const svgPath = `/assets/canvas/${iconName}.svg`;\n        \n        const pngResponse = await fetch(pngPath, { method: 'HEAD' });\n        const svgResponse = await fetch(svgPath, { method: 'HEAD' });\n        \n        return pngResponse.ok || svgResponse.ok;\n      } else {\n        // Provider-specific icon\n        const [provider, actualIconName] = iconName.split('_', 2);\n        const iconPath = `/icons/${provider}/${actualIconName}.png`;\n        const response = await fetch(iconPath, { method: 'HEAD' });\n        return response.ok;\n      }\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private async findNextBestMatch(\n    missingIconName: string, \n    searchEmbedding: number[], \n    excludeMatch: { icon: string; provider: string; similarity: number }\n  ): Promise<string | null> {\n    let nextBestMatch: { icon: string; similarity: number; provider: string } | null = null;\n\n    // Search through all embeddings again, excluding the already found match\n    for (const [iconName, iconEmbedding] of Object.entries(this.precomputedData!.embeddings)) {\n      // Skip the already found match\n      if (iconName === excludeMatch.icon) continue;\n      \n      const similarity = this.cosineSimilarity(searchEmbedding, iconEmbedding);\n      \n      if (!nextBestMatch || similarity > nextBestMatch.similarity) {\n        const isGeneralIcon = !iconName.match(/^(aws|gcp|azure)_/);\n        \n        nextBestMatch = {\n          icon: iconName,\n          similarity,\n          provider: isGeneralIcon ? 'general' : iconName.split('_')[0]\n        };\n      }\n    }\n\n    if (nextBestMatch) {\n      const fallbackIcon = nextBestMatch.provider === 'general' \n        ? nextBestMatch.icon \n        : `${nextBestMatch.provider}_${nextBestMatch.icon}`;\n      \n      const iconExists = await this.verifyIconExists(fallbackIcon);\n      if (iconExists) {\n        this.fallbackCache[missingIconName] = fallbackIcon;\n        console.log(`‚úÖ IconFallback: Found alternative fallback \"${missingIconName}\" ‚Üí \"${fallbackIcon}\"`);\n        return fallbackIcon;\n      }\n    }\n\n    console.log(`‚ùå IconFallback: No valid fallback icons found for \"${missingIconName}\"`);\n    return null;\n  }\n}",
    "start_line": 8,
    "end_line": 250,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "class",
    "base_classes": [],
    "class_name": null,
    "display_name": "class IconFallbackService",
    "component_id": "client.utils.iconFallbackService.IconFallbackService"
  },
  "client.utils.iconFallbackService.loadPrecomputedData": {
    "id": "client.utils.iconFallbackService.loadPrecomputedData",
    "name": "loadPrecomputedData",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [],
    "source_code": "private async loadPrecomputedData() {\n    try {\n      const response = await fetch('/precomputed-icon-embeddings.json');\n      if (!response.ok) {\n        throw new Error(`Failed to load precomputed data: ${response.status}`);\n      }\n      this.precomputedData = await response.json();\n    } catch (error) {\n      this.precomputedData = null;\n    }\n  }",
    "start_line": 21,
    "end_line": 31,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method loadPrecomputedData",
    "component_id": "client.utils.iconFallbackService.loadPrecomputedData"
  },
  "client.utils.iconFallbackService.getEmbedding": {
    "id": "client.utils.iconFallbackService.getEmbedding",
    "name": "getEmbedding",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [],
    "source_code": "private async getEmbedding(text: string): Promise<number[] | null> {\n    const cacheKey = `embedding_${text.toLowerCase()}`;\n    if (this.embeddingCache[cacheKey]) {\n      return this.embeddingCache[cacheKey];\n    }\n\n    try {\n      const response = await fetch('/api/embed', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ text })\n      });\n\n      if (!response.ok) {\n        throw new Error(`Embedding API failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n      const embedding = data.embedding;\n      this.embeddingCache[cacheKey] = embedding;\n      return embedding;\n    } catch (error) {\n      return null;\n    }\n  }",
    "start_line": 33,
    "end_line": 57,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method getEmbedding",
    "component_id": "client.utils.iconFallbackService.getEmbedding"
  },
  "client.utils.iconFallbackService.cosineSimilarity": {
    "id": "client.utils.iconFallbackService.cosineSimilarity",
    "name": "cosineSimilarity",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [],
    "source_code": "private cosineSimilarity(a: number[], b: number[]): number {\n    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n    return dotProduct / (magnitudeA * magnitudeB);\n  }",
    "start_line": 59,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "a",
      "b"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "method cosineSimilarity",
    "component_id": "client.utils.iconFallbackService.cosineSimilarity"
  },
  "client.utils.iconFallbackService.findFallbackIcon": {
    "id": "client.utils.iconFallbackService.findFallbackIcon",
    "name": "findFallbackIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [],
    "source_code": "public async findFallbackIcon(missingIconName: string): Promise<string | null> {\n    if (typeof window === 'undefined') {\n      return null;\n    }\n\n    // Check cache first\n    if (this.fallbackCache[missingIconName]) {\n      return this.fallbackCache[missingIconName];\n    }\n\n    // Wait for precomputed data if not loaded yet\n    if (!this.precomputedData) {\n      await this.loadPrecomputedData();\n    }\n\n    if (!this.precomputedData) {\n      return null;\n    }\n\n    try {\n      // Searching fallback silently\n      \n      // Handle both prefixed (gcp_compute) and non-prefixed (server) icon names\n      let provider: string;\n      let searchTerm: string;\n      \n      const prefixMatch = missingIconName.match(/^(aws|gcp|azure)_(.+)$/);\n      if (prefixMatch) {\n        [, provider, searchTerm] = prefixMatch;\n        // Prefixed name detected\n      } else {\n        // For non-prefixed names, search across all providers to find the best semantic match\n        provider = 'gcp'; // Default to GCP for result formatting, but we'll search all\n        searchTerm = missingIconName;\n        // Non-prefixed name detected\n      }\n\n      // Get embedding for search term (only 1 API call)\n      const searchEmbedding = await this.getEmbedding(searchTerm.replace(/_/g, ' '));\n      if (!searchEmbedding) {\n        console.log(`‚ùå IconFallback: Could not get embedding for \"${searchTerm}\"`);\n        return null;\n      }\n\n      // For non-prefixed names, prioritize general icons first, then cloud provider icons\n      let globalBestMatch: { icon: string; similarity: number; provider: string } | null = null;\n      let searchProviders: string[] = [];\n      \n      if (prefixMatch) {\n        // Prefixed names: search only the specified provider\n        searchProviders = [provider];\n      } else {\n        // Non-prefixed names: first search general icons, then cloud providers\n        // Search through all embeddings to find general icons (no provider prefix)\n        for (const [iconName, iconEmbedding] of Object.entries(this.precomputedData.embeddings)) {\n          // General icons don't have provider prefixes (aws_, gcp_, azure_)\n          if (!iconName.match(/^(aws|gcp|azure)_/)) {\n            const similarity = this.cosineSimilarity(searchEmbedding, iconEmbedding);\n            if (!globalBestMatch || similarity > globalBestMatch.similarity) {\n              globalBestMatch = { icon: iconName, similarity, provider: 'general' };\n            }\n          }\n        }\n        \n        // Also search cloud providers to find the absolute best match across all icons\n        searchProviders = ['gcp', 'aws', 'azure'];\n      }\n\n      // Search cloud provider icons to find absolute best match across all providers\n      if (searchProviders.length > 0) {\n        for (const currentProvider of searchProviders) {\n          const providerIcons = iconLists[currentProvider as keyof typeof iconLists];\n          if (!providerIcons) {\n            continue;\n          }\n\n          const availableIcons = Object.values(providerIcons).flat();\n          if (availableIcons.length === 0) {\n            continue;\n          }\n\n          // Compare against precomputed icon embeddings (no API calls)\n          for (const icon of availableIcons) {\n            const iconEmbedding = this.precomputedData.embeddings[icon];\n            if (iconEmbedding) {\n              const similarity = this.cosineSimilarity(searchEmbedding, iconEmbedding);\n              if (!globalBestMatch || similarity > globalBestMatch.similarity) {\n                globalBestMatch = { icon, similarity, provider: currentProvider };\n              }\n            }\n          }\n        }\n      }\n\n      if (globalBestMatch) { // Always use best match, no matter how low similarity\n        // For general icons, don't add provider prefix\n        const fallbackIcon = globalBestMatch.provider === 'general' \n          ? globalBestMatch.icon \n          : `${globalBestMatch.provider}_${globalBestMatch.icon}`;\n        \n        // CRITICAL: Verify the fallback icon actually exists as a file\n        const iconExists = await this.verifyIconExists(fallbackIcon);\n        if (!iconExists) {\n          // Try to find the next best match that actually exists\n          return await this.findNextBestMatch(missingIconName, searchEmbedding, globalBestMatch);\n        }\n        \n        // Found valid fallback\n        this.fallbackCache[missingIconName] = fallbackIcon;\n        return fallbackIcon;\n      } else {\n        return null;\n      }\n\n    } catch (error) {\n      return null;\n    }\n  }",
    "start_line": 66,
    "end_line": 183,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "missingIconName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method findFallbackIcon",
    "component_id": "client.utils.iconFallbackService.findFallbackIcon"
  },
  "client.utils.iconFallbackService.verifyIconExists": {
    "id": "client.utils.iconFallbackService.verifyIconExists",
    "name": "verifyIconExists",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [],
    "source_code": "private async verifyIconExists(iconName: string): Promise<boolean> {\n    try {\n      // Check if it's a general icon (no provider prefix)\n      if (!iconName.includes('_') || (!iconName.startsWith('aws_') && !iconName.startsWith('gcp_') && !iconName.startsWith('azure_'))) {\n        // Try both PNG and SVG for general icons\n        const pngPath = `/assets/canvas/${iconName}.png`;\n        const svgPath = `/assets/canvas/${iconName}.svg`;\n        \n        const pngResponse = await fetch(pngPath, { method: 'HEAD' });\n        const svgResponse = await fetch(svgPath, { method: 'HEAD' });\n        \n        return pngResponse.ok || svgResponse.ok;\n      } else {\n        // Provider-specific icon\n        const [provider, actualIconName] = iconName.split('_', 2);\n        const iconPath = `/icons/${provider}/${actualIconName}.png`;\n        const response = await fetch(iconPath, { method: 'HEAD' });\n        return response.ok;\n      }\n    } catch (error) {\n      return false;\n    }\n  }",
    "start_line": 185,
    "end_line": 207,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method verifyIconExists",
    "component_id": "client.utils.iconFallbackService.verifyIconExists"
  },
  "client.utils.iconFallbackService.findNextBestMatch": {
    "id": "client.utils.iconFallbackService.findNextBestMatch",
    "name": "findNextBestMatch",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/iconFallbackService.ts",
    "relative_path": "client/utils/iconFallbackService.ts",
    "depends_on": [],
    "source_code": "private async findNextBestMatch(\n    missingIconName: string, \n    searchEmbedding: number[], \n    excludeMatch: { icon: string; provider: string; similarity: number }\n  ): Promise<string | null> {\n    let nextBestMatch: { icon: string; similarity: number; provider: string } | null = null;\n\n    // Search through all embeddings again, excluding the already found match\n    for (const [iconName, iconEmbedding] of Object.entries(this.precomputedData!.embeddings)) {\n      // Skip the already found match\n      if (iconName === excludeMatch.icon) continue;\n      \n      const similarity = this.cosineSimilarity(searchEmbedding, iconEmbedding);\n      \n      if (!nextBestMatch || similarity > nextBestMatch.similarity) {\n        const isGeneralIcon = !iconName.match(/^(aws|gcp|azure)_/);\n        \n        nextBestMatch = {\n          icon: iconName,\n          similarity,\n          provider: isGeneralIcon ? 'general' : iconName.split('_')[0]\n        };\n      }\n    }\n\n    if (nextBestMatch) {\n      const fallbackIcon = nextBestMatch.provider === 'general' \n        ? nextBestMatch.icon \n        : `${nextBestMatch.provider}_${nextBestMatch.icon}`;\n      \n      const iconExists = await this.verifyIconExists(fallbackIcon);\n      if (iconExists) {\n        this.fallbackCache[missingIconName] = fallbackIcon;\n        console.log(`‚úÖ IconFallback: Found alternative fallback \"${missingIconName}\" ‚Üí \"${fallbackIcon}\"`);\n        return fallbackIcon;\n      }\n    }\n\n    console.log(`‚ùå IconFallback: No valid fallback icons found for \"${missingIconName}\"`);\n    return null;\n  }",
    "start_line": 209,
    "end_line": 249,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "missingIconName",
      "searchEmbedding",
      "excludeMatch"
    ],
    "node_type": "method",
    "base_classes": null,
    "class_name": null,
    "display_name": "async method findNextBestMatch",
    "component_id": "client.utils.iconFallbackService.findNextBestMatch"
  },
  "client.utils.migrationTestHelpers.extractModesFromDomain": {
    "id": "client.utils.migrationTestHelpers.extractModesFromDomain",
    "name": "extractModesFromDomain",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/migrationTestHelpers.ts",
    "relative_path": "client/utils/migrationTestHelpers.ts",
    "depends_on": [
      "client.types.graph.ElkGraphNode"
    ],
    "source_code": "function extractModesFromDomain(graph: ElkGraphNode): Record<string, 'FREE' | 'LOCK'> {\n  const modes: Record<string, 'FREE' | 'LOCK'> = {};\n  \n  const traverse = (node: any) => {\n    if (node.mode) {\n      modes[node.id] = node.mode;\n    }\n    if (node.children) {\n      node.children.forEach(traverse);\n    }\n  };\n  \n  traverse(graph);\n  return modes;\n}",
    "start_line": 18,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractModesFromDomain",
    "component_id": "client.utils.migrationTestHelpers.extractModesFromDomain"
  },
  "client.utils.migrationTestHelpers.extractModesFromViewState": {
    "id": "client.utils.migrationTestHelpers.extractModesFromViewState",
    "name": "extractModesFromViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/migrationTestHelpers.ts",
    "relative_path": "client/utils/migrationTestHelpers.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function extractModesFromViewState(viewState: ViewState): Record<string, 'FREE' | 'LOCK'> {\n  const modes: Record<string, 'FREE' | 'LOCK'> = {};\n  \n  if (viewState.layout) {\n    for (const [groupId, { mode }] of Object.entries(viewState.layout)) {\n      modes[groupId] = mode;\n    }\n  }\n  \n  return modes;\n}",
    "start_line": 37,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractModesFromViewState",
    "component_id": "client.utils.migrationTestHelpers.extractModesFromViewState"
  },
  "client.utils.migrationTestHelpers.checkModeAlignment": {
    "id": "client.utils.migrationTestHelpers.checkModeAlignment",
    "name": "checkModeAlignment",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/migrationTestHelpers.ts",
    "relative_path": "client/utils/migrationTestHelpers.ts",
    "depends_on": [
      "client.types.graph.ElkGraphNode",
      "client.viewstate.ViewState.ViewState",
      "client.utils.migrationTestHelpers.extractModesFromDomain",
      "client.utils.migrationTestHelpers.extractModesFromViewState",
      "client.components.graph.utils.elk.edgePoints.add"
    ],
    "source_code": "function checkModeAlignment(viewState: ViewState, domainGraph: ElkGraphNode): {\n  correct: boolean;\n  issues: string[];\n  domainModes: Record<string, 'FREE' | 'LOCK'>;\n  viewStateModes: Record<string, 'FREE' | 'LOCK'>;\n} {\n  const domainModes = extractModesFromDomain(domainGraph);\n  const viewStateModes = extractModesFromViewState(viewState);\n  \n  const issues: string[] = [];\n  \n  // Check 1: Domain should have NO modes (after migration)\n  if (Object.keys(domainModes).length > 0) {\n    issues.push(`‚ùå Domain Graph still has modes: ${Object.keys(domainModes).join(', ')}`);\n  }\n  \n  // Check 2: ViewState should have modes for all groups\n  const allGroupIds = new Set<string>();\n  const collectGroupIds = (node: any) => {\n    if (node.children && node.children.length > 0) {\n      allGroupIds.add(node.id);\n    }\n    if (node.children) {\n      node.children.forEach(collectGroupIds);\n    }\n  };\n  collectGroupIds(domainGraph);\n  \n  for (const groupId of allGroupIds) {\n    if (!viewStateModes[groupId]) {\n      issues.push(`‚ö†Ô∏è Group \"${groupId}\" missing from ViewState.layout (will default to FREE)`);\n    }\n  }\n  \n  // Check 3: ViewState should not have modes for non-existent groups\n  for (const groupId of Object.keys(viewStateModes)) {\n    if (!allGroupIds.has(groupId)) {\n      issues.push(`‚ö†Ô∏è ViewState.layout has mode for non-existent group: \"${groupId}\"`);\n    }\n  }\n  \n  return {\n    correct: issues.length === 0,\n    issues,\n    domainModes,\n    viewStateModes\n  };\n}",
    "start_line": 52,
    "end_line": 99,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "viewState",
      "domainGraph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function checkModeAlignment",
    "component_id": "client.utils.migrationTestHelpers.checkModeAlignment"
  },
  "client.utils.migrationTestHelpers.migrationReport": {
    "id": "client.utils.migrationTestHelpers.migrationReport",
    "name": "migrationReport",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/migrationTestHelpers.ts",
    "relative_path": "client/utils/migrationTestHelpers.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState",
      "client.types.graph.ElkGraphNode",
      "client.utils.migrationTestHelpers.checkModeAlignment"
    ],
    "source_code": "function migrationReport(viewState: ViewState, domainGraph: ElkGraphNode): string {\n  const alignment = checkModeAlignment(viewState, domainGraph);\n  \n  let report = '\\nüìä MODE MIGRATION REPORT\\n';\n  report += '='.repeat(50) + '\\n\\n';\n  \n  report += '‚úÖ EXPECTED:\\n';\n  report += '  - Domain Graph: NO modes (pure structure only)\\n';\n  report += '  - ViewState.layout: All group modes\\n\\n';\n  \n  report += 'üìã ACTUAL:\\n';\n  report += `  - Domain Graph modes: ${Object.keys(alignment.domainModes).length}\\n`;\n  if (Object.keys(alignment.domainModes).length > 0) {\n    report += `    ${JSON.stringify(alignment.domainModes, null, 2)}\\n`;\n  } else {\n    report += '    ‚úÖ None (correct!)\\n';\n  }\n  \n  report += `  - ViewState.layout modes: ${Object.keys(alignment.viewStateModes).length}\\n`;\n  if (Object.keys(alignment.viewStateModes).length > 0) {\n    report += `    ${JSON.stringify(alignment.viewStateModes, null, 2)}\\n`;\n  } else {\n    report += '    ‚ö†Ô∏è None (may need migration)\\n';\n  }\n  \n  report += '\\nüîç ALIGNMENT CHECK:\\n';\n  if (alignment.correct) {\n    report += '  ‚úÖ Alignment is CORRECT!\\n';\n  } else {\n    report += '  ‚ùå Issues found:\\n';\n    alignment.issues.forEach(issue => {\n      report += `    ${issue}\\n`;\n    });\n  }\n  \n  report += '\\n' + '='.repeat(50) + '\\n';\n  \n  return report;\n}",
    "start_line": 104,
    "end_line": 142,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "viewState",
      "domainGraph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function migrationReport",
    "component_id": "client.utils.migrationTestHelpers.migrationReport"
  },
  "client.utils.migrationTestHelpers.setupWindowHelpers": {
    "id": "client.utils.migrationTestHelpers.setupWindowHelpers",
    "name": "setupWindowHelpers",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/migrationTestHelpers.ts",
    "relative_path": "client/utils/migrationTestHelpers.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.migrationTestHelpers.migrationReport",
      "client.types.graph.ElkGraphNode",
      "client.viewstate.ViewState.ViewState",
      "client.utils.migrationTestHelpers.checkModeAlignment"
    ],
    "source_code": "function setupWindowHelpers(getViewState: () => ViewState, getDomainGraph: () => ElkGraphNode) {\n  if (typeof window !== 'undefined') {\n    (window as any).getViewState = () => {\n      const vs = getViewState();\n      console.log('üì¶ ViewState:', vs);\n      console.log('üì¶ ViewState.layout:', vs.layout);\n      return vs;\n    };\n    \n    (window as any).getDomainGraph = () => {\n      const graph = getDomainGraph();\n      console.log('üå≥ Domain Graph:', graph);\n      return graph;\n    };\n    \n    (window as any).checkModeAlignment = () => {\n      const viewState = getViewState();\n      const domainGraph = getDomainGraph();\n      const result = checkModeAlignment(viewState, domainGraph);\n      console.log('üîç Alignment Check:', result);\n      return result;\n    };\n    \n    (window as any).migrationReport = () => {\n      const viewState = getViewState();\n      const domainGraph = getDomainGraph();\n      const report = migrationReport(viewState, domainGraph);\n      console.log(report);\n      return report;\n    };\n    \n  }\n}",
    "start_line": 147,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "getViewState",
      "getDomainGraph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setupWindowHelpers",
    "component_id": "client.utils.migrationTestHelpers.setupWindowHelpers"
  },
  "client.utils.naming.componentsHintFromGraph": {
    "id": "client.utils.naming.componentsHintFromGraph",
    "name": "componentsHintFromGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/naming.ts",
    "relative_path": "client/utils/naming.ts",
    "depends_on": [],
    "source_code": "function componentsHintFromGraph(rawGraph: any): string {\n  const labels = rawGraph?.children?.map((n: any) => n?.data?.label || n?.id).filter(Boolean) || [];\n  return labels.length ? `Architecture with components: ${labels.slice(0, 5).join(\", \")}` : \"\";\n}",
    "start_line": 11,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawGraph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function componentsHintFromGraph",
    "component_id": "client.utils.naming.componentsHintFromGraph"
  },
  "client.utils.naming.generateNameWithFallback": {
    "id": "client.utils.naming.generateNameWithFallback",
    "name": "generateNameWithFallback",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/naming.ts",
    "relative_path": "client/utils/naming.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.chatUtils.generateChatName",
      "client.utils.naming.componentsHintFromGraph",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function generateNameWithFallback(rawGraph: any, userPrompt?: string): Promise<string> {\n  // Use provided prompt or generate components hint\n  const prompt = userPrompt?.trim() || componentsHintFromGraph(rawGraph);\n  \n  console.log('ü§ñ Calling generateChatName API with:', { \n    userPrompt: prompt, \n    rawGraph: rawGraph ? { children: rawGraph.children?.length || 0 } : null,\n    nodeCount: rawGraph?.children?.length || 0 \n  });\n  \n  try {\n    let name = await generateChatName(prompt, rawGraph);\n    console.log('üéØ Generated chat name from API:', name);\n    \n    // If API returned default name, try with better prompt\n    if (!name || name === \"New Architecture\") {\n      console.warn('‚ö†Ô∏è API returned default name, trying with better prompt');\n      const retryPrompt = componentsHintFromGraph(rawGraph);\n      const retry = await generateChatName(retryPrompt, rawGraph);\n      console.log('üîÑ Retry generated name:', retry);\n      \n      if (retry && retry !== \"New Architecture\") {\n        name = retry;\n      }\n    }\n    \n    return name || \"New Architecture\";\n  } catch (error) {\n    console.error('‚ùå generateChatName API failed, using fallback:', error);\n    // Fallback to components-based naming\n    const fallbackName = componentsHintFromGraph(rawGraph);\n    return fallbackName || \"New Architecture\";\n  }\n}",
    "start_line": 20,
    "end_line": 53,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rawGraph",
      "userPrompt"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function generateNameWithFallback",
    "component_id": "client.utils.naming.generateNameWithFallback"
  },
  "client.utils.naming.ensureUniqueName": {
    "id": "client.utils.naming.ensureUniqueName",
    "name": "ensureUniqueName",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/naming.ts",
    "relative_path": "client/utils/naming.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function ensureUniqueName(baseName: string, existingArchitectures: any[]): string {\n  if (!existingArchitectures || existingArchitectures.length === 0) {\n    return baseName;\n  }\n  \n  const existingNames = new Set(existingArchitectures.map(arch => arch.name));\n  \n  if (!existingNames.has(baseName)) {\n    return baseName;\n  }\n  \n  // Add number suffix\n  let counter = 1;\n  let candidateName = `${baseName} (${counter})`;\n  \n  while (existingNames.has(candidateName)) {\n    counter++;\n    candidateName = `${baseName} (${counter})`;\n  }\n  \n  console.log(`üìù Ensured unique name: ${baseName} -> ${candidateName}`);\n  return candidateName;\n}",
    "start_line": 58,
    "end_line": 80,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "baseName",
      "existingArchitectures"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensureUniqueName",
    "component_id": "client.utils.naming.ensureUniqueName"
  },
  "client.utils.sendFunctionResult.sendFunctionResult": {
    "id": "client.utils.sendFunctionResult.sendFunctionResult",
    "name": "sendFunctionResult",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/sendFunctionResult.ts",
    "relative_path": "client/utils/sendFunctionResult.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "function sendFunctionResult(sendEvent: (event: any) => void, name: string, result: any): boolean {\n  console.log(`üì§ Sending function result for ${name}...`);\n  \n  // Create the function_result message\n  const functionResultMessage = {\n    type: \"conversation.item.create\",\n    item: {\n      type: \"function_result\",  // <-- critical\n      role: \"tool\",\n      name,                     // must exactly match the function the model called\n      content: result           // the *entire* graph object is fine here\n    }\n  };\n  \n  // Log message size for debugging\n  const messageSize = JSON.stringify(functionResultMessage).length;\n  console.log(`üì¶ Function result size: ${messageSize} bytes`);\n  \n  try {\n    // Send the function result message - App.jsx will handle queueing if needed\n    sendEvent(functionResultMessage);\n    console.log(`‚úÖ Function result for ${name} sent successfully`);\n    \n    // Send the response.create event to prompt the model to continue\n    sendEvent({ type: \"response.create\" });\n    console.log(`üîÑ Sending response.create to continue the conversation`);\n    \n    return true;\n  } catch (error) {\n    console.error(`‚ùå Error sending function result for ${name}:`, error);\n    return false;\n  }\n}",
    "start_line": 10,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "sendEvent",
      "name",
      "result"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sendFunctionResult",
    "component_id": "client.utils.sendFunctionResult.sendFunctionResult"
  },
  "client.utils.splitTools.chunkTools": {
    "id": "client.utils.splitTools.chunkTools",
    "name": "chunkTools",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/splitTools.js",
    "relative_path": "client/utils/splitTools.js",
    "depends_on": [],
    "source_code": "function chunkTools(tools, maxBytes = 950) {\n  const pages = [];\n  let current = [];\n  let size = 0;\n\n  for (const tool of tools) {\n    const toolSize = JSON.stringify(tool).length;\n    if (size + toolSize > maxBytes && current.length) {\n      pages.push(current);\n      current = [];\n      size = 0;\n    }\n    current.push(tool);\n    size += toolSize;\n  }\n  if (current.length) pages.push(current);\n  return pages;\n}",
    "start_line": 9,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "tools"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function chunkTools",
    "component_id": "client.utils.splitTools.chunkTools"
  },
  "client.utils.svgExport.generateSVG": {
    "id": "client.utils.svgExport.generateSVG",
    "name": "generateSVG",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/svgExport.ts",
    "relative_path": "client/utils/svgExport.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.add",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function generateSVG(layoutedGraph: any): string {\n  if (!layoutedGraph) return '';\n  \n  // Create accumulator for flattened nodes and edges\n  const collected = { nodes: [] as any[], edges: [] as any[] };\n  \n  // Helper function to flatten graph with proper coordinates\n  const flattenGraph = (\n    node: any,\n    containerOffset = { x: 0, y: 0 }\n  ) => {\n    // Skip root container itself (only its children)\n    if (node.id !== 'root') {\n      collected.nodes.push({\n        ...node,\n        x: node.x + containerOffset.x,\n        y: node.y + containerOffset.y\n      });\n    }\n    \n    // Recursively flatten children with cumulative offset\n    if (node.children && Array.isArray(node.children)) {\n      const childOffset = {\n        x: containerOffset.x + (node.id !== 'root' ? node.x : 0),\n        y: containerOffset.y + (node.id !== 'root' ? node.y : 0)\n      };\n      \n      for (const child of node.children) {\n        flattenGraph(child, childOffset);\n      }\n    }\n    \n    // Collect edges at this level\n    if (node.edges && Array.isArray(node.edges)) {\n      for (const edge of node.edges) {\n        collected.edges.push({\n          ...edge,\n          sections: edge.sections?.map((section: any) => ({\n            ...section,\n            startPoint: {\n              x: section.startPoint.x + (node.id !== 'root' ? node.x : 0) + containerOffset.x,\n              y: section.startPoint.y + (node.id !== 'root' ? node.y : 0) + containerOffset.y\n            },\n            endPoint: {\n              x: section.endPoint.x + (node.id !== 'root' ? node.x : 0) + containerOffset.x,\n              y: section.endPoint.y + (node.id !== 'root' ? node.y : 0) + containerOffset.y\n            }\n          }))\n        });\n      }\n    }\n  };\n  \n  flattenGraph(layoutedGraph);\n  \n  const nodes = collected.nodes;\n  const edges = collected.edges;\n  \n  if (nodes.length === 0) {\n    return '<svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><text x=\"50\" y=\"50\" text-anchor=\"middle\">No content</text></svg>';\n  }\n  \n  // Calculate bounds\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n  \n  for (const node of nodes) {\n    minX = Math.min(minX, node.x);\n    minY = Math.min(minY, node.y);\n    maxX = Math.max(maxX, node.x + (node.width || 100));\n    maxY = Math.max(maxY, node.y + (node.height || 60));\n  }\n  \n  const padding = 20;\n  const svgWidth = maxX - minX + padding * 2;\n  const svgHeight = maxY - minY + padding * 2;\n  \n  const shiftX = (x: number) => x - minX + padding;\n  const shiftY = (y: number) => y - minY + padding;\n  \n  // Collect all unique icons used in nodes for embedding\n  const usedIcons = new Set<string>();\n  for (const node of nodes) {\n    let icon = node.data?.icon;\n    if (icon) {\n      usedIcons.add(icon);\n      console.log('üîç [SVG] Icon found in node:', icon);\n    }\n  }\n  \n  if (usedIcons.size > 0) {\n    console.log('üì¶ [SVG] Used icons for embedding:', Array.from(usedIcons));\n  }\n  \n  // Start building SVG\n  let svg = `<svg width=\"${svgWidth}\" height=\"${svgHeight}\" xmlns=\"http://www.w3.org/2000/svg\">`;\n  \n  // Add defs for markers and icons\n  svg += `<defs>\n    <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"9\" refY=\"5\" \n      markerWidth=\"6\" markerHeight=\"6\" orient=\"auto\">\n      <path d=\"M 0 0 L 10 5 L 0 10 z\" fill=\"#2d6bc4\" />\n    </marker>\n  </defs>`;\n  \n  // Draw nodes\n  for (const node of nodes) {\n    const x = shiftX(node.x);\n    const y = shiftY(node.y);\n    const width = node.width || 100;\n    const height = node.height || 60;\n    const isContainer = !!(node.children && node.children.length > 0);\n    \n    // Determine fill color based on whether it's a container\n    const fill = isContainer ? '#f3f4f6' : '#ffffff';\n    \n    // Get icon from node data\n    const icon = node.data?.icon;\n    \n    console.log(`üé® [SVG] Rendering node: ${node.id}, container: ${isContainer}, icon: ${icon || 'none'}`, {\n      x, y, width, height,\n      hasIcon: !!node.data?.icon\n    });\n    \n    svg += `\n      <rect x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" \n        fill=\"${fill}\" stroke=\"#2d6bc4\" stroke-width=\"2\" rx=\"5\" ry=\"5\" />\n    `;\n    \n    // Add label if it exists (hide root label)\n    const label = node.data?.label || (node.labels && node.labels[0]?.text) || (node.id === 'root' ? '' : node.id);\n    \n    // Special handling - if it's the root node or if node has explicit icon in data\n    // Avoid showing the icon twice or adding redundant icon logic\n    if (label) {\n      if (isContainer) {\n        // Group node - label at center\n        svg += `\n          <text x=\"${x + width/2}\" y=\"${y + height/2}\" \n            text-anchor=\"middle\" dominant-baseline=\"middle\" \n            font-size=\"14\" font-weight=\"bold\" fill=\"#2d6bc4\">${label}</text>\n        `;\n        \n        // Add icon for container nodes too at the top\n        if (icon) {\n          // Direct image embedding approach\n          svg += `\n            <image x=\"${x + width/2 - 15}\" y=\"${y + 10}\" width=\"30\" height=\"30\" \n               href=\"/assets/canvas/${icon}.svg\" />\n          `;\n        }\n      } else {\n        // Regular node - label at bottom\n        svg += `\n          <text x=\"${x + width/2}\" y=\"${y + height - 10}\" \n            text-anchor=\"middle\" dominant-baseline=\"middle\" \n            font-size=\"12\" font-weight=\"bold\" fill=\"#2d6bc4\">${label}</text>\n        `;\n        \n        // Add icon if specified, otherwise use first letter\n        if (icon) {\n          // Direct image embedding approach\n          svg += `\n            <image x=\"${x + width/2 - 20}\" y=\"${y + 10}\" width=\"40\" height=\"40\"\n              href=\"/assets/canvas/${icon}.svg\" />\n          `;\n        } else {\n          // Fallback to first letter in a circle\n          const iconLetter = label.charAt(0).toUpperCase();\n          svg += `\n            <circle cx=\"${x + width/2}\" cy=\"${y + height/2 - 10}\" r=\"15\" fill=\"#2d6bc4\" />\n            <text x=\"${x + width/2}\" y=\"${y + height/2 - 6}\" \n              text-anchor=\"middle\" dominant-baseline=\"middle\" \n              font-size=\"14\" font-weight=\"bold\" fill=\"white\">${iconLetter}</text>\n          `;\n        }\n      }\n    }\n    \n    // Add node ID as smaller text below\n    svg += `\n      <text x=\"${x + width/2}\" y=\"${y + height - 2}\" \n        text-anchor=\"middle\" dominant-baseline=\"baseline\" \n        font-size=\"9\" fill=\"#666666\">(${node.id})</text>\n    `;\n  }\n  \n  // Draw edges\n  for (const edge of edges) {\n    if (!edge.sections || edge.sections.length === 0) {\n      continue;\n    }\n    \n    // Handle multi-section edges (support both types)\n    for (let i = 0; i < edge.sections.length; i++) {\n      const section = edge.sections[i];\n      const startX = shiftX(section.startPoint.x);\n      const startY = shiftY(section.startPoint.y);\n      const endX = shiftX(section.endPoint.x);\n      const endY = shiftY(section.endPoint.y);\n      \n      // Build polyline points\n      let points = `${startX},${startY}`;\n      \n      // Add bend points if they exist\n      if (section.bendPoints && section.bendPoints.length > 0) {\n        for (const bendPoint of section.bendPoints) {\n          points += ` ${shiftX(bendPoint.x)},${shiftY(bendPoint.y)}`;\n        }\n      }\n      \n      points += ` ${endX},${endY}`;\n      \n      svg += `\n        <polyline points=\"${points}\" fill=\"none\" stroke=\"#2d6bc4\" \n          stroke-width=\"2\" marker-end=\"url(#arrow)\" />\n      `;\n      \n      // Add edge label if it exists\n      if (edge.labels && edge.labels.length > 0) {\n        const rawLabel = edge.labels[0];\n        // Use the edge section's coordinates directly or fall back to calculated positions\n        let labelX: number, labelY: number;\n        \n        if (i === 0 && section.bendPoints && section.bendPoints.length > 0) {\n          // Position label at first bend point\n          const firstBend = section.bendPoints[0];\n          labelX = shiftX(firstBend.x);\n          labelY = shiftY(firstBend.y) - 15; // Slightly above\n        } else {\n          // Position label at middle of section\n          labelX = (startX + endX) / 2;\n          labelY = (startY + endY) / 2 - 15;\n        }\n        \n        // Draw label with higher z-index to ensure visibility\n        svg += `\n          <text x=\"${labelX}\" y=\"${labelY}\" \n            text-anchor=\"middle\" dominant-baseline=\"middle\" \n            font-size=\"11\" fill=\"#333\" \n            paint-order=\"stroke\"\n            stroke=\"#fff\" \n            stroke-width=\"3\" \n            stroke-linecap=\"round\" \n            stroke-linejoin=\"round\">${rawLabel.text}</text>\n        `;\n      }\n    }\n  }\n  \n  // Close SVG tag\n  svg += '</svg>';\n  \n  return svg;\n}",
    "start_line": 10,
    "end_line": 263,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "layoutedGraph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateSVG",
    "component_id": "client.utils.svgExport.generateSVG"
  },
  "client.utils.svgExport.handleSvgZoom": {
    "id": "client.utils.svgExport.handleSvgZoom",
    "name": "handleSvgZoom",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/svgExport.ts",
    "relative_path": "client/utils/svgExport.ts",
    "depends_on": [],
    "source_code": "function handleSvgZoom(delta: number, currentZoom: number): number {\n  return Math.max(0.2, Math.min(5, currentZoom + delta));\n}",
    "start_line": 268,
    "end_line": 270,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "delta",
      "currentZoom"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handleSvgZoom",
    "component_id": "client.utils.svgExport.handleSvgZoom"
  },
  "client.utils.svgExport.isValidSVG": {
    "id": "client.utils.svgExport.isValidSVG",
    "name": "isValidSVG",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/svgExport.ts",
    "relative_path": "client/utils/svgExport.ts",
    "depends_on": [],
    "source_code": "function isValidSVG(svg: string): boolean {\n  if (!svg || typeof svg !== 'string') return false;\n  return svg.trim().startsWith('<svg') && svg.trim().endsWith('</svg>');\n}",
    "start_line": 275,
    "end_line": 278,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "svg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function isValidSVG",
    "component_id": "client.utils.svgExport.isValidSVG"
  },
  "client.utils.svgExport.getSVGDimensions": {
    "id": "client.utils.svgExport.getSVGDimensions",
    "name": "getSVGDimensions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/svgExport.ts",
    "relative_path": "client/utils/svgExport.ts",
    "depends_on": [],
    "source_code": "function getSVGDimensions(svg: string): { width: number; height: number } | null {\n  const widthMatch = svg.match(/width=\"(\\d+(?:\\.\\d+)?)\"/);\n  const heightMatch = svg.match(/height=\"(\\d+(?:\\.\\d+)?)\"/);\n  \n  if (widthMatch && heightMatch) {\n    return {\n      width: parseFloat(widthMatch[1]),\n      height: parseFloat(heightMatch[1])\n    };\n  }\n  \n  return null;\n}",
    "start_line": 283,
    "end_line": 295,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "svg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getSVGDimensions",
    "component_id": "client.utils.svgExport.getSVGDimensions"
  },
  "client.utils.testArchitectureSearch.testArchitectureSearch": {
    "id": "client.utils.testArchitectureSearch.testArchitectureSearch",
    "name": "testArchitectureSearch",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testArchitectureSearch.ts",
    "relative_path": "client/utils/testArchitectureSearch.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.utils.architectureSearchService.findMatchingArchitecture"
    ],
    "source_code": "async function testArchitectureSearch() {\n  console.log('üß™ Testing Architecture Search Service...');\n  \n  const testCases = [\n    'machine learning training',\n    'gen ai chatbot',\n    'data analytics',\n    'microservices',\n    'kubernetes deployment',\n    'real-time streaming',\n    'web application',\n    'mobile backend'\n  ];\n\n  for (const testCase of testCases) {\n    console.log(`\\nüîç Testing: \"${testCase}\"`);\n    try {\n      const result = await architectureSearchService.findMatchingArchitecture(testCase);\n      if (result) {\n        console.log(`‚úÖ Match found: ${result.subgroup}`);\n        console.log(`üìã Description: ${result.description}`);\n        console.log(`üèóÔ∏è Architecture: ${result.architecture}`);\n      } else {\n        console.log(`‚ùå No match found for: ${testCase}`);\n      }\n    } catch (error) {\n      console.error(`üí• Error testing ${testCase}:`, error);\n    }\n  }\n}",
    "start_line": 3,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testArchitectureSearch",
    "component_id": "client.utils.testArchitectureSearch.testArchitectureSearch"
  },
  "client.utils.testArchitectureSearch.testSingleArchitecture": {
    "id": "client.utils.testArchitectureSearch.testSingleArchitecture",
    "name": "testSingleArchitecture",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testArchitectureSearch.ts",
    "relative_path": "client/utils/testArchitectureSearch.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.architectureSearchService.findMatchingArchitecture",
      "client.utils.architectureSearchService.getAvailableArchitectures",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function testSingleArchitecture(userInput: string) {\n  console.log(`üß™ Testing single architecture search: ${userInput}`);\n  \n  // Check if service is initialized\n  const architectures = architectureSearchService.getAvailableArchitectures();\n  console.log(`üìä Service has ${architectures.length} architectures loaded`);\n  \n  if (architectures.length === 0) {\n    console.warn('‚ö†Ô∏è No architectures loaded yet. Try again in a few seconds...');\n    return null;\n  }\n  \n  try {\n    const result = await architectureSearchService.findMatchingArchitecture(userInput);\n    if (result) {\n      console.log(`‚úÖ Match found: ${result.subgroup}`);\n      console.log(`üìã Description: ${result.description}`);\n      console.log(`üîó Source URL: ${result.source}`);\n      console.log(`‚òÅÔ∏è Cloud Provider: ${result.cloud.toUpperCase()}`);\n      console.log(`üìÅ Category: ${result.group} > ${result.subgroup}`);\n      console.log(`üèóÔ∏è Architecture JSON:`);\n      console.log(result.architecture);\n      return result;\n    } else {\n      console.log(`‚ùå No match found for: ${userInput}`);\n      return null;\n    }\n  } catch (error) {\n    console.error(`üí• Error testing ${userInput}:`, error);\n    return null;\n  }\n}",
    "start_line": 34,
    "end_line": 65,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "userInput"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testSingleArchitecture",
    "component_id": "client.utils.testArchitectureSearch.testSingleArchitecture"
  },
  "client.utils.testArchitectureSearch.listAvailableArchitectures": {
    "id": "client.utils.testArchitectureSearch.listAvailableArchitectures",
    "name": "listAvailableArchitectures",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testArchitectureSearch.ts",
    "relative_path": "client/utils/testArchitectureSearch.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.architectureSearchService.getAvailableArchitectures"
    ],
    "source_code": "function listAvailableArchitectures() {\n  console.log('üìã Available reference architectures:');\n  const architectures = architectureSearchService.getAvailableArchitectures();\n  \n  const grouped = architectures.reduce((acc, arch) => {\n    if (!acc[arch.group]) acc[arch.group] = [];\n    acc[arch.group].push(arch);\n    return acc;\n  }, {} as Record<string, any[]>);\n\n  for (const [group, archs] of Object.entries(grouped)) {\n    console.log(`\\nüìÅ ${group}:`);\n    archs.forEach(arch => {\n      console.log(`  ‚Ä¢ ${arch.subgroup}: ${arch.description}`);\n    });\n  }\n}",
    "start_line": 67,
    "end_line": 83,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function listAvailableArchitectures",
    "component_id": "client.utils.testArchitectureSearch.listAvailableArchitectures"
  },
  "client.utils.testHelpers.getRandomArchitecturePrompt": {
    "id": "client.utils.testHelpers.getRandomArchitecturePrompt",
    "name": "getRandomArchitecturePrompt",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testHelpers.ts",
    "relative_path": "client/utils/testHelpers.ts",
    "depends_on": [],
    "source_code": "function getRandomArchitecturePrompt(): string {\n  const randomIndex = Math.floor(Math.random() * architecturePrompts.length);\n  return architecturePrompts[randomIndex];\n}",
    "start_line": 19,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getRandomArchitecturePrompt",
    "component_id": "client.utils.testHelpers.getRandomArchitecturePrompt"
  },
  "client.utils.testHelpers.waitForArchitectureGeneration": {
    "id": "client.utils.testHelpers.waitForArchitectureGeneration",
    "name": "waitForArchitectureGeneration",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testHelpers.ts",
    "relative_path": "client/utils/testHelpers.ts",
    "depends_on": [],
    "source_code": "function waitForArchitectureGeneration(page: any, timeout: number = 15000): Promise<void> {\n  return new Promise(async (resolve, reject) => {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      const nodeCount = await page.locator('.react-flow__node').count();\n      if (nodeCount > 0) {\n        resolve();\n        return;\n      }\n      await page.waitForTimeout(500);\n    }\n    \n    reject(new Error('Architecture generation timeout'));\n  });\n}",
    "start_line": 24,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page",
      "timeout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function waitForArchitectureGeneration",
    "component_id": "client.utils.testHelpers.waitForArchitectureGeneration"
  },
  "client.utils.testHelpers.generateTestArchitectureData": {
    "id": "client.utils.testHelpers.generateTestArchitectureData",
    "name": "generateTestArchitectureData",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testHelpers.ts",
    "relative_path": "client/utils/testHelpers.ts",
    "depends_on": [],
    "source_code": "function generateTestArchitectureData() {\n  return {\n    name: 'Test Architecture',\n    rawGraph: {\n      id: 'root',\n      children: [\n        {\n          id: 'api-gateway',\n          data: { label: 'API Gateway', icon: 'aws_api_gateway' },\n          position: { x: 100, y: 100 }\n        },\n        {\n          id: 'user-service',\n          data: { label: 'User Service', icon: 'aws_lambda' },\n          position: { x: 300, y: 100 }\n        },\n        {\n          id: 'database',\n          data: { label: 'Database', icon: 'ads_rds' },\n          position: { x: 300, y: 300 }\n        }\n      ],\n      edges: [\n        {\n          id: 'e1',\n          source: 'api-gateway',\n          target: 'user-service'\n        },\n        {\n          id: 'e2',\n          source: 'user-service',\n          target: 'database'\n        }\n      ]\n    }\n  };\n}",
    "start_line": 41,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generateTestArchitectureData",
    "component_id": "client.utils.testHelpers.generateTestArchitectureData"
  },
  "client.utils.testIconFallback.testIconLoads": {
    "id": "client.utils.testIconFallback.testIconLoads",
    "name": "testIconLoads",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testIconFallback.ts",
    "relative_path": "client/utils/testIconFallback.ts",
    "depends_on": [],
    "source_code": "async function testIconLoads(iconName: string): Promise<boolean> {\n  // Check if it's a general icon (no provider prefix)\n  const isGeneral = !iconName.match(/^(aws|gcp|azure)_/);\n  \n  if (isGeneral) {\n    // Try general icon paths\n    const paths = [\n      `/assets/canvas/${iconName}.png`,\n      `/assets/canvas/${iconName}.svg`\n    ];\n    \n    for (const path of paths) {\n      const exists = await new Promise<boolean>((resolve) => {\n        const img = new Image();\n        img.onload = () => resolve(true);\n        img.onerror = () => resolve(false);\n        img.src = path;\n        setTimeout(() => resolve(false), 2000);\n      });\n      if (exists) return true;\n    }\n    return false;\n  } else {\n    // Provider icon - use simple path for testing\n    return new Promise((resolve) => {\n      const img = new Image();\n      img.onload = () => resolve(true);\n      img.onerror = () => resolve(false);\n      \n      // This is simplified - real CustomNode logic is more complex\n      const iconPath = `/icons/${iconName.replace('_', '/')}.png`;\n      img.src = iconPath;\n      \n      setTimeout(() => resolve(false), 2000);\n    });\n  }\n}",
    "start_line": 6,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testIconLoads",
    "component_id": "client.utils.testIconFallback.testIconLoads"
  },
  "client.utils.testIconFallback.testIconFallback": {
    "id": "client.utils.testIconFallback.testIconFallback",
    "name": "testIconFallback",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testIconFallback.ts",
    "relative_path": "client/utils/testIconFallback.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.iconFallbackService.findFallbackIcon",
      "scripts.test-vercel-preview.error",
      "client.utils.testIconFallback.testIconLoads"
    ],
    "source_code": "async function testIconFallback() {\n  console.log('üß™ Testing Icon Fallback Service with Frontend Verification...');\n  \n  const testCases = [\n    'gcp_instance_group',        // Missing icon that triggered this feature\n    'gcp_kubernetes_cluster',    // Another potentially missing icon\n    'aws_invalid_service',       // AWS test case\n    'azure_some_service',        // Azure test case\n    'gcp_compute_instances',     // Another GCP test case\n    'nonexistent_service',       // Definitely missing\n    'database_cluster',          // Generic term\n    'load_balancer'             // Another generic term\n  ];\n\n  let passedTests = 0;\n  let failedTests = 0;\n\n  for (const testIcon of testCases) {\n    console.log(`\\nüîç Testing: ${testIcon}`);\n    \n    // First check if original icon exists\n    const originalExists = await testIconLoads(testIcon);\n    console.log(`   Original icon exists: ${originalExists ? '‚úÖ' : '‚ùå'}`);\n    \n    if (!originalExists) {\n      // Test fallback service\n      try {\n        const fallback = await iconFallbackService.findFallbackIcon(testIcon);\n        if (fallback) {\n          console.log(`   üîÑ Found fallback: ${testIcon} ‚Üí ${fallback}`);\n          \n          // Test if fallback actually loads\n          const fallbackExists = await testIconLoads(fallback);\n          console.log(`   Fallback loads: ${fallbackExists ? '‚úÖ' : '‚ùå'}`);\n          \n          if (fallbackExists) {\n            console.log(`   ‚úÖ SUCCESS: ${testIcon} has working fallback`);\n            passedTests++;\n          } else {\n            console.log(`   ‚ùå FAILED: ${testIcon} fallback doesn't load in frontend`);\n            failedTests++;\n          }\n        } else {\n          console.log(`   ‚ùå FAILED: No fallback found for ${testIcon}`);\n          failedTests++;\n        }\n      } catch (error) {\n        console.error(`   üí• ERROR: ${testIcon}:`, error);\n        failedTests++;\n      }\n    } else {\n      console.log(`   ‚úÖ SKIP: ${testIcon} original icon works`);\n    }\n  }\n  \n  console.log(`\\nüéØ Icon Fallback Test Results:`);\n  console.log(`   ‚úÖ Passed: ${passedTests}`);\n  console.log(`   ‚ùå Failed: ${failedTests}`);\n  console.log(`   üìä Success Rate: ${Math.round((passedTests / (passedTests + failedTests)) * 100)}%`);\n  \n  return { passed: passedTests, failed: failedTests };\n}",
    "start_line": 48,
    "end_line": 109,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testIconFallback",
    "component_id": "client.utils.testIconFallback.testIconFallback"
  },
  "client.utils.testIconFallback.testSingleIcon": {
    "id": "client.utils.testIconFallback.testSingleIcon",
    "name": "testSingleIcon",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testIconFallback.ts",
    "relative_path": "client/utils/testIconFallback.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.iconFallbackService.findFallbackIcon",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function testSingleIcon(iconName: string) {\n  console.log(`üß™ Testing single icon: ${iconName}`);\n  try {\n    const fallback = await iconFallbackService.findFallbackIcon(iconName);\n    if (fallback) {\n      console.log(`‚úÖ Fallback found: ${iconName} ‚Üí ${fallback}`);\n      return fallback;\n    } else {\n      console.log(`‚ùå No fallback found for: ${iconName}`);\n      return null;\n    }\n  } catch (error) {\n    console.error(`üí• Error:`, error);\n    return null;\n  }\n}",
    "start_line": 114,
    "end_line": 129,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testSingleIcon",
    "component_id": "client.utils.testIconFallback.testSingleIcon"
  },
  "client.utils.testIconFallback.testCompleteIconPipeline": {
    "id": "client.utils.testIconFallback.testCompleteIconPipeline",
    "name": "testCompleteIconPipeline",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testIconFallback.ts",
    "relative_path": "client/utils/testIconFallback.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.iconFallbackService.findFallbackIcon",
      "scripts.test-vercel-preview.error",
      "client.utils.testIconFallback.testIconLoads"
    ],
    "source_code": "async function testCompleteIconPipeline(iconName: string) {\n  console.log(`\\nüîß COMPLETE PIPELINE TEST: ${iconName}`);\n  \n  // Step 1: Test semantic fallback\n  try {\n    const fallback = await iconFallbackService.findFallbackIcon(iconName);\n    console.log(`1Ô∏è‚É£ Semantic fallback: ${iconName} ‚Üí ${fallback || 'NONE'}`);\n    \n    if (!fallback) {\n      console.log(`‚ùå FAILED: No semantic fallback found`);\n      return;\n    }\n    \n    // Step 2: Test icon path construction\n    const isGeneral = !fallback.match(/^(aws|gcp|azure)_/);\n    let iconPath;\n    \n    if (isGeneral) {\n      // General icon path\n      iconPath = `/assets/canvas/${fallback}.png`;\n    } else {\n      // Provider icon path - need to find category\n      const [provider, iconBaseName] = fallback.split('_', 2);\n      // This is simplified - real logic is more complex\n      iconPath = `/icons/${provider}/compute/${iconBaseName}.png`;\n    }\n    \n    console.log(`2Ô∏è‚É£ Icon path: ${iconPath}`);\n    \n    // Step 3: Test if icon actually loads\n    const iconExists = await testIconLoads(fallback);\n    console.log(`3Ô∏è‚É£ Icon loads: ${iconExists ? '‚úÖ' : '‚ùå'}`);\n    \n    if (!iconExists) {\n      console.log(`‚ùå FAILED: Icon path doesn't work`);\n      // Try alternative paths\n      if (isGeneral) {\n        const altPath = `/assets/canvas/${fallback}.svg`;\n        console.log(`üîÑ Trying SVG: ${altPath}`);\n        const svgExists = await new Promise(resolve => {\n          const img = new Image();\n          img.onload = () => resolve(true);\n          img.onerror = () => resolve(false);\n          img.src = altPath;\n          setTimeout(() => resolve(false), 2000);\n        });\n        console.log(`   SVG loads: ${svgExists ? '‚úÖ' : '‚ùå'}`);\n      }\n    }\n    \n  } catch (error) {\n    console.error(`üí• Pipeline error:`, error);\n  }\n}",
    "start_line": 134,
    "end_line": 187,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testCompleteIconPipeline",
    "component_id": "client.utils.testIconFallback.testCompleteIconPipeline"
  },
  "client.utils.testIconFallback.debugIconFallback": {
    "id": "client.utils.testIconFallback.debugIconFallback",
    "name": "debugIconFallback",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/testIconFallback.ts",
    "relative_path": "client/utils/testIconFallback.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.utils.testIconFallback.testCompleteIconPipeline"
    ],
    "source_code": "async function debugIconFallback() {\n  console.log('üîß DEBUG: Testing icon fallback service...');\n  \n  const testCases = ['instance_group', 'database', 'server', 'api'];\n  \n  for (const testIcon of testCases) {\n    await testCompleteIconPipeline(testIcon);\n  }\n}",
    "start_line": 192,
    "end_line": 200,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function debugIconFallback",
    "component_id": "client.utils.testIconFallback.debugIconFallback"
  },
  "client.utils.textMeasurement.initMeasurement": {
    "id": "client.utils.textMeasurement.initMeasurement",
    "name": "initMeasurement",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/textMeasurement.ts",
    "relative_path": "client/utils/textMeasurement.ts",
    "depends_on": [],
    "source_code": "function initMeasurement() {\n  if (typeof window === 'undefined') return; // SSR safety\n  \n  if (!measurementSvg) {\n    // Create an off-screen SVG for text measurement\n    measurementSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    measurementSvg.style.position = 'absolute';\n    measurementSvg.style.left = '-9999px';\n    measurementSvg.style.top = '-9999px';\n    measurementSvg.style.width = '1px';\n    measurementSvg.style.height = '1px';\n    measurementSvg.style.visibility = 'hidden';\n    \n    measurementText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    // Apply the EXACT same font styles that will be used in React Flow nodes\n    measurementText.style.fontSize = '12px';\n    measurementText.style.fontFamily = 'system-ui, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif';\n    measurementText.style.fontWeight = 'normal'; // Match React Flow default\n    \n    measurementSvg.appendChild(measurementText);\n    document.body.appendChild(measurementSvg);\n  }\n}",
    "start_line": 12,
    "end_line": 34,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function initMeasurement",
    "component_id": "client.utils.textMeasurement.initMeasurement"
  },
  "client.utils.textMeasurement.splitTextIntoLines": {
    "id": "client.utils.textMeasurement.splitTextIntoLines",
    "name": "splitTextIntoLines",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/textMeasurement.ts",
    "relative_path": "client/utils/textMeasurement.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn",
      "client.utils.textMeasurement.initMeasurement"
    ],
    "source_code": "function splitTextIntoLines(text: string, maxLineWidth: number = 76): string[] {\n  // For browser environment, use proper text measurement\n  if (typeof window !== 'undefined') {\n    initMeasurement();\n    if (measurementText) {\n      try {\n        const words = text.split(' ');\n        const lines: string[] = [];\n        let currentLine = '';\n        \n        // Special logging for GKE Gateway Controller\n        if (text === \"GKE Gateway Controller\") {\n          console.log(`üîç [MEASUREMENT] Splitting \"${text}\" with maxWidth: ${maxLineWidth}px`);\n        }\n        \n        for (const word of words) {\n          const testLine = currentLine ? `${currentLine} ${word}` : word;\n          measurementText.textContent = testLine;\n          const testWidth = measurementText.getBBox().width;\n          \n          if (text === \"GKE Gateway Controller\") {\n            console.log(`  [MEASUREMENT] Testing: \"${testLine}\" -> ${testWidth}px (limit: ${maxLineWidth}px)`);\n          }\n          \n          if (testWidth <= maxLineWidth) {\n            currentLine = testLine;\n          } else {\n            if (currentLine) {\n              lines.push(currentLine);\n              if (text === \"GKE Gateway Controller\") {\n                console.log(`  [MEASUREMENT] ‚úÖ Added line: \"${currentLine}\"`);\n              }\n              currentLine = word;\n            } else {\n              // Single word is too long, but DON'T break it - keep as one line\n              lines.push(word);\n              if (text === \"GKE Gateway Controller\") {\n                console.log(`  [MEASUREMENT] ‚ö†Ô∏è Long word: \"${word}\"`);\n              }\n              currentLine = '';\n            }\n          }\n        }\n        \n        if (currentLine) {\n          lines.push(currentLine);\n          if (text === \"GKE Gateway Controller\") {\n            console.log(`  [MEASUREMENT] ‚úÖ Final line: \"${currentLine}\"`);\n          }\n        }\n        \n        if (text === \"GKE Gateway Controller\") {\n          console.log(`üéØ [MEASUREMENT] Result: [${lines.join('\", \"')}] (${lines.length} lines)`);\n        }\n        return lines;\n      } catch (error) {\n        console.warn('‚ùå Failed to measure text, using fallback:', error);\n      }\n    }\n  }\n  \n  // Fallback: Simple character-based estimation (no word breaking)\n  const avgCharWidth = 7; // Approximate character width\n  const maxCharsPerLine = Math.floor(maxLineWidth / avgCharWidth);\n  const words = text.split(' ');\n  const lines: string[] = [];\n  let currentLine = '';\n  \n  for (const word of words) {\n    const testLine = currentLine ? `${currentLine} ${word}` : word;\n    if (testLine.length <= maxCharsPerLine) {\n      currentLine = testLine;\n    } else {\n      if (currentLine) {\n        lines.push(currentLine);\n        currentLine = word;\n      } else {\n        // Single word is too long, but DON'T break it\n        lines.push(word);\n      }\n    }\n  }\n  \n  if (currentLine) {\n    lines.push(currentLine);\n  }\n  return lines;\n}",
    "start_line": 44,
    "end_line": 131,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text",
      "maxLineWidth"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function splitTextIntoLines",
    "component_id": "client.utils.textMeasurement.splitTextIntoLines"
  },
  "client.utils.textMeasurement.measureNodeLabel": {
    "id": "client.utils.textMeasurement.measureNodeLabel",
    "name": "measureNodeLabel",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/textMeasurement.ts",
    "relative_path": "client/utils/textMeasurement.ts",
    "depends_on": [
      "client.utils.textMeasurement.splitTextIntoLines",
      "client.utils.textMeasurement.initMeasurement"
    ],
    "source_code": "function measureNodeLabel(text: string): { width: number; height: number; lines: number } {\n  const maxLineWidth = 76; // Reduced width to add horizontal padding (100px - 24px padding)\n  const lines = splitTextIntoLines(text, maxLineWidth);\n  \n  // Measure the final dimensions\n  const lineHeight = 14;\n  const totalHeight = lines.length * lineHeight;\n  \n  // Find the widest line for accurate width\n  let maxWidth = 0;\n  if (typeof window !== 'undefined') {\n    initMeasurement();\n    if (measurementText) {\n      try {\n        for (const line of lines) {\n          measurementText.textContent = line;\n          const lineWidth = measurementText.getBBox().width;\n          maxWidth = Math.max(maxWidth, lineWidth);\n        }\n      } catch (error) {\n        maxWidth = text.length * 7; // Fallback\n      }\n    }\n  } else {\n    maxWidth = text.length * 7; // SSR fallback\n  }\n  \n  return {\n    width: Math.ceil(maxWidth),\n    height: totalHeight,\n    lines: lines.length\n  };\n}",
    "start_line": 133,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "text"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function measureNodeLabel",
    "component_id": "client.utils.textMeasurement.measureNodeLabel"
  },
  "client.utils.textMeasurement.calculateNodeDimensions": {
    "id": "client.utils.textMeasurement.calculateNodeDimensions",
    "name": "calculateNodeDimensions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/textMeasurement.ts",
    "relative_path": "client/utils/textMeasurement.ts",
    "depends_on": [
      "client.utils.textMeasurement.measureNodeLabel"
    ],
    "source_code": "function calculateNodeDimensions(label: string): { width: number; height: number } {\n  const textDims = measureNodeLabel(label);\n  \n  // Constants for icon and padding\n  const ICON_SIZE = 48; // Square icons - full width/height\n  const NODE_WIDTH = 100; // Keep original width - DO NOT CHANGE\n  const HORIZONTAL_PADDING = 16;\n  const VERTICAL_PADDING = 12;\n  const ICON_TEXT_GAP = 12; // Increased gap between icon and text\n  \n  // Calculate required dimensions:\n  // - WIDTH: Fixed for all nodes to maintain alignment\n  // - HEIGHT: Square for 1 line, variable for multi-line\n  const width = NODE_WIDTH;\n  \n  // For single line: make node square (100x100)\n  // For multi-line: add extra height for additional lines\n  if (textDims.lines === 1) {\n    // Single line: make it square\n    const height = NODE_WIDTH; // 100px - perfectly square\n    return { width, height };\n  } else {\n    // Multi-line: base square size + extra height for additional lines\n    const baseHeight = NODE_WIDTH; // Start with square\n    const extraLines = textDims.lines - 1; // Additional lines beyond first\n    const extraHeight = extraLines * 14; // 14px per extra line\n    const height = baseHeight + extraHeight;\n    return { width, height };\n  }\n}",
    "start_line": 171,
    "end_line": 200,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "label"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculateNodeDimensions",
    "component_id": "client.utils.textMeasurement.calculateNodeDimensions"
  },
  "client.utils.textMeasurement.cleanupMeasurement": {
    "id": "client.utils.textMeasurement.cleanupMeasurement",
    "name": "cleanupMeasurement",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/textMeasurement.ts",
    "relative_path": "client/utils/textMeasurement.ts",
    "depends_on": [],
    "source_code": "function cleanupMeasurement() {\n  if (measurementSvg && measurementSvg.parentNode) {\n    measurementSvg.parentNode.removeChild(measurementSvg);\n    measurementSvg = null;\n    measurementText = null;\n  }\n}",
    "start_line": 205,
    "end_line": 211,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cleanupMeasurement",
    "component_id": "client.utils.textMeasurement.cleanupMeasurement"
  },
  "client.utils.viewstateDebug.logDeletionAndSave": {
    "id": "client.utils.viewstateDebug.logDeletionAndSave",
    "name": "logDeletionAndSave",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/viewstateDebug.ts",
    "relative_path": "client/utils/viewstateDebug.ts",
    "depends_on": [],
    "source_code": "function logDeletionAndSave(...args: any[]) {}",
    "start_line": 1,
    "end_line": 1,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logDeletionAndSave",
    "component_id": "client.utils.viewstateDebug.logDeletionAndSave"
  },
  "client.utils.viewstateDebug.logPageLoad": {
    "id": "client.utils.viewstateDebug.logPageLoad",
    "name": "logPageLoad",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/viewstateDebug.ts",
    "relative_path": "client/utils/viewstateDebug.ts",
    "depends_on": [],
    "source_code": "function logPageLoad(...args: any[]) {}",
    "start_line": 2,
    "end_line": 2,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logPageLoad",
    "component_id": "client.utils.viewstateDebug.logPageLoad"
  },
  "client.utils.viewstateDebug.logUrlArchCheck": {
    "id": "client.utils.viewstateDebug.logUrlArchCheck",
    "name": "logUrlArchCheck",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/viewstateDebug.ts",
    "relative_path": "client/utils/viewstateDebug.ts",
    "depends_on": [],
    "source_code": "function logUrlArchCheck(...args: any[]) {}",
    "start_line": 3,
    "end_line": 3,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function logUrlArchCheck",
    "component_id": "client.utils.viewstateDebug.logUrlArchCheck"
  },
  "client.utils.viewstateDebug.extractGroupIdsFromGraph": {
    "id": "client.utils.viewstateDebug.extractGroupIdsFromGraph",
    "name": "extractGroupIdsFromGraph",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/utils/viewstateDebug.ts",
    "relative_path": "client/utils/viewstateDebug.ts",
    "depends_on": [],
    "source_code": "function extractGroupIdsFromGraph(graph: any): string[] {\n  return [];\n}",
    "start_line": 4,
    "end_line": 6,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extractGroupIdsFromGraph",
    "component_id": "client.utils.viewstateDebug.extractGroupIdsFromGraph"
  },
  "client.viewstate.ViewState.ViewState": {
    "id": "client.viewstate.ViewState.ViewState",
    "name": "ViewState",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/viewstate/ViewState.ts",
    "relative_path": "client/viewstate/ViewState.ts",
    "depends_on": [],
    "source_code": "type ViewState = {\n  node?: Record<string, { x: number; y: number; w?: number; h?: number }>;\n  group?: Record<string, { x: number; y: number; w?: number; h?: number }>;\n  edge?: Record<string, { waypoints?: Array<{ x: number; y: number }> }>;\n};",
    "start_line": 9,
    "end_line": 13,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type ViewState",
    "component_id": "client.viewstate.ViewState.ViewState"
  },
  "client.viewstate.ViewState.Geometry": {
    "id": "client.viewstate.ViewState.Geometry",
    "name": "Geometry",
    "component_type": "type",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/viewstate/ViewState.ts",
    "relative_path": "client/viewstate/ViewState.ts",
    "depends_on": [],
    "source_code": "type Geometry = { x: number; y: number; w?: number; h?: number };",
    "start_line": 15,
    "end_line": 15,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "type_alias",
    "base_classes": null,
    "class_name": null,
    "display_name": "type Geometry",
    "component_id": "client.viewstate.ViewState.Geometry"
  },
  "client.viewstate.ViewState.createEmptyViewState": {
    "id": "client.viewstate.ViewState.createEmptyViewState",
    "name": "createEmptyViewState",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/viewstate/ViewState.ts",
    "relative_path": "client/viewstate/ViewState.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function createEmptyViewState(): ViewState {\n  return {\n    node: {},\n    group: {},\n    edge: {},\n  };\n}",
    "start_line": 20,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createEmptyViewState",
    "component_id": "client.viewstate.ViewState.createEmptyViewState"
  },
  "client.viewstate.ViewState.requireGeometry": {
    "id": "client.viewstate.ViewState.requireGeometry",
    "name": "requireGeometry",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/viewstate/ViewState.ts",
    "relative_path": "client/viewstate/ViewState.ts",
    "depends_on": [
      "client.viewstate.ViewState.Geometry",
      "client.viewstate.ViewState.ViewState",
      "client.components.graph.utils.elk.edgePoints.warn",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "function requireGeometry(\n  kind: 'node' | 'group',\n  id: string,\n  viewState: ViewState\n): Geometry {\n  const store = kind === 'node' ? viewState.node : viewState.group;\n  const geometry = store?.[id];\n\n  if (!geometry || !Number.isFinite(geometry.x) || !Number.isFinite(geometry.y)) {\n    const error = new Error(\n      `[ViewState] Missing geometry for ${kind} \"${id}\". ` +\n      `ViewState is the source of truth; no fallbacks allowed. ` +\n      `Ensure Layout or Orchestration has written geometry before rendering.`\n    );\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(error);\n      throw error;\n    }\n    // In production, return a safe default but log warning\n    console.warn(`[ViewState] Missing geometry for ${kind} \"${id}\", using fallback (0,0)`);\n    return { x: 0, y: 0, w: 0, h: 0 };\n  }\n\n  return geometry;\n}",
    "start_line": 38,
    "end_line": 62,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "kind",
      "id",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function requireGeometry",
    "component_id": "client.viewstate.ViewState.requireGeometry"
  },
  "client.viewstate.ViewState.getGeometry": {
    "id": "client.viewstate.ViewState.getGeometry",
    "name": "getGeometry",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/viewstate/ViewState.ts",
    "relative_path": "client/viewstate/ViewState.ts",
    "depends_on": [
      "client.viewstate.ViewState.Geometry",
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "function getGeometry(\n  kind: 'node' | 'group',\n  id: string,\n  viewState: ViewState\n): Geometry | undefined {\n  const store = kind === 'node' ? viewState.node : viewState.group;\n  return store?.[id];\n}",
    "start_line": 68,
    "end_line": 75,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "kind",
      "id",
      "viewState"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function getGeometry",
    "component_id": "client.viewstate.ViewState.getGeometry"
  },
  "client.viewstate.adjust.AdjustForReparentOptions": {
    "id": "client.viewstate.adjust.AdjustForReparentOptions",
    "name": "AdjustForReparentOptions",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/viewstate/adjust.ts",
    "relative_path": "client/viewstate/adjust.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState"
    ],
    "source_code": "interface AdjustForReparentOptions {\n  nodeId: string;\n  oldParentId: string;\n  newParentId: string;\n  viewState: ViewState;\n  /**\n   * Function to get the world position of a group (for computing relative positions)\n   */\n  getGroupWorldPos: (groupId: string) => { x: number; y: number } | undefined;\n}",
    "start_line": 11,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface AdjustForReparentOptions",
    "component_id": "client.viewstate.adjust.AdjustForReparentOptions"
  },
  "client.viewstate.adjust.adjustForReparent": {
    "id": "client.viewstate.adjust.adjustForReparent",
    "name": "adjustForReparent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/client/viewstate/adjust.ts",
    "relative_path": "client/viewstate/adjust.ts",
    "depends_on": [
      "client.viewstate.ViewState.ViewState",
      "client.viewstate.adjust.AdjustForReparentOptions",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "function adjustForReparent(options: AdjustForReparentOptions): ViewState {\n  const { nodeId, oldParentId, newParentId, viewState, getGroupWorldPos } = options;\n\n  // Get current node geometry\n  const nodeGeom = viewState.node?.[nodeId];\n  if (!nodeGeom) {\n    console.warn(`[adjustForReparent] Node \"${nodeId}\" has no geometry in ViewState`);\n    return viewState;\n  }\n\n  // Get world positions of old and new parents\n  const oldParentWorldPos = oldParentId === 'root' \n    ? { x: 0, y: 0 } \n    : getGroupWorldPos(oldParentId);\n  \n  const newParentWorldPos = newParentId === 'root'\n    ? { x: 0, y: 0 }\n    : getGroupWorldPos(newParentId);\n\n  if (!oldParentWorldPos || !newParentWorldPos) {\n    console.warn(\n      `[adjustForReparent] Cannot compute world positions for parents. ` +\n      `oldParent: ${oldParentId}, newParent: ${newParentId}`\n    );\n    return viewState;\n  }\n\n  // Compute node's world position\n  const nodeWorldX = oldParentWorldPos.x + nodeGeom.x;\n  const nodeWorldY = oldParentWorldPos.y + nodeGeom.y;\n\n  // Compute new relative position\n  const newRelativeX = nodeWorldX - newParentWorldPos.x;\n  const newRelativeY = nodeWorldY - newParentWorldPos.y;\n\n  // Update ViewState\n  const updated = {\n    ...viewState,\n    node: {\n      ...viewState.node,\n      [nodeId]: {\n        ...nodeGeom,\n        x: newRelativeX,\n        y: newRelativeY,\n      },\n    },\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.debug('[adjustForReparent] Preserved world position', {\n      nodeId,\n      oldParent: oldParentId,\n      newParent: newParentId,\n      worldPos: { x: nodeWorldX, y: nodeWorldY },\n      oldRelative: { x: nodeGeom.x, y: nodeGeom.y },\n      newRelative: { x: newRelativeX, y: newRelativeY },\n    });\n  }\n\n  return updated;\n}",
    "start_line": 35,
    "end_line": 95,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "options"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function adjustForReparent",
    "component_id": "client.viewstate.adjust.adjustForReparent"
  },
  "e2e.actual-canvas-test.test.lineIntersectsRect": {
    "id": "e2e.actual-canvas-test.test.lineIntersectsRect",
    "name": "lineIntersectsRect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/actual-canvas-test.test.ts",
    "relative_path": "e2e/actual-canvas-test.test.ts",
    "depends_on": [
      "e2e.actual-canvas-test.test.lineSegmentIntersectsRect"
    ],
    "source_code": "function lineIntersectsRect(start: {x: number, y: number}, end: {x: number, y: number}, rect: {x: number, y: number, width: number, height: number}): boolean {\n  // Simple bounding box check first\n  const lineMinX = Math.min(start.x, end.x);\n  const lineMaxX = Math.max(start.x, end.x);\n  const lineMinY = Math.min(start.y, end.y);\n  const lineMaxY = Math.max(start.y, end.y);\n  \n  const rectMaxX = rect.x + rect.width;\n  const rectMaxY = rect.y + rect.height;\n  \n  // If line bounding box doesn't overlap with rect, no intersection\n  if (lineMaxX < rect.x || lineMinX > rectMaxX || lineMaxY < rect.y || lineMinY > rectMaxY) {\n    return false;\n  }\n  \n  // Check if line passes through the interior of the rectangle (not just touching edges)\n  const margin = 2; // Small margin to avoid edge cases\n  const innerRect = {\n    x: rect.x + margin,\n    y: rect.y + margin,\n    width: rect.width - 2 * margin,\n    height: rect.height - 2 * margin\n  };\n  \n  if (innerRect.width <= 0 || innerRect.height <= 0) return false;\n  \n  // Check if line segment intersects with inner rectangle\n  return lineSegmentIntersectsRect(start, end, innerRect);\n}",
    "start_line": 239,
    "end_line": 267,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "start",
      "end",
      "rect"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lineIntersectsRect",
    "component_id": "e2e.actual-canvas-test.test.lineIntersectsRect"
  },
  "e2e.actual-canvas-test.test.lineSegmentIntersectsRect": {
    "id": "e2e.actual-canvas-test.test.lineSegmentIntersectsRect",
    "name": "lineSegmentIntersectsRect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/actual-canvas-test.test.ts",
    "relative_path": "e2e/actual-canvas-test.test.ts",
    "depends_on": [
      "e2e.actual-canvas-test.test.lineSegmentsIntersect"
    ],
    "source_code": "function lineSegmentIntersectsRect(start: {x: number, y: number}, end: {x: number, y: number}, rect: {x: number, y: number, width: number, height: number}): boolean {\n  const rectMaxX = rect.x + rect.width;\n  const rectMaxY = rect.y + rect.height;\n  \n  // Check intersection with each edge of the rectangle\n  return (\n    lineSegmentsIntersect(start, end, {x: rect.x, y: rect.y}, {x: rectMaxX, y: rect.y}) ||\n    lineSegmentsIntersect(start, end, {x: rectMaxX, y: rect.y}, {x: rectMaxX, y: rectMaxY}) ||\n    lineSegmentsIntersect(start, end, {x: rectMaxX, y: rectMaxY}, {x: rect.x, y: rectMaxY}) ||\n    lineSegmentsIntersect(start, end, {x: rect.x, y: rectMaxY}, {x: rect.x, y: rect.y})\n  );\n}",
    "start_line": 269,
    "end_line": 280,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "start",
      "end",
      "rect"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lineSegmentIntersectsRect",
    "component_id": "e2e.actual-canvas-test.test.lineSegmentIntersectsRect"
  },
  "e2e.actual-canvas-test.test.lineSegmentsIntersect": {
    "id": "e2e.actual-canvas-test.test.lineSegmentsIntersect",
    "name": "lineSegmentsIntersect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/actual-canvas-test.test.ts",
    "relative_path": "e2e/actual-canvas-test.test.ts",
    "depends_on": [],
    "source_code": "function lineSegmentsIntersect(p1: {x: number, y: number}, p2: {x: number, y: number}, p3: {x: number, y: number}, p4: {x: number, y: number}): boolean {\n  const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  if (Math.abs(denom) < 1e-10) return false; // Lines are parallel\n  \n  const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  \n  return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;\n}",
    "start_line": 282,
    "end_line": 290,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "p1",
      "p2",
      "p3",
      "p4"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lineSegmentsIntersect",
    "component_id": "e2e.actual-canvas-test.test.lineSegmentsIntersect"
  },
  "e2e.canvas-comprehensive.shared-utils.ensurePageReady": {
    "id": "e2e.canvas-comprehensive.shared-utils.ensurePageReady",
    "name": "ensurePageReady",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [],
    "source_code": "async function ensurePageReady(page: Page): Promise<void> {\n  // Check if window helpers are available - fail fast if not\n  const helpersAvailable = await page.evaluate(() => {\n    return typeof (window as any).getDomainGraph === 'function' && \n           typeof (window as any).getViewState === 'function';\n  });\n  \n  if (!helpersAvailable) {\n    throw new Error('‚ùå EARLY FAILURE: Window helpers (getDomainGraph/getViewState) not available. Page may not be fully loaded.');\n  }\n  \n  // Check if ReactFlow is ready\n  const reactFlowReady = await page.evaluate(() => {\n    return document.querySelector('.react-flow') !== null;\n  });\n  \n  if (!reactFlowReady) {\n    throw new Error('‚ùå EARLY FAILURE: ReactFlow canvas not found. Page may not be fully loaded.');\n  }\n}",
    "start_line": 8,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function ensurePageReady",
    "component_id": "e2e.canvas-comprehensive.shared-utils.ensurePageReady"
  },
  "e2e.canvas-comprehensive.shared-utils.ensureBoxToolAvailable": {
    "id": "e2e.canvas-comprehensive.shared-utils.ensureBoxToolAvailable",
    "name": "ensureBoxToolAvailable",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [],
    "source_code": "async function ensureBoxToolAvailable(page: Page): Promise<void> {\n  const boxToolExists = await page.evaluate(() => {\n    return document.querySelector('[title*=\"box\" i]') !== null;\n  });\n  \n  if (!boxToolExists) {\n    throw new Error('‚ùå EARLY FAILURE: Box tool button not found. Toolbar may not be loaded.');\n  }\n}",
    "start_line": 32,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function ensureBoxToolAvailable",
    "component_id": "e2e.canvas-comprehensive.shared-utils.ensureBoxToolAvailable"
  },
  "e2e.canvas-comprehensive.shared-utils.addNodeToCanvas": {
    "id": "e2e.canvas-comprehensive.shared-utils.addNodeToCanvas",
    "name": "addNodeToCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "e2e.canvas-comprehensive.shared-utils.ensurePageReady",
      "e2e.canvas-comprehensive.shared-utils.verifyLayerSync",
      "scripts.test-vercel-preview.error",
      "e2e.canvas-comprehensive.shared-utils.ensureBoxToolAvailable"
    ],
    "source_code": "async function addNodeToCanvas(page: Page, x: number, y: number): Promise<void> {\n  console.log(`üß™ Adding node at (${x}, ${y})`);\n  \n  // EARLY FAILURE: Check page is ready\n  await ensurePageReady(page);\n  \n  // Get initial counts\n  const initialSync = await verifyLayerSync(page);\n  console.log(`üìä Initial sync: canvas=${initialSync.canvasNodes}, domain=${initialSync.domainNodes}, viewState=${initialSync.viewStateNodes}`);\n  \n  // EARLY FAILURE: Check box tool is available\n  await ensureBoxToolAvailable(page);\n  \n  // CRITICAL: Always re-select box tool for each node (tool gets reset to 'arrow' after each use)\n  console.log('üîß Selecting box tool...');\n  \n  // Wait for window helper to be available\n  await page.waitForFunction(() => {\n    return typeof (window as any).handleToolSelect === 'function';\n  }, { timeout: 10000 });\n  \n  // Use window helper to select box tool (more reliable than clicking)\n  await page.evaluate(() => {\n    (window as any).handleToolSelect('box');\n  });\n  \n  // Wait for React state to update\n  await page.waitForTimeout(300);\n  \n  // Verify tool is selected\n  const currentTool = await page.evaluate(() => {\n    return (window as any).__selectedTool || 'unknown';\n  });\n  console.log(`üîß Current tool after selection: ${currentTool}`);\n  \n  if (currentTool !== 'box') {\n    throw new Error(`‚ùå EARLY FAILURE: Box tool not selected. Current tool: ${currentTool}`);\n  }\n  \n  // Click on the ReactFlow pane (not the container) - this triggers onPaneClick\n  const paneLocator = page.locator('.react-flow__pane');\n  await paneLocator.waitFor({ state: 'visible', timeout: 5000 });\n  \n  // Get console messages before click\n  const consoleLogs: string[] = [];\n  page.on('console', msg => {\n    const text = msg.text();\n    consoleLogs.push(`[${msg.type()}] ${text}`);\n    // Log placeNodeOnCanvas messages immediately\n    if (text.includes('placeNodeOnCanvas')) {\n      console.log(`üìã [placeNodeOnCanvas] ${text}`);\n    }\n  });\n  \n  await paneLocator.click({ position: { x, y }, timeout: 5000 });\n  console.log(`üñ±Ô∏è Clicked canvas pane at (${x}, ${y})`);\n  \n  // Wait and print console logs\n  await page.waitForTimeout(500);\n  const relevantLogs = consoleLogs.filter(l => l.includes('place') || l.includes('node') || l.includes('onPaneClick') || l.includes('Canvas'));\n  if (relevantLogs.length > 0) {\n    console.log('üìã Browser console:', relevantLogs.slice(-15).join('\\n'));\n  }\n  \n  // Wait for \"Generating...\" to appear and disappear (indicates domain processing)\n  try {\n    await page.waitForSelector('text=Generating...', { timeout: 3000 });\n    console.log('‚è≥ \"Generating...\" appeared');\n    await page.waitForSelector('text=Generating...', { state: 'hidden', timeout: 15000 });\n    console.log('‚úÖ \"Generating...\" disappeared');\n  } catch (e) {\n    console.log('‚ö†Ô∏è No \"Generating...\" found, continuing...');\n    await page.waitForTimeout(2000);\n  }\n  \n  // Finish editing if node is in edit mode\n  await page.keyboard.press('Escape');\n  await page.waitForTimeout(500);\n  \n  // Wait for domain to be updated - with EARLY FAILURE timeout\n  try {\n    await page.waitForFunction((expectedDomainCount) => {\n      const domain = (window as any).getDomainGraph?.() || { children: [] };\n      const currentCount = domain.children?.length || 0;\n      console.log(`üîç Domain check: current=${currentCount}, expected>=${expectedDomainCount}`);\n      return currentCount >= expectedDomainCount;\n    }, initialSync.domainNodes + 1, { timeout: 8000 }); // Reduced from 10000 to 8000 for faster failure\n    console.log('‚úÖ Domain updated successfully');\n  } catch (e: any) {\n    console.error('‚ùå Domain update timeout:', e.message);\n    // Get final state for debugging\n    const finalSync = await verifyLayerSync(page);\n    console.log(`üìä Final sync after timeout: canvas=${finalSync.canvasNodes}, domain=${finalSync.domainNodes}`);\n    throw new Error(`‚ùå EARLY FAILURE: Domain not updated. Expected >=${initialSync.domainNodes + 1}, got ${finalSync.domainNodes}. Canvas=${finalSync.canvasNodes}`);\n  }\n  \n  // Wait for canvas to sync with domain (nodes to render)\n  try {\n    await page.waitForFunction((expectedCanvasCount) => {\n      const canvasNodes = document.querySelectorAll('.react-flow__node').length;\n      return canvasNodes >= expectedCanvasCount;\n    }, initialSync.domainNodes + 1, { timeout: 5000 });\n    console.log('‚úÖ Canvas synced with domain');\n  } catch (e) {\n    console.log('‚ö†Ô∏è Canvas sync timeout, continuing...');\n  }\n  \n  // Additional wait for stability\n  await page.waitForTimeout(300);\n}",
    "start_line": 42,
    "end_line": 151,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page",
      "x",
      "y"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function addNodeToCanvas",
    "component_id": "e2e.canvas-comprehensive.shared-utils.addNodeToCanvas"
  },
  "e2e.canvas-comprehensive.shared-utils.verifyLayerSync": {
    "id": "e2e.canvas-comprehensive.shared-utils.verifyLayerSync",
    "name": "verifyLayerSync",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [],
    "source_code": "async function verifyLayerSync(page: Page): Promise<{ canvasNodes: number, domainNodes: number, viewStateNodes: number, inSync: boolean }> {\n  const canvasNodes = await page.locator('.react-flow__node').count();\n  \n  // EARLY FAILURE: Check helpers are available\n  const helpersAvailable = await page.evaluate(() => {\n    return typeof (window as any).getDomainGraph === 'function' && \n           typeof (window as any).getViewState === 'function';\n  });\n  \n  if (!helpersAvailable) {\n    throw new Error('‚ùå EARLY FAILURE: Window helpers not available in verifyLayerSync');\n  }\n  \n  const result = await page.evaluate(() => {\n    const domain = (window as any).getDomainGraph?.() || { children: [] };\n    const viewState = (window as any).getViewState?.() || { node: {}, group: {}, edge: {} };\n    const domainCount = domain.children?.length || 0;\n    const viewStateCount = Object.keys(viewState.node || {}).length;\n    \n    return {\n      domainNodes: domainCount,\n      viewStateNodes: viewStateCount,\n    };\n  });\n  \n  return { \n    canvasNodes, \n    domainNodes: result.domainNodes, \n    viewStateNodes: result.viewStateNodes,\n    inSync: canvasNodes === result.domainNodes && canvasNodes === result.viewStateNodes\n  };\n}",
    "start_line": 153,
    "end_line": 184,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function verifyLayerSync",
    "component_id": "e2e.canvas-comprehensive.shared-utils.verifyLayerSync"
  },
  "e2e.canvas-comprehensive.shared-utils.verifyPersistence": {
    "id": "e2e.canvas-comprehensive.shared-utils.verifyPersistence",
    "name": "verifyPersistence",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [],
    "source_code": "async function verifyPersistence(page: Page): Promise<void> {\n  await page.reload();\n  \n  // EARLY FAILURE: Fast timeout for ReactFlow to appear\n  await page.waitForSelector('.react-flow', { timeout: 10000 });\n  \n  // EARLY FAILURE: Check helpers are available after reload\n  const helpersAvailable = await page.waitForFunction(() => {\n    return typeof (window as any).getDomainGraph === 'function' && \n           typeof (window as any).getViewState === 'function';\n  }, { timeout: 5000 }).catch(() => null);\n  \n  if (!helpersAvailable) {\n    throw new Error('‚ùå EARLY FAILURE: Window helpers not available after page reload');\n  }\n  \n  await page.waitForTimeout(1000); // Brief wait for restoration\n}",
    "start_line": 186,
    "end_line": 203,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function verifyPersistence",
    "component_id": "e2e.canvas-comprehensive.shared-utils.verifyPersistence"
  },
  "e2e.canvas-comprehensive.shared-utils.checkArchitectureCompliance": {
    "id": "e2e.canvas-comprehensive.shared-utils.checkArchitectureCompliance",
    "name": "checkArchitectureCompliance",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [],
    "source_code": "async function checkArchitectureCompliance(page: Page): Promise<string[]> {\n  const violations: string[] = [];\n  \n  // Check if Domain has mode fields (violation)\n  const domainHasMode = await page.evaluate(() => {\n    const domain = (window as any).getDomainGraph?.() || { children: [] };\n    const hasModeFields = (node: any): boolean => {\n      if (node.mode === 'FREE' || node.mode === 'LOCK') return true;\n      if (node.children) return node.children.some((child: any) => hasModeFields(child));\n      return false;\n    };\n    return hasModeFields(domain);\n  });\n  \n  if (domainHasMode) {\n    violations.push('Domain contains mode fields (should be in ViewState.layout)');\n  }\n  \n  return violations;\n}",
    "start_line": 205,
    "end_line": 224,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function checkArchitectureCompliance",
    "component_id": "e2e.canvas-comprehensive.shared-utils.checkArchitectureCompliance"
  },
  "e2e.canvas-comprehensive.shared-utils.setupCleanCanvas": {
    "id": "e2e.canvas-comprehensive.shared-utils.setupCleanCanvas",
    "name": "setupCleanCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [
      "e2e.canvas-comprehensive.shared-utils.verifyLayerSync",
      "e2e.canvas-comprehensive.shared-utils.ensurePageReady"
    ],
    "source_code": "async function setupCleanCanvas(page: Page): Promise<void> {\n  await page.goto(baseURL);\n  \n  // EARLY FAILURE: Fast timeout checks\n  await page.waitForSelector('.react-flow', { timeout: 10000 });\n  await page.waitForSelector('.react-flow__pane', { timeout: 10000 });\n  \n  // Clear any existing state\n  await page.evaluate(() => {\n    localStorage.clear();\n    sessionStorage.clear();\n    if ((window as any).resetCanvas) {\n      (window as any).resetCanvas();\n    }\n  });\n  \n  // Wait for any re-renders after clearing storage\n  await page.waitForTimeout(500);\n  \n  // Reload to ensure clean state after reset\n  await page.reload();\n  await page.waitForSelector('.react-flow', { timeout: 10000 });\n  await page.waitForTimeout(500);\n  \n  // EARLY FAILURE: Verify helpers available after clear\n  await ensurePageReady(page);\n  \n  // Wait for toolbar to be stable before proceeding\n  await page.waitForSelector('[title*=\"box\" i]', { timeout: 10000 });\n  await page.waitForTimeout(300); // Brief wait for any animations\n  \n  // EARLY FAILURE: Verify canvas is actually empty\n  const sync = await verifyLayerSync(page);\n  if (sync.canvasNodes !== 0 || sync.domainNodes !== 0) {\n    throw new Error(`‚ùå EARLY FAILURE: Canvas not clean after setup. Canvas nodes: ${sync.canvasNodes}, Domain nodes: ${sync.domainNodes}`);\n  }\n}",
    "start_line": 226,
    "end_line": 262,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function setupCleanCanvas",
    "component_id": "e2e.canvas-comprehensive.shared-utils.setupCleanCanvas"
  },
  "e2e.canvas-comprehensive.shared-utils.findParent": {
    "id": "e2e.canvas-comprehensive.shared-utils.findParent",
    "name": "findParent",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-comprehensive/shared-utils.ts",
    "relative_path": "e2e/canvas-comprehensive/shared-utils.ts",
    "depends_on": [
      "e2e.canvas-comprehensive.shared-utils.findParent"
    ],
    "source_code": "function findParent(graph: any, nodeId: string, parentId = 'root'): string | null {\n  if (!graph.children) return null;\n  for (const child of graph.children) {\n    if (child.id === nodeId) return parentId;\n    const found = findParent(child, nodeId, child.id);\n    if (found) return found;\n  }\n  return null;\n}",
    "start_line": 264,
    "end_line": 272,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "graph",
      "nodeId",
      "parentId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function findParent",
    "component_id": "e2e.canvas-comprehensive.shared-utils.findParent"
  },
  "e2e.canvas-free-mode-behavior.test.NodeSnapshot": {
    "id": "e2e.canvas-free-mode-behavior.test.NodeSnapshot",
    "name": "NodeSnapshot",
    "component_type": "interface",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [],
    "source_code": "interface NodeSnapshot {\n  id: string;\n  rect: { x: number; y: number; width: number; height: number };\n}",
    "start_line": 11,
    "end_line": 14,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "interface",
    "base_classes": [],
    "class_name": null,
    "display_name": "interface NodeSnapshot",
    "component_id": "e2e.canvas-free-mode-behavior.test.NodeSnapshot"
  },
  "e2e.canvas-free-mode-behavior.test.goToCanvas": {
    "id": "e2e.canvas-free-mode-behavior.test.goToCanvas",
    "name": "goToCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [],
    "source_code": "async function goToCanvas(page: Page) {\n  await page.goto(baseURL);\n  await page.waitForLoadState('domcontentloaded', { timeout: 15000 });\n  await page.waitForSelector(\".react-flow__pane\", { timeout: 20000 });\n}",
    "start_line": 16,
    "end_line": 20,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function goToCanvas",
    "component_id": "e2e.canvas-free-mode-behavior.test.goToCanvas"
  },
  "e2e.canvas-free-mode-behavior.test.getNodeSnapshots": {
    "id": "e2e.canvas-free-mode-behavior.test.getNodeSnapshots",
    "name": "getNodeSnapshots",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [
      "e2e.canvas-free-mode-behavior.test.NodeSnapshot"
    ],
    "source_code": "async function getNodeSnapshots(page: Page): Promise<NodeSnapshot[]> {\n  return page.evaluate(() => {\n    return Array.from(document.querySelectorAll('.react-flow__node')).map((el) => {\n      const rect = el.getBoundingClientRect();\n      return {\n        id: el.getAttribute('data-id') || '',\n        rect: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },\n      };\n    });\n  });\n}",
    "start_line": 22,
    "end_line": 32,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getNodeSnapshots",
    "component_id": "e2e.canvas-free-mode-behavior.test.getNodeSnapshots"
  },
  "e2e.canvas-free-mode-behavior.test.centerOf": {
    "id": "e2e.canvas-free-mode-behavior.test.centerOf",
    "name": "centerOf",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [],
    "source_code": "function centerOf(rect: { x: number; y: number; width: number; height: number }) {\n  return { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };\n}",
    "start_line": 34,
    "end_line": 36,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "rect"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function centerOf",
    "component_id": "e2e.canvas-free-mode-behavior.test.centerOf"
  },
  "e2e.canvas-free-mode-behavior.test.computeCanvasPoint": {
    "id": "e2e.canvas-free-mode-behavior.test.computeCanvasPoint",
    "name": "computeCanvasPoint",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [],
    "source_code": "function computeCanvasPoint(paneBox: DOMRect, relative: { x: number; y: number }) {\n  return { x: paneBox.x + relative.x, y: paneBox.y + relative.y };\n}",
    "start_line": 38,
    "end_line": 40,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "paneBox",
      "relative"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function computeCanvasPoint",
    "component_id": "e2e.canvas-free-mode-behavior.test.computeCanvasPoint"
  },
  "e2e.canvas-free-mode-behavior.test.candidateRelativePositions": {
    "id": "e2e.canvas-free-mode-behavior.test.candidateRelativePositions",
    "name": "candidateRelativePositions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [],
    "source_code": "function candidateRelativePositions(paneBox: DOMRect, fractions: Array<[number, number]>) {\n  return fractions.map(([fx, fy]) => ({ x: paneBox.width * fx, y: paneBox.height * fy }));\n}",
    "start_line": 42,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "paneBox",
      "fractions"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function candidateRelativePositions",
    "component_id": "e2e.canvas-free-mode-behavior.test.candidateRelativePositions"
  },
  "e2e.canvas-free-mode-behavior.test.distance": {
    "id": "e2e.canvas-free-mode-behavior.test.distance",
    "name": "distance",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [],
    "source_code": "function distance(a: { x: number; y: number }, b: { x: number; y: number }) {\n  return Math.hypot(a.x - b.x, a.y - b.y);\n}",
    "start_line": 46,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "a",
      "b"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function distance",
    "component_id": "e2e.canvas-free-mode-behavior.test.distance"
  },
  "e2e.canvas-free-mode-behavior.test.pickEmptyCanvasPoint": {
    "id": "e2e.canvas-free-mode-behavior.test.pickEmptyCanvasPoint",
    "name": "pickEmptyCanvasPoint",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [
      "e2e.canvas-free-mode-behavior.test.candidateRelativePositions",
      "e2e.canvas-free-mode-behavior.test.NodeSnapshot",
      "e2e.canvas-free-mode-behavior.test.computeCanvasPoint",
      "e2e.canvas-free-mode-behavior.test.centerOf",
      "e2e.canvas-free-mode-behavior.test.distance"
    ],
    "source_code": "function pickEmptyCanvasPoint(\n  snapshots: NodeSnapshot[],\n  paneBox: DOMRect,\n  candidateFractions: Array<[number, number]>,\n  minSpacing: number,\n) {\n  const centers = snapshots.map((node) => centerOf(node.rect));\n  const candidates = candidateRelativePositions(paneBox, candidateFractions);\n\n  for (const relative of candidates) {\n    const absolute = computeCanvasPoint(paneBox, relative);\n    const farEnough = centers.every((existing) => distance(existing, absolute) > minSpacing);\n    if (farEnough) {\n      return { relative, absolute };\n    }\n  }\n\n  const fallbackRelative = candidates[candidates.length - 1];\n  return { relative: fallbackRelative, absolute: computeCanvasPoint(paneBox, fallbackRelative) };\n}",
    "start_line": 50,
    "end_line": 69,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "snapshots",
      "paneBox",
      "candidateFractions",
      "minSpacing"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function pickEmptyCanvasPoint",
    "component_id": "e2e.canvas-free-mode-behavior.test.pickEmptyCanvasPoint"
  },
  "e2e.canvas-free-mode-behavior.test.waitForNodeNear": {
    "id": "e2e.canvas-free-mode-behavior.test.waitForNodeNear",
    "name": "waitForNodeNear",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [
      "e2e.canvas-free-mode-behavior.test.NodeSnapshot"
    ],
    "source_code": "async function waitForNodeNear(\n  page: Page,\n  point: { x: number; y: number },\n  tolerance = 160,\n  timeout = 15000,\n): Promise<NodeSnapshot> {\n  const handle = await page.waitForFunction(\n    ({ x, y, tolerance }) => {\n      const nodes = Array.from(document.querySelectorAll('.react-flow__node'));\n      for (const el of nodes) {\n        const rect = el.getBoundingClientRect();\n        const centerX = rect.x + rect.width / 2;\n        const centerY = rect.y + rect.height / 2;\n        if (Math.abs(centerX - x) <= tolerance && Math.abs(centerY - y) <= tolerance) {\n          return {\n            id: el.getAttribute('data-id') || '',\n            rect: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },\n          };\n        }\n      }\n      return null;\n    },\n    { x: point.x, y: point.y, tolerance },\n    { timeout },\n  );\n  return await handle.jsonValue();\n}",
    "start_line": 71,
    "end_line": 97,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page",
      "point",
      "tolerance",
      "timeout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function waitForNodeNear",
    "component_id": "e2e.canvas-free-mode-behavior.test.waitForNodeNear"
  },
  "e2e.canvas-free-mode-behavior.test.findNodeNear": {
    "id": "e2e.canvas-free-mode-behavior.test.findNodeNear",
    "name": "findNodeNear",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [
      "e2e.canvas-free-mode-behavior.test.NodeSnapshot"
    ],
    "source_code": "async function findNodeNear(\n  page: Page,\n  point: { x: number; y: number },\n  tolerance = 64,\n): Promise<NodeSnapshot | null> {\n  return page.evaluate(({ x, y, tolerance }) => {\n    const nodes = Array.from(document.querySelectorAll('.react-flow__node'));\n    for (const el of nodes) {\n      const rect = el.getBoundingClientRect();\n      const centerX = rect.x + rect.width / 2;\n      const centerY = rect.y + rect.height / 2;\n      if (Math.abs(centerX - x) <= tolerance && Math.abs(centerY - y) <= tolerance) {\n        return {\n          id: el.getAttribute('data-id') || '',\n          rect: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },\n        };\n      }\n    }\n    return null;\n  }, { x: point.x, y: point.y, tolerance });\n}",
    "start_line": 99,
    "end_line": 119,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page",
      "point",
      "tolerance"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function findNodeNear",
    "component_id": "e2e.canvas-free-mode-behavior.test.findNodeNear"
  },
  "e2e.canvas-free-mode-behavior.test.createUserNode": {
    "id": "e2e.canvas-free-mode-behavior.test.createUserNode",
    "name": "createUserNode",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-free-mode-behavior.test.ts",
    "relative_path": "e2e/canvas-free-mode-behavior.test.ts",
    "depends_on": [
      "e2e.canvas-free-mode-behavior.test.computeCanvasPoint",
      "e2e.canvas-free-mode-behavior.test.waitForNodeNear"
    ],
    "source_code": "async function createUserNode(\n  page: Page,\n  pane: Locator,\n  paneBox: DOMRect,\n  relative: { x: number; y: number },\n) {\n  await page.click('button[aria-label=\"Add box (R)\"]', { timeout: 5000 });\n  const clickPoint = computeCanvasPoint(paneBox, relative);\n  await pane.click({ position: relative });\n  const node = await waitForNodeNear(page, clickPoint, 120);\n  return { node, clickPoint };\n}",
    "start_line": 121,
    "end_line": 132,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page",
      "pane",
      "paneBox",
      "relative"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function createUserNode",
    "component_id": "e2e.canvas-free-mode-behavior.test.createUserNode"
  },
  "e2e.canvas-real-browser.test.waitForCanvas": {
    "id": "e2e.canvas-real-browser.test.waitForCanvas",
    "name": "waitForCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "async function waitForCanvas(page: Page) {\n  // Wait for page to be fully loaded\n  await page.waitForLoadState('networkidle');\n  \n  // Wait for React Flow canvas - try multiple selectors\n  const selectors = ['.react-flow', '.react-flow__renderer', '[class*=\"react-flow\"]'];\n  let found = false;\n  \n  for (const selector of selectors) {\n    try {\n      await page.waitForSelector(selector, { timeout: 5000 });\n      console.log(`‚úÖ Found canvas with selector: ${selector}`);\n      found = true;\n      break;\n    } catch (e) {\n      console.log(`‚ùå Selector ${selector} not found`);\n    }\n  }\n  \n  if (!found) {\n    // Take screenshot for debugging\n    await page.screenshot({ path: 'canvas-not-found.png' });\n    throw new Error('Canvas not found with any selector');\n  }\n  \n  // Wait for canvas to stabilize\n  await page.waitForTimeout(2000);\n}",
    "start_line": 12,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function waitForCanvas",
    "component_id": "e2e.canvas-real-browser.test.waitForCanvas"
  },
  "e2e.canvas-real-browser.test.getCanvasNodes": {
    "id": "e2e.canvas-real-browser.test.getCanvasNodes",
    "name": "getCanvasNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [],
    "source_code": "async function getCanvasNodes(page: Page) {\n  return await page.locator('.react-flow__node').all();\n}",
    "start_line": 41,
    "end_line": 43,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getCanvasNodes",
    "component_id": "e2e.canvas-real-browser.test.getCanvasNodes"
  },
  "e2e.canvas-real-browser.test.getNodeCount": {
    "id": "e2e.canvas-real-browser.test.getNodeCount",
    "name": "getNodeCount",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [
      "e2e.canvas-real-browser.test.getCanvasNodes"
    ],
    "source_code": "async function getNodeCount(page: Page): Promise<number> {\n  const nodes = await getCanvasNodes(page);\n  return nodes.length;\n}",
    "start_line": 45,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getNodeCount",
    "component_id": "e2e.canvas-real-browser.test.getNodeCount"
  },
  "e2e.canvas-real-browser.test.getNodePositions": {
    "id": "e2e.canvas-real-browser.test.getNodePositions",
    "name": "getNodePositions",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [
      "e2e.canvas-real-browser.test.getCanvasNodes"
    ],
    "source_code": "async function getNodePositions(page: Page): Promise<Array<{id: string, x: number, y: number}>> {\n  const nodes = await getCanvasNodes(page);\n  const positions = [];\n  \n  for (const node of nodes) {\n    const id = await node.getAttribute('data-id') || 'unknown';\n    const transform = await node.evaluate(el => el.style.transform);\n    \n    // Parse transform: translate(123px, 456px)\n    const match = transform.match(/translate\\(([^,]+),\\s*([^)]+)\\)/);\n    if (match) {\n      const x = parseFloat(match[1]);\n      const y = parseFloat(match[2]);\n      positions.push({ id, x, y });\n    }\n  }\n  \n  return positions;\n}",
    "start_line": 50,
    "end_line": 68,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getNodePositions",
    "component_id": "e2e.canvas-real-browser.test.getNodePositions"
  },
  "e2e.canvas-real-browser.test.selectBoxTool": {
    "id": "e2e.canvas-real-browser.test.selectBoxTool",
    "name": "selectBoxTool",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function selectBoxTool(page: Page) {\n  // Try multiple selectors for the box tool\n  const selectors = [\n    '[data-testid=\"tool-box\"]',\n    '[title*=\"box\" i]',\n    '[aria-label*=\"box\" i]',\n    'button:has-text(\"Box\")',\n    '.tool-button:has-text(\"‚ñ°\")'\n  ];\n  \n  for (const selector of selectors) {\n    try {\n      await page.click(selector, { timeout: 2000 });\n      console.log(`‚úÖ Selected box tool with selector: ${selector}`);\n      return;\n    } catch (e) {\n      // Try next selector\n    }\n  }\n  \n  console.warn('‚ö†Ô∏è Could not find box tool, proceeding anyway');\n}",
    "start_line": 70,
    "end_line": 91,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function selectBoxTool",
    "component_id": "e2e.canvas-real-browser.test.selectBoxTool"
  },
  "e2e.canvas-real-browser.test.addNodeToCanvas": {
    "id": "e2e.canvas-real-browser.test.addNodeToCanvas",
    "name": "addNodeToCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "e2e.canvas-real-browser.test.selectBoxTool"
    ],
    "source_code": "async function addNodeToCanvas(page: Page, x: number, y: number) {\n  // CRITICAL: Always re-select the box tool for each node\n  await selectBoxTool(page);\n  \n  // Click on canvas to add node - try multiple selectors\n  const selectors = ['.react-flow', '.react-flow__renderer', '[class*=\"react-flow\"]'];\n  let clicked = false;\n  \n  for (const selector of selectors) {\n    try {\n      const canvas = page.locator(selector);\n      await canvas.click({ position: { x, y }, timeout: 2000 });\n      console.log(`‚úÖ Clicked canvas with selector: ${selector}`);\n      clicked = true;\n      break;\n    } catch (e) {\n      console.log(`‚ùå Could not click with selector: ${selector}`);\n    }\n  }\n  \n  if (!clicked) {\n    throw new Error('Could not click on canvas with any selector');\n  }\n  \n  // Wait for \"Generating...\" to appear and disappear (indicates processing)\n  try {\n    await page.waitForText('Generating...', { timeout: 2000 });\n    await page.waitForFunction(() => !document.body.textContent?.includes('Generating...'), { timeout: 10000 });\n  } catch (e) {\n    console.log('‚ö†Ô∏è No \"Generating...\" detected, continuing...');\n  }\n  \n  // Wait for domain to be updated (critical for layer sync)\n  const initialDomainCount = await page.evaluate(() => {\n    const domainGraph = (window as any).getDomainGraph?.() || { children: [] };\n    return domainGraph.children?.length || 0;\n  });\n  \n  await page.waitForFunction((expectedCount) => {\n    const domainGraph = (window as any).getDomainGraph?.() || { children: [] };\n    return domainGraph.children?.length >= expectedCount;\n  }, initialDomainCount + 1, { timeout: 10000 });\n  \n  // Finish editing if node is in edit mode\n  await page.keyboard.press('Escape');\n  await page.waitForTimeout(500);\n}",
    "start_line": 93,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page",
      "x",
      "y"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function addNodeToCanvas",
    "component_id": "e2e.canvas-real-browser.test.addNodeToCanvas"
  },
  "e2e.canvas-real-browser.test.deleteSelectedNodes": {
    "id": "e2e.canvas-real-browser.test.deleteSelectedNodes",
    "name": "deleteSelectedNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [],
    "source_code": "async function deleteSelectedNodes(page: Page) {\n  await page.keyboard.press('Delete');\n  await page.waitForTimeout(500);\n}",
    "start_line": 141,
    "end_line": 144,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function deleteSelectedNodes",
    "component_id": "e2e.canvas-real-browser.test.deleteSelectedNodes"
  },
  "e2e.canvas-real-browser.test.selectAllNodes": {
    "id": "e2e.canvas-real-browser.test.selectAllNodes",
    "name": "selectAllNodes",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [],
    "source_code": "async function selectAllNodes(page: Page) {\n  // Try Ctrl+A to select all\n  await page.keyboard.press('Control+a');\n  await page.waitForTimeout(300);\n}",
    "start_line": 146,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function selectAllNodes",
    "component_id": "e2e.canvas-real-browser.test.selectAllNodes"
  },
  "e2e.canvas-real-browser.test.clearLocalStorage": {
    "id": "e2e.canvas-real-browser.test.clearLocalStorage",
    "name": "clearLocalStorage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function clearLocalStorage(page: Page) {\n  try {\n    await page.evaluate(() => {\n      if (typeof localStorage !== 'undefined') {\n        localStorage.clear();\n      }\n      if (typeof sessionStorage !== 'undefined') {\n        sessionStorage.clear();\n      }\n    });\n  } catch (error) {\n    console.warn('Could not clear localStorage:', error);\n  }\n}",
    "start_line": 152,
    "end_line": 165,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function clearLocalStorage",
    "component_id": "e2e.canvas-real-browser.test.clearLocalStorage"
  },
  "e2e.canvas-real-browser.test.getLocalStorageSnapshot": {
    "id": "e2e.canvas-real-browser.test.getLocalStorageSnapshot",
    "name": "getLocalStorageSnapshot",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function getLocalStorageSnapshot(page: Page) {\n  try {\n    return await page.evaluate(() => {\n      if (typeof localStorage !== 'undefined') {\n        return localStorage.getItem('atelier_canvas_last_snapshot_v1');\n      }\n      return null;\n    });\n  } catch (error) {\n    console.warn('Could not access localStorage:', error);\n    return null;\n  }\n}",
    "start_line": 167,
    "end_line": 179,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getLocalStorageSnapshot",
    "component_id": "e2e.canvas-real-browser.test.getLocalStorageSnapshot"
  },
  "e2e.canvas-real-browser.test.callResetCanvas": {
    "id": "e2e.canvas-real-browser.test.callResetCanvas",
    "name": "callResetCanvas",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/canvas-real-browser.test.ts",
    "relative_path": "e2e/canvas-real-browser.test.ts",
    "depends_on": [],
    "source_code": "async function callResetCanvas(page: Page) {\n  await page.evaluate(() => {\n    (window as any).resetCanvas?.();\n  });\n  await page.waitForTimeout(1000);\n}",
    "start_line": 181,
    "end_line": 186,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "page"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function callResetCanvas",
    "component_id": "e2e.canvas-real-browser.test.callResetCanvas"
  },
  "e2e.libavoid-edge-creation.test.lineSegmentIntersectsRect": {
    "id": "e2e.libavoid-edge-creation.test.lineSegmentIntersectsRect",
    "name": "lineSegmentIntersectsRect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/libavoid-edge-creation.test.ts",
    "relative_path": "e2e/libavoid-edge-creation.test.ts",
    "depends_on": [
      "e2e.libavoid-edge-creation.test.lineSegmentsIntersect"
    ],
    "source_code": "function lineSegmentIntersectsRect(\n  start: { x: number; y: number },\n  end: { x: number; y: number },\n  rect: { x: number; y: number; width: number; height: number }\n): boolean {\n  const rectMaxX = rect.x + rect.width;\n  const rectMaxY = rect.y + rect.height;\n  \n  // Check intersection with each edge of the rectangle\n  return (\n    lineSegmentsIntersect(start, end, { x: rect.x, y: rect.y }, { x: rectMaxX, y: rect.y }) ||\n    lineSegmentsIntersect(start, end, { x: rectMaxX, y: rect.y }, { x: rectMaxX, y: rectMaxY }) ||\n    lineSegmentsIntersect(start, end, { x: rectMaxX, y: rectMaxY }, { x: rect.x, y: rectMaxY }) ||\n    lineSegmentsIntersect(start, end, { x: rect.x, y: rectMaxY }, { x: rect.x, y: rect.y })\n  );\n}",
    "start_line": 265,
    "end_line": 280,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "start",
      "end",
      "rect"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lineSegmentIntersectsRect",
    "component_id": "e2e.libavoid-edge-creation.test.lineSegmentIntersectsRect"
  },
  "e2e.libavoid-edge-creation.test.lineSegmentsIntersect": {
    "id": "e2e.libavoid-edge-creation.test.lineSegmentsIntersect",
    "name": "lineSegmentsIntersect",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/libavoid-edge-creation.test.ts",
    "relative_path": "e2e/libavoid-edge-creation.test.ts",
    "depends_on": [],
    "source_code": "function lineSegmentsIntersect(\n  p1: { x: number; y: number },\n  p2: { x: number; y: number },\n  p3: { x: number; y: number },\n  p4: { x: number; y: number }\n): boolean {\n  const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  if (Math.abs(denom) < 1e-10) return false; // Lines are parallel\n  \n  const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  \n  return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;\n}",
    "start_line": 282,
    "end_line": 295,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "p1",
      "p2",
      "p3",
      "p4"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lineSegmentsIntersect",
    "component_id": "e2e.libavoid-edge-creation.test.lineSegmentsIntersect"
  },
  "e2e.test-config.getBaseUrl": {
    "id": "e2e.test-config.getBaseUrl",
    "name": "getBaseUrl",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/test-config.js",
    "relative_path": "e2e/test-config.js",
    "depends_on": [
      "scripts.find-server-port.findRunningServerPort",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function getBaseUrl() {\n    if (process.env.E2E_BASE_URL) {\n        return process.env.E2E_BASE_URL;\n    }\n    \n    try {\n        const port = await findRunningServerPort();\n        return `http://localhost:${port}`;\n    } catch (error) {\n        console.warn(`‚ö†Ô∏è  Could not detect running server: ${error.message}`);\n        console.warn('   Falling back to default port 3000');\n        return 'http://localhost:3000';\n    }\n}",
    "start_line": 14,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getBaseUrl",
    "component_id": "e2e.test-config.getBaseUrl"
  },
  "e2e.test-config.setupTestConfig": {
    "id": "e2e.test-config.setupTestConfig",
    "name": "setupTestConfig",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/e2e/test-config.js",
    "relative_path": "e2e/test-config.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "e2e.test-config.getBaseUrl"
    ],
    "source_code": "async function setupTestConfig() {\n    const baseUrl = await getBaseUrl();\n    console.log(`üåê E2E tests using base URL: ${baseUrl}`);\n    return { baseUrl };\n}",
    "start_line": 33,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function setupTestConfig",
    "component_id": "e2e.test-config.setupTestConfig"
  },
  "pages.auth.AuthPage": {
    "id": "pages.auth.AuthPage",
    "name": "AuthPage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/pages/auth.jsx",
    "relative_path": "pages/auth.jsx",
    "depends_on": [],
    "source_code": "function AuthPage() {\n  return (\n    <ViewModeProvider fallbackMode=\"auth\">\n      <CanvasAdapterProvider>\n      <App />\n      </CanvasAdapterProvider>\n    </ViewModeProvider>\n  );\n}",
    "start_line": 10,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function AuthPage",
    "component_id": "pages.auth.AuthPage"
  },
  "pages.canvas.CanvasPage": {
    "id": "pages.canvas.CanvasPage",
    "name": "CanvasPage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/pages/canvas.jsx",
    "relative_path": "pages/canvas.jsx",
    "depends_on": [],
    "source_code": "function CanvasPage() {\n  return (\n    <div style={{ width: '100vw', height: '100vh', margin: 0, padding: 0 }}>\n      <ApiEndpointProvider>\n        <ViewModeProvider fallbackMode=\"canvas\">\n          <CanvasAdapterProvider>\n          <App />\n          </CanvasAdapterProvider>\n        </ViewModeProvider>\n      </ApiEndpointProvider>\n    </div>\n  );\n}",
    "start_line": 11,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function CanvasPage",
    "component_id": "pages.canvas.CanvasPage"
  },
  "pages.embed.EmbedPage": {
    "id": "pages.embed.EmbedPage",
    "name": "EmbedPage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/pages/embed.jsx",
    "relative_path": "pages/embed.jsx",
    "depends_on": [],
    "source_code": "function EmbedPage() {\n  return (\n    <div style={{ width: '100vw', height: '100vh', margin: 0, padding: 0 }}>\n      <FramerEmbeddable \n        apiEndpoint={process.env.NODE_ENV === 'development' ? 'http://localhost:3000' : 'https://atelier-hr1fy8lrc-shreyaspatel031s-projects.vercel.app'}\n        width=\"100%\"\n        height=\"100vh\"\n      />\n    </div>\n  );\n}",
    "start_line": 9,
    "end_line": 19,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function EmbedPage",
    "component_id": "pages.embed.EmbedPage"
  },
  "pages.index.IndexPage": {
    "id": "pages.index.IndexPage",
    "name": "IndexPage",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/pages/index.jsx",
    "relative_path": "pages/index.jsx",
    "depends_on": [],
    "source_code": "function IndexPage() {\n  return (\n    <div style={{ width: '100vw', height: '100vh', margin: 0, padding: 0 }}>\n      <ApiEndpointProvider>\n        <ViewModeProvider fallbackMode=\"canvas\">\n          <CanvasAdapterProvider>\n          <App />\n          </CanvasAdapterProvider>\n        </ViewModeProvider>\n      </ApiEndpointProvider>\n    </div>\n  );\n}",
    "start_line": 11,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function IndexPage",
    "component_id": "pages.index.IndexPage"
  },
  "pages.test-elk.TestElk": {
    "id": "pages.test-elk.TestElk",
    "name": "TestElk",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/pages/test-elk.jsx",
    "relative_path": "pages/test-elk.jsx",
    "depends_on": [],
    "source_code": "function TestElk() {\n  return <InteractiveCanvasSimple />;\n}",
    "start_line": 3,
    "end_line": 5,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function TestElk",
    "component_id": "pages.test-elk.TestElk"
  },
  "playwright.config.defineConfig": {
    "id": "playwright.config.defineConfig",
    "name": "defineConfig",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/playwright.config.ts",
    "relative_path": "playwright.config.ts",
    "depends_on": [
      "playwright.config.defineConfig"
    ],
    "source_code": "export default defineConfig({\n  testDir: './e2e',\n  timeout: 60000, // 60 seconds for complete architecture generation\n  expect: {\n    timeout: 15000 // 15 seconds for individual expectations\n  },\n  fullyParallel: true, // Enable parallel execution across projects\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 1,\n  reporter: 'list',\n  use: {\n    baseURL: BASE_URL,\n    headless: true,\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure'\n  },\n  projects: [\n    // Canvas Comprehensive Tests - 5 categories that can run in parallel\n    {\n      name: 'canvas-core-interactions',\n      testMatch: '**/canvas-comprehensive/core-interactions/**/*.spec.ts',\n      use: { ...devices['Desktop Chrome'] },\n      workers: 1, // Run tests in this category sequentially\n    },\n    {\n      name: 'canvas-layer-sync',\n      testMatch: '**/canvas-comprehensive/layer-sync/**/*.spec.ts',\n      use: { ...devices['Desktop Chrome'] },\n      workers: 1,\n    },\n    {\n      name: 'canvas-persistence',\n      testMatch: '**/canvas-comprehensive/persistence/**/*.spec.ts',\n      use: { ...devices['Desktop Chrome'] },\n      workers: 1,\n    },\n    {\n      name: 'canvas-architecture',\n      testMatch: '**/canvas-comprehensive/architecture/**/*.spec.ts',\n      use: { ...devices['Desktop Chrome'] },\n      workers: 1,\n    },\n    {\n      name: 'canvas-drag',\n      testMatch: '**/canvas-comprehensive/drag/**/*.spec.ts',\n      use: { ...devices['Desktop Chrome'] },\n      workers: 1,\n    },\n    // Edge Routing Tests - can run in parallel with canvas tests\n    {\n      name: 'edge-routing',\n      testMatch: '**/canvas-comprehensive/edge-routing/**/*.test.ts',\n      use: { ...devices['Desktop Chrome'] },\n      workers: 1,\n    },\n    // Other standalone tests\n    {\n      name: 'other-tests',\n      testMatch: [\n        '**/*.test.ts',\n        '**/*.spec.ts',\n        '!**/canvas-comprehensive/**/*',\n        '!**/actual-canvas-test.test.ts', // Skip the interfering test\n      ],\n      use: { ...devices['Desktop Chrome'] },\n      workers: 1,\n    },\n  ],\n  webServer: {\n    command: 'npm run dev',\n    port: BASE_PORT,\n    reuseExistingServer: !process.env.CI,\n    timeout: 30000\n  }\n});",
    "start_line": 7,
    "end_line": 82,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "export_default_call",
    "base_classes": null,
    "class_name": null,
    "display_name": "export default defineConfig(...)",
    "component_id": "playwright.config.defineConfig"
  },
  "playwright.local.config.defineConfig": {
    "id": "playwright.local.config.defineConfig",
    "name": "defineConfig",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/playwright.local.config.ts",
    "relative_path": "playwright.local.config.ts",
    "depends_on": [
      "playwright.local.config.defineConfig"
    ],
    "source_code": "export default defineConfig({\n  testDir: './e2e',\n  timeout: 60000, // 60 seconds for complete architecture generation\n  expect: {\n    timeout: 15000 // 15 seconds for individual expectations\n  },\n  fullyParallel: false, // Run tests sequentially to avoid port conflicts\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 1,\n  workers: 1, // Single worker to avoid conflicts\n  reporter: 'list',\n  use: {\n    baseURL: 'http://localhost:3000', // Will be dynamically detected\n    headless: true, // Run all tests headless to avoid interrupting user flow\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure'\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    }\n  ],\n  // No webServer config - assume local server is already running\n});",
    "start_line": 3,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "export_default_call",
    "base_classes": null,
    "class_name": null,
    "display_name": "export default defineConfig(...)",
    "component_id": "playwright.local.config.defineConfig"
  },
  "scripts.dev-setup.printHelp": {
    "id": "scripts.dev-setup.printHelp",
    "name": "printHelp",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/dev-setup.js",
    "relative_path": "scripts/dev-setup.js",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function printHelp() {\n  console.log(chalk.blue.bold('\\nüé® Multi-View Development Setup\\n'));\n  console.log(chalk.yellow('Available development views (all on same server):\\n'));\n  \n  Object.entries(DEV_MODES).forEach(([key, mode]) => {\n    console.log(chalk.green.bold(`üì± ${key.toUpperCase()}: ${mode.name}`));\n    console.log(chalk.gray(`   Description: ${mode.description}`));\n    console.log(chalk.cyan(`   Path: ${mode.path}`));\n    console.log(chalk.gray(`   Component: ${mode.component}`));\n    console.log(chalk.gray(`   Features: ${mode.features.join(', ')}`));\n    console.log('');\n  });\n  \n  console.log(chalk.yellow('Usage:'));\n  console.log(chalk.white('  npm run dev             # Start development server'));\n  console.log(chalk.white('  npm run dev:help        # Show this help'));\n  console.log('');\n  console.log(chalk.yellow('Once server is running, visit:'));\n  Object.entries(DEV_MODES).forEach(([key, mode]) => {\n    console.log(chalk.cyan(`  http://localhost:[PORT]${mode.path}   # ${mode.name}`));\n  });\n  console.log('');\n}",
    "start_line": 34,
    "end_line": 56,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function printHelp",
    "component_id": "scripts.dev-setup.printHelp"
  },
  "scripts.dev-setup.main": {
    "id": "scripts.dev-setup.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/dev-setup.js",
    "relative_path": "scripts/dev-setup.js",
    "depends_on": [
      "scripts.dev-setup.printHelp",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "function main() {\n  const command = process.argv[2];\n  \n  if (!command || command === 'help' || command === '--help' || command === '-h') {\n    printHelp();\n    return;\n  }\n  \n  // For any command, just show the help since we're using path-based routing now\n  console.log(chalk.blue.bold('üé® Path-Based Multi-View Development\\n'));\n  console.log(chalk.green('All views are now available on the same development server!\\n'));\n  console.log(chalk.yellow('Start the development server with:'));\n  console.log(chalk.white('  npm run dev\\n'));\n  console.log(chalk.yellow('Then visit these paths:'));\n  Object.entries(DEV_MODES).forEach(([key, mode]) => {\n    console.log(chalk.cyan(`  http://localhost:[PORT]${mode.path}   # ${mode.name}`));\n  });\n  console.log('');\n  console.log(chalk.gray('The port will be shown when you start the server.'));\n}",
    "start_line": 58,
    "end_line": 77,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "scripts.dev-setup.main"
  },
  "scripts.find-server-port.checkPort": {
    "id": "scripts.find-server-port.checkPort",
    "name": "checkPort",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/find-server-port.js",
    "relative_path": "scripts/find-server-port.js",
    "depends_on": [],
    "source_code": "async function checkPort(port) {\n    try {\n        // Try to fetch the root page or canvas page to check if server is running\n        const response = await fetch(`http://localhost:${port}/canvas`, {\n            method: 'GET',\n            timeout: 1000\n        });\n        return response.ok || response.status === 200;\n    } catch (error) {\n        // Also try root path\n        try {\n            const response = await fetch(`http://localhost:${port}/`, {\n                method: 'GET',\n                timeout: 1000\n            });\n            return response.ok || response.status === 200;\n        } catch (e) {\n            return false;\n        }\n    }\n}",
    "start_line": 15,
    "end_line": 35,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "port"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function checkPort",
    "component_id": "scripts.find-server-port.checkPort"
  },
  "scripts.find-server-port.findRunningServerPort": {
    "id": "scripts.find-server-port.findRunningServerPort",
    "name": "findRunningServerPort",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/find-server-port.js",
    "relative_path": "scripts/find-server-port.js",
    "depends_on": [
      "scripts.find-server-port.checkPort",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "async function findRunningServerPort() {\n    console.log('üîç Searching for running development server...');\n    \n    for (const port of COMMON_PORTS) {\n        if (await checkPort(port)) {\n            console.log(`‚úÖ Found server running on port ${port}`);\n            return port;\n        }\n    }\n    \n    throw new Error('‚ùå No running development server found on common ports (3000-3005)');\n}",
    "start_line": 37,
    "end_line": 48,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function findRunningServerPort",
    "component_id": "scripts.find-server-port.findRunningServerPort"
  },
  "scripts.generateGroupIconVariations.createDashedVariation": {
    "id": "scripts.generateGroupIconVariations.createDashedVariation",
    "name": "createDashedVariation",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/generateGroupIconVariations.js",
    "relative_path": "scripts/generateGroupIconVariations.js",
    "depends_on": [],
    "source_code": "function createDashedVariation(svgContent, iconName) {\n  // Add stroke-dasharray to path elements\n  let dashedSvg = svgContent.replace(\n    /<path /g, \n    '<path stroke-dasharray=\"8,4\" stroke-width=\"2\" '\n  );\n  \n  // Also add dashed style to rect elements that might have strokes\n  dashedSvg = dashedSvg.replace(\n    /<rect([^>]*stroke[^>]*)>/g,\n    (match, attributes) => {\n      if (!attributes.includes('stroke-dasharray')) {\n        return `<rect${attributes} stroke-dasharray=\"8,4\">`;\n      }\n      return match;\n    }\n  );\n  \n  return dashedSvg;\n}",
    "start_line": 23,
    "end_line": 42,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "svgContent",
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createDashedVariation",
    "component_id": "scripts.generateGroupIconVariations.createDashedVariation"
  },
  "scripts.generateGroupIconVariations.createDottedVariation": {
    "id": "scripts.generateGroupIconVariations.createDottedVariation",
    "name": "createDottedVariation",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/generateGroupIconVariations.js",
    "relative_path": "scripts/generateGroupIconVariations.js",
    "depends_on": [],
    "source_code": "function createDottedVariation(svgContent, iconName) {\n  // Add stroke-dasharray for dots\n  let dottedSvg = svgContent.replace(\n    /<path /g,\n    '<path stroke-dasharray=\"2,2\" stroke-width=\"2\" '\n  );\n  \n  // Also add dotted style to rect elements\n  dottedSvg = dottedSvg.replace(\n    /<rect([^>]*stroke[^>]*)>/g,\n    (match, attributes) => {\n      if (!attributes.includes('stroke-dasharray')) {\n        return `<rect${attributes} stroke-dasharray=\"2,2\">`;\n      }\n      return match;\n    }\n  );\n  \n  return dottedSvg;\n}",
    "start_line": 45,
    "end_line": 64,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "svgContent",
      "iconName"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function createDottedVariation",
    "component_id": "scripts.generateGroupIconVariations.createDottedVariation"
  },
  "scripts.precompute-embeddings.precomputeEmbeddings": {
    "id": "scripts.precompute-embeddings.precomputeEmbeddings",
    "name": "precomputeEmbeddings",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/precompute-embeddings.js",
    "relative_path": "scripts/precompute-embeddings.js",
    "depends_on": [
      "scripts.precompute-embeddings.parseCSVLine",
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error",
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function precomputeEmbeddings() {\n  console.log('üèóÔ∏è  Pre-computing embeddings at build time...');\n  \n  // Check for API key\n  if (!process.env.OPENAI_API_KEY && !process.env.VITE_OPENAI_API_KEY) {\n    console.log('‚ö†Ô∏è  No OpenAI API key found, skipping embedding pre-computation');\n    console.log('    OPENAI_API_KEY:', process.env.OPENAI_API_KEY ? 'SET' : 'NOT SET');\n    console.log('    VITE_OPENAI_API_KEY:', process.env.VITE_OPENAI_API_KEY ? 'SET' : 'NOT SET');\n    // Create empty file so runtime doesn't crash\n    fs.writeFileSync(OUTPUT_PATH, JSON.stringify({ architectures: [], embeddings: {} }));\n    return;\n  }\n  \n  console.log('‚úÖ OpenAI API key found, proceeding with embedding pre-computation');\n  \n  const openai = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY || process.env.VITE_OPENAI_API_KEY\n  });\n  \n  try {\n    // Read and parse CSV\n    console.log('üìÑ Reading architecture CSV...');\n    const csvContent = fs.readFileSync(CSV_PATH, 'utf-8');\n    const lines = csvContent.split('\\n');\n    const headers = lines[0].split(',').map(h => h.trim().replace(/\"/g, ''));\n    \n    const architectures = [];\n    const embeddings = {};\n    \n    console.log('üîç Processing architectures...');\n    \n    // Parse all architectures first\n    const validArchs = [];\n    for (let i = 1; i < Math.min(lines.length, 63); i++) {\n      const line = lines[i].trim();\n      if (!line) continue;\n      \n      try {\n        const values = parseCSVLine(line);\n        if (values.length >= 6) {\n          const arch = {\n            id: `arch_${i}`,\n            cloud: values[0]?.trim() || '',\n            group: values[1]?.trim() || '',\n            subgroup: values[2]?.trim() || '',\n            source: values[3]?.trim() || '',\n            description: values[4]?.trim() || '',\n            architecture: values[5]?.trim() || ''\n          };\n          \n          if (arch.subgroup && arch.description) {\n            const searchText = `${arch.cloud} ${arch.group} ${arch.subgroup} ${arch.description}`.toLowerCase();\n            validArchs.push({ arch, searchText });\n          }\n        }\n      } catch (error) {\n        console.warn(`‚ö†Ô∏è  Skipping line ${i}:`, error.message);\n      }\n    }\n    \n    // Process embeddings in batches for speed (up to 2048 inputs per request)\n    console.log(`üöÄ Processing ${validArchs.length} architectures in batches for maximum speed...`);\n    const batchSize = 50; // Conservative batch size for stability\n    \n    for (let batchStart = 0; batchStart < validArchs.length; batchStart += batchSize) {\n      const batch = validArchs.slice(batchStart, batchStart + batchSize);\n      const batchTexts = batch.map(item => item.searchText);\n      \n      console.log(`‚ö° Computing embeddings for batch ${Math.floor(batchStart/batchSize) + 1}/${Math.ceil(validArchs.length/batchSize)} (${batch.length} items)`);\n      \n      try {\n        // Get embeddings for entire batch in one API call\n        const response = await openai.embeddings.create({\n          model: 'text-embedding-3-small',\n          input: batchTexts,\n        });\n        \n        // Store results\n        batch.forEach((item, index) => {\n          architectures.push(item.arch);\n          embeddings[item.searchText] = response.data[index].embedding;\n        });\n        \n        // Small delay between batches to be nice to API\n        if (batchStart + batchSize < validArchs.length) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n        }\n      } catch (error) {\n        console.error(`‚ùå Batch failed, falling back to individual processing:`, error.message);\n        \n        // Fallback: process this batch individually\n        for (const item of batch) {\n          try {\n            console.log(`‚ö° Computing embedding for: ${item.arch.subgroup}`);\n            const response = await openai.embeddings.create({\n              model: 'text-embedding-3-small',\n              input: item.searchText,\n            });\n            \n            architectures.push(item.arch);\n            embeddings[item.searchText] = response.data[0].embedding;\n            await new Promise(resolve => setTimeout(resolve, 100));\n          } catch (error) {\n            console.warn(`‚ö†Ô∏è  Skipping ${item.arch.subgroup}:`, error.message);\n          }\n        }\n      }\n    }\n    \n    // Ensure output directory exists\n    const outputDir = path.dirname(OUTPUT_PATH);\n    if (!fs.existsSync(outputDir)) {\n      fs.mkdirSync(outputDir, { recursive: true });\n    }\n    \n    // Write precomputed data\n    const output = {\n      architectures,\n      embeddings,\n      generatedAt: new Date().toISOString(),\n      count: architectures.length\n    };\n    \n    fs.writeFileSync(OUTPUT_PATH, JSON.stringify(output, null, 2));\n    console.log(`‚úÖ Pre-computed ${architectures.length} embeddings and saved to ${OUTPUT_PATH}`);\n    \n  } catch (error) {\n    console.error('‚ùå Failed to pre-compute embeddings:', error);\n    process.exit(1);\n  }\n}",
    "start_line": 48,
    "end_line": 178,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function precomputeEmbeddings",
    "component_id": "scripts.precompute-embeddings.precomputeEmbeddings"
  },
  "scripts.precompute-embeddings.parseCSVLine": {
    "id": "scripts.precompute-embeddings.parseCSVLine",
    "name": "parseCSVLine",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/precompute-embeddings.js",
    "relative_path": "scripts/precompute-embeddings.js",
    "depends_on": [],
    "source_code": "function parseCSVLine(line) {\n  const result = [];\n  let current = '';\n  let inQuotes = false;\n  \n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    if (char === '\"') {\n      inQuotes = !inQuotes;\n    } else if (char === ',' && !inQuotes) {\n      result.push(current.trim());\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  result.push(current.trim());\n  \n  return result.map(field => field.replace(/^\"|\"$/g, ''));\n}",
    "start_line": 180,
    "end_line": 199,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "line"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseCSVLine",
    "component_id": "scripts.precompute-embeddings.parseCSVLine"
  },
  "scripts.precompute-icon-embeddings.parseIconLists": {
    "id": "scripts.precompute-icon-embeddings.parseIconLists",
    "name": "parseIconLists",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/precompute-icon-embeddings.js",
    "relative_path": "scripts/precompute-icon-embeddings.js",
    "depends_on": [
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "function parseIconLists() {\n  if (!fs.existsSync(ICON_LISTS_PATH)) {\n    console.error('‚ùå iconLists.ts not found. Run generate-icons first.');\n    process.exit(1);\n  }\n  \n  const content = fs.readFileSync(ICON_LISTS_PATH, 'utf-8');\n  \n  // Extract the iconLists object using a more robust approach\n  const startMatch = content.match(/export const iconLists: IconLists = {/);\n  if (!startMatch) {\n    console.error('‚ùå Could not find iconLists export in file');\n    process.exit(1);\n  }\n  \n  const startIndex = startMatch.index + startMatch[0].length;\n  let braceCount = 1;\n  let endIndex = startIndex;\n  \n  // Find the matching closing brace\n  for (let i = startIndex; i < content.length && braceCount > 0; i++) {\n    if (content[i] === '{') braceCount++;\n    else if (content[i] === '}') braceCount--;\n    endIndex = i;\n  }\n  \n  if (braceCount > 0) {\n    console.error('‚ùå Could not find closing brace for iconLists');\n    process.exit(1);\n  }\n  \n  let objectStr = content.substring(startIndex, endIndex);\n  \n  // Convert to JSON-like format\n  objectStr = objectStr.replace(/(\\w+):\\s*{/g, '\"$1\": {');\n  objectStr = objectStr.replace(/(\\w+):\\s*\\[/g, '\"$1\": [');\n  objectStr = objectStr.replace(/'/g, '\"');\n  objectStr = objectStr.replace(/,(\\s*[}\\]])/g, '$1'); // Remove trailing commas\n  \n  try {\n    return JSON.parse('{' + objectStr + '}');\n  } catch (error) {\n    console.error('‚ùå Failed to parse icon lists:', error);\n    console.error('Parsed content preview:', objectStr.substring(0, 500));\n    process.exit(1);\n  }\n}",
    "start_line": 50,
    "end_line": 96,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parseIconLists",
    "component_id": "scripts.precompute-icon-embeddings.parseIconLists"
  },
  "scripts.precompute-icon-embeddings.cosineSimilarity": {
    "id": "scripts.precompute-icon-embeddings.cosineSimilarity",
    "name": "cosineSimilarity",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/precompute-icon-embeddings.js",
    "relative_path": "scripts/precompute-icon-embeddings.js",
    "depends_on": [],
    "source_code": "function cosineSimilarity(a, b) {\n  const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n  const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n  const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n  return dotProduct / (magnitudeA * magnitudeB);\n}",
    "start_line": 98,
    "end_line": 103,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "a",
      "b"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cosineSimilarity",
    "component_id": "scripts.precompute-icon-embeddings.cosineSimilarity"
  },
  "scripts.precompute-icon-embeddings.precomputeIconEmbeddings": {
    "id": "scripts.precompute-icon-embeddings.precomputeIconEmbeddings",
    "name": "precomputeIconEmbeddings",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/precompute-icon-embeddings.js",
    "relative_path": "scripts/precompute-icon-embeddings.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.precompute-icon-embeddings.parseIconLists",
      "client.components.graph.utils.elk.edgePoints.warn",
      "scripts.test-vercel-preview.error",
      "scripts.precompute-icon-embeddings.cosineSimilarity"
    ],
    "source_code": "async function precomputeIconEmbeddings() {\n  console.log('üé® Pre-computing icon embeddings at build time...');\n  \n  // Check for API key\n  if (!process.env.OPENAI_API_KEY && !process.env.VITE_OPENAI_API_KEY) {\n    console.log('‚ö†Ô∏è  No OpenAI API key found, skipping icon embedding pre-computation');\n    // Create empty file so runtime doesn't crash\n    fs.writeFileSync(OUTPUT_PATH, JSON.stringify({ embeddings: {}, similarities: {} }));\n    return;\n  }\n  \n  console.log('‚úÖ OpenAI API key found, proceeding with icon embedding pre-computation');\n  \n  const openai = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY || process.env.VITE_OPENAI_API_KEY\n  });\n  \n  try {\n    // Parse icon lists\n    console.log('üìã Loading icon lists...');\n    const iconLists = parseIconLists();\n    \n    // Collect all icons with their provider prefixes\n    const allIcons = [];\n    console.log('üì¶ Icon lists structure:', Object.keys(iconLists));\n    \n    for (const [provider, categories] of Object.entries(iconLists)) {\n      if (provider === 'generic' || provider === 'all') {\n        // Skip generic and all arrays\n        continue;\n      }\n      \n      console.log(`üìã Processing provider: ${provider}, categories:`, Object.keys(categories || {}));\n      \n      if (categories && typeof categories === 'object') {\n        for (const [category, icons] of Object.entries(categories)) {\n          if (Array.isArray(icons)) {\n            icons.forEach(icon => {\n              allIcons.push({\n                provider,\n                category,\n                name: icon,\n                fullName: `${provider}_${icon}`,\n                searchText: icon.replace(/_/g, ' ') // Convert underscores to spaces for better embedding\n              });\n            });\n          } else {\n            console.warn(`‚ö†Ô∏è Category ${category} in ${provider} is not an array:`, typeof icons);\n          }\n        }\n      } else {\n        console.warn(`‚ö†Ô∏è Provider ${provider} categories is not an object:`, typeof categories);\n      }\n    }\n    \n    console.log(`üîç Found ${allIcons.length} total icons across all providers`);\n    \n    // Generate embeddings for all icons\n    const embeddings = {};\n    const batchSize = 50; // Conservative batch size\n    \n    console.log('üöÄ Computing embeddings in batches...');\n    \n    for (let i = 0; i < allIcons.length; i += batchSize) {\n      const batch = allIcons.slice(i, i + batchSize);\n      const batchTexts = batch.map(icon => icon.searchText);\n      \n      console.log(`‚ö° Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(allIcons.length/batchSize)} (${batch.length} icons)`);\n      \n      try {\n        const response = await openai.embeddings.create({\n          model: 'text-embedding-3-small',\n          input: batchTexts,\n        });\n        \n        batch.forEach((icon, index) => {\n          embeddings[icon.name] = response.data[index].embedding;\n        });\n        \n        // Small delay between batches\n        if (i + batchSize < allIcons.length) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n        }\n      } catch (error) {\n        console.error(`‚ùå Batch failed, processing individually:`, error.message);\n        \n        // Fallback to individual processing\n        for (const icon of batch) {\n          try {\n            const response = await openai.embeddings.create({\n              model: 'text-embedding-3-small',\n              input: icon.searchText,\n            });\n            embeddings[icon.name] = response.data[0].embedding;\n            await new Promise(resolve => setTimeout(resolve, 100));\n          } catch (error) {\n            console.warn(`‚ö†Ô∏è  Skipping ${icon.fullName}:`, error.message);\n          }\n        }\n      }\n    }\n    \n    console.log('üîó Computing similarity mappings...');\n    \n    // Pre-compute similarity mappings for faster lookup\n    const similarities = {};\n    const providers = Object.keys(iconLists);\n    \n    for (const provider of providers) {\n      similarities[provider] = {};\n      const providerIcons = allIcons.filter(icon => icon.provider === provider);\n      \n      console.log(`üìä Computing ${providerIcons.length * providerIcons.length} similarities for ${provider}...`);\n      \n      for (const iconA of providerIcons) {\n        if (!embeddings[iconA.name]) continue;\n        \n        similarities[provider][iconA.name] = {};\n        \n        for (const iconB of providerIcons) {\n          if (!embeddings[iconB.name] || iconA.name === iconB.name) continue;\n          \n          const similarity = cosineSimilarity(embeddings[iconA.name], embeddings[iconB.name]);\n          similarities[provider][iconA.name][iconB.name] = similarity;\n        }\n      }\n    }\n    \n    // Ensure output directory exists\n    const outputDir = path.dirname(OUTPUT_PATH);\n    if (!fs.existsSync(outputDir)) {\n      fs.mkdirSync(outputDir, { recursive: true });\n    }\n    \n    // Write precomputed data\n    const output = {\n      embeddings,\n      similarities,\n      generatedAt: new Date().toISOString(),\n      iconCount: Object.keys(embeddings).length,\n      providers: providers\n    };\n    \n    fs.writeFileSync(OUTPUT_PATH, JSON.stringify(output, null, 2));\n    \n    // Also copy to public directory for local development\n    const publicPath = 'public/precomputed-icon-embeddings.json';\n    const publicDir = path.dirname(publicPath);\n    if (!fs.existsSync(publicDir)) {\n      fs.mkdirSync(publicDir, { recursive: true });\n    }\n    fs.writeFileSync(publicPath, JSON.stringify(output, null, 2));\n    \n    // Also copy to dist directory for Vercel deployment\n    const distPath = 'dist/precomputed-icon-embeddings.json';\n    const distDir = path.dirname(distPath);\n    if (!fs.existsSync(distDir)) {\n      fs.mkdirSync(distDir, { recursive: true });\n    }\n    fs.writeFileSync(distPath, JSON.stringify(output, null, 2));\n    \n    console.log(`‚úÖ Pre-computed ${Object.keys(embeddings).length} icon embeddings and similarities`);\n    console.log(`üìÅ Saved to ${OUTPUT_PATH}`);\n    console.log(`üìÅ Also saved to ${publicPath} for local development`);\n    console.log(`üìÅ Also saved to ${distPath} for Vercel deployment`);\n    \n  } catch (error) {\n    console.error('‚ùå Failed to pre-compute icon embeddings:', error);\n    process.exit(1);\n  }\n}",
    "start_line": 105,
    "end_line": 275,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function precomputeIconEmbeddings",
    "component_id": "scripts.precompute-icon-embeddings.precomputeIconEmbeddings"
  },
  "scripts.promote-to-production.log": {
    "id": "scripts.promote-to-production.log",
    "name": "log",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/promote-to-production.js",
    "relative_path": "scripts/promote-to-production.js",
    "depends_on": [
      "scripts.promote-to-production.log"
    ],
    "source_code": "log = (color, message) => console.log(`${color}${message}${COLORS.reset}`)",
    "start_line": 22,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "color",
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function log",
    "component_id": "scripts.promote-to-production.log"
  },
  "scripts.promote-to-production.success": {
    "id": "scripts.promote-to-production.success",
    "name": "success",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/promote-to-production.js",
    "relative_path": "scripts/promote-to-production.js",
    "depends_on": [
      "scripts.promote-to-production.log"
    ],
    "source_code": "success = (message) => log(COLORS.green, `‚úÖ ${message}`)",
    "start_line": 23,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function success",
    "component_id": "scripts.promote-to-production.success"
  },
  "scripts.promote-to-production.error": {
    "id": "scripts.promote-to-production.error",
    "name": "error",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/promote-to-production.js",
    "relative_path": "scripts/promote-to-production.js",
    "depends_on": [
      "scripts.promote-to-production.log"
    ],
    "source_code": "error = (message) => log(COLORS.red, `‚ùå ${message}`)",
    "start_line": 24,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function error",
    "component_id": "scripts.promote-to-production.error"
  },
  "scripts.promote-to-production.info": {
    "id": "scripts.promote-to-production.info",
    "name": "info",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/promote-to-production.js",
    "relative_path": "scripts/promote-to-production.js",
    "depends_on": [
      "scripts.promote-to-production.log"
    ],
    "source_code": "info = (message) => log(COLORS.blue, `‚ÑπÔ∏è  ${message}`)",
    "start_line": 25,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function info",
    "component_id": "scripts.promote-to-production.info"
  },
  "scripts.promote-to-production.warning": {
    "id": "scripts.promote-to-production.warning",
    "name": "warning",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/promote-to-production.js",
    "relative_path": "scripts/promote-to-production.js",
    "depends_on": [
      "scripts.promote-to-production.log"
    ],
    "source_code": "warning = (message) => log(COLORS.yellow, `‚ö†Ô∏è  ${message}`)",
    "start_line": 26,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function warning",
    "component_id": "scripts.promote-to-production.warning"
  },
  "scripts.promote-to-production.promoteToProduction": {
    "id": "scripts.promote-to-production.promoteToProduction",
    "name": "promoteToProduction",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/promote-to-production.js",
    "relative_path": "scripts/promote-to-production.js",
    "depends_on": [
      "scripts.promote-to-production.info",
      "scripts.promote-to-production.warning",
      "scripts.promote-to-production.log",
      "scripts.promote-to-production.error",
      "scripts.promote-to-production.success"
    ],
    "source_code": "async function promoteToProduction() {\n  console.log(`${COLORS.bold}${COLORS.blue}üöÄ Production Promotion Workflow${COLORS.reset}\\n`);\n  \n  try {\n    // Step 1: Run comprehensive tests on preview\n    info('Step 1: Running comprehensive tests on preview deployment...');\n    \n    const tester = new VercelPreviewTester();\n    const testsPass = await tester.runAllTests();\n    \n    if (!testsPass) {\n      error('Tests failed on preview deployment.');\n      error('‚ùå PROMOTION BLOCKED - Fix failing tests before promoting to production.');\n      process.exit(1);\n    }\n    \n    success('All tests passed on preview deployment!');\n    \n    // Step 2: Confirm promotion\n    console.log('\\n' + '='.repeat(60));\n    console.log(`${COLORS.bold}${COLORS.yellow}‚ö†Ô∏è  PRODUCTION PROMOTION CONFIRMATION${COLORS.reset}`);\n    console.log('='.repeat(60));\n    \n    warning('You are about to promote the current preview to production.');\n    warning('This will make the changes live on atelier-inc.net');\n    \n    // In a real scenario, you might want to add interactive confirmation\n    // For now, we'll just show the command to run\n    console.log(`\\n${COLORS.bold}To complete the promotion, run:${COLORS.reset}`);\n    console.log(`${COLORS.green}vercel --prod${COLORS.reset}\\n`);\n    \n    console.log(`${COLORS.yellow}Or use the Vercel dashboard to promote the deployment.${COLORS.reset}`);\n    \n    success('‚úÖ Preview deployment is ready for production promotion!');\n    \n  } catch (err) {\n    error(`Production promotion failed: ${err.message}`);\n    process.exit(1);\n  }\n}",
    "start_line": 28,
    "end_line": 67,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function promoteToProduction",
    "component_id": "scripts.promote-to-production.promoteToProduction"
  },
  "scripts.setup-git-hooks.log": {
    "id": "scripts.setup-git-hooks.log",
    "name": "log",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/setup-git-hooks.js",
    "relative_path": "scripts/setup-git-hooks.js",
    "depends_on": [
      "scripts.setup-git-hooks.log"
    ],
    "source_code": "log = (color, message) => console.log(`${color}${message}${COLORS.reset}`)",
    "start_line": 23,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "color",
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function log",
    "component_id": "scripts.setup-git-hooks.log"
  },
  "scripts.setup-git-hooks.success": {
    "id": "scripts.setup-git-hooks.success",
    "name": "success",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/setup-git-hooks.js",
    "relative_path": "scripts/setup-git-hooks.js",
    "depends_on": [
      "scripts.setup-git-hooks.log"
    ],
    "source_code": "success = (message) => log(COLORS.green, `‚úÖ ${message}`)",
    "start_line": 24,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function success",
    "component_id": "scripts.setup-git-hooks.success"
  },
  "scripts.setup-git-hooks.error": {
    "id": "scripts.setup-git-hooks.error",
    "name": "error",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/setup-git-hooks.js",
    "relative_path": "scripts/setup-git-hooks.js",
    "depends_on": [
      "scripts.setup-git-hooks.log"
    ],
    "source_code": "error = (message) => log(COLORS.red, `‚ùå ${message}`)",
    "start_line": 25,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function error",
    "component_id": "scripts.setup-git-hooks.error"
  },
  "scripts.setup-git-hooks.info": {
    "id": "scripts.setup-git-hooks.info",
    "name": "info",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/setup-git-hooks.js",
    "relative_path": "scripts/setup-git-hooks.js",
    "depends_on": [
      "scripts.setup-git-hooks.log"
    ],
    "source_code": "info = (message) => log(COLORS.blue, `‚ÑπÔ∏è  ${message}`)",
    "start_line": 26,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function info",
    "component_id": "scripts.setup-git-hooks.info"
  },
  "scripts.setup-git-hooks.warning": {
    "id": "scripts.setup-git-hooks.warning",
    "name": "warning",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/setup-git-hooks.js",
    "relative_path": "scripts/setup-git-hooks.js",
    "depends_on": [
      "scripts.setup-git-hooks.log"
    ],
    "source_code": "warning = (message) => log(COLORS.yellow, `‚ö†Ô∏è  ${message}`)",
    "start_line": 27,
    "end_line": 27,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function warning",
    "component_id": "scripts.setup-git-hooks.warning"
  },
  "scripts.setup-git-hooks.setupGitHooks": {
    "id": "scripts.setup-git-hooks.setupGitHooks",
    "name": "setupGitHooks",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/setup-git-hooks.js",
    "relative_path": "scripts/setup-git-hooks.js",
    "depends_on": [
      "scripts.setup-git-hooks.info",
      "scripts.setup-git-hooks.success",
      "scripts.setup-git-hooks.log",
      "scripts.setup-git-hooks.error",
      "scripts.setup-git-hooks.warning"
    ],
    "source_code": "function setupGitHooks() {\n  console.log(`${COLORS.bold}${COLORS.blue}üîß Setting up Git Hooks for Vercel Testing${COLORS.reset}\\n`);\n  \n  try {\n    // Check if we're in a git repository\n    try {\n      execSync('git rev-parse --git-dir', { stdio: 'ignore' });\n    } catch (err) {\n      error('Not in a git repository. Please run this from the project root.');\n      process.exit(1);\n    }\n    \n    // Set up git hooks directory\n    const gitHooksDir = '.git/hooks';\n    const customHooksDir = '.githooks';\n    \n    if (!fs.existsSync(customHooksDir)) {\n      error('Custom hooks directory .githooks not found');\n      process.exit(1);\n    }\n    \n    // Configure git to use our custom hooks directory\n    info('Configuring git to use custom hooks directory...');\n    execSync('git config core.hooksPath .githooks', { stdio: 'inherit' });\n    success('Git configured to use .githooks directory');\n    \n    // Make all hooks executable\n    const hookFiles = fs.readdirSync(customHooksDir);\n    for (const hookFile of hookFiles) {\n      const hookPath = path.join(customHooksDir, hookFile);\n      if (fs.statSync(hookPath).isFile()) {\n        execSync(`chmod +x \"${hookPath}\"`);\n        success(`Made ${hookFile} executable`);\n      }\n    }\n    \n    // Create a wrapper script that prevents --no-verify\n    const gitWrapperPath = '.githooks/git-push-wrapper.sh';\n    const gitWrapperContent = `#!/bin/bash\n\n# Git push wrapper that prevents bypassing hooks\n# This ensures that --no-verify cannot be used to skip our tests\n\nif [[ \"$*\" == *\"--no-verify\"* ]]; then\n    echo -e \"\\\\033[0;31m‚ùå ERROR: --no-verify is not allowed\\\\033[0m\"\n    echo -e \"\\\\033[0;31müö´ Push protection cannot be bypassed\\\\033[0m\"\n    echo -e \"\\\\033[1;33müí° Fix the failing tests instead of bypassing them\\\\033[0m\"\n    echo \"\"\n    echo -e \"\\\\033[0;34mTo see what's failing, run:\\\\033[0m\"\n    echo -e \"\\\\033[0;34m  npm run test:vercel-preview\\\\033[0m\"\n    echo \"\"\n    exit 1\nfi\n\n# Call the real git with all arguments\nexec /usr/bin/git \"$@\"\n`;\n    \n    fs.writeFileSync(gitWrapperPath, gitWrapperContent);\n    execSync(`chmod +x \"${gitWrapperPath}\"`);\n    success('Created git push wrapper to prevent --no-verify');\n    \n    // Add alias to package.json scripts to use our wrapper\n    const packageJsonPath = 'package.json';\n    if (fs.existsSync(packageJsonPath)) {\n      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n      \n      if (!packageJson.scripts) {\n        packageJson.scripts = {};\n      }\n      \n      // Add protected git commands\n      packageJson.scripts['git:push'] = './.githooks/git-push-wrapper.sh push';\n      packageJson.scripts['git:push-origin'] = './.githooks/git-push-wrapper.sh push origin';\n      \n      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));\n      success('Added protected git commands to package.json');\n    }\n    \n    // Test the hook setup\n    info('Testing git hook setup...');\n    try {\n      // This should work (just checking if hooks are callable)\n      execSync('git config --get core.hooksPath', { stdio: 'pipe' });\n      success('Git hooks are properly configured');\n    } catch (err) {\n      warning('Could not verify git hook configuration');\n    }\n    \n    console.log('\\n' + '='.repeat(60));\n    console.log(`${COLORS.bold}${COLORS.green}üéâ Git Hooks Setup Complete!${COLORS.reset}`);\n    console.log('='.repeat(60));\n    \n    console.log(`${COLORS.blue}üìã What was set up:${COLORS.reset}`);\n    console.log(`${COLORS.green}  ‚úÖ Pre-push hook that tests Vercel preview before allowing push${COLORS.reset}`);\n    console.log(`${COLORS.green}  ‚úÖ Protection against --no-verify bypass attempts${COLORS.reset}`);\n    console.log(`${COLORS.green}  ‚úÖ Automatic deployment and testing on push${COLORS.reset}`);\n    \n    console.log(`\\n${COLORS.blue}üìã How it works:${COLORS.reset}`);\n    console.log(`${COLORS.yellow}  1. When you run 'git push', the hook automatically:${COLORS.reset}`);\n    console.log(`${COLORS.yellow}     - Deploys your code to Vercel preview${COLORS.reset}`);\n    console.log(`${COLORS.yellow}     - Runs comprehensive tests on the live preview${COLORS.reset}`);\n    console.log(`${COLORS.yellow}     - Blocks the push if any tests fail${COLORS.reset}`);\n    console.log(`${COLORS.yellow}  2. Only allows push if all tests pass${COLORS.reset}`);\n    console.log(`${COLORS.yellow}  3. Prevents bypassing with --no-verify${COLORS.reset}`);\n    \n    console.log(`\\n${COLORS.blue}üìã Safe commands to use:${COLORS.reset}`);\n    console.log(`${COLORS.green}  git push                    # Protected push with testing${COLORS.reset}`);\n    console.log(`${COLORS.green}  npm run git:push           # Alternative protected push${COLORS.reset}`);\n    console.log(`${COLORS.green}  npm run promote:production # Promote after tests pass${COLORS.reset}`);\n    \n    console.log(`\\n${COLORS.red}üö´ Commands that are blocked:${COLORS.reset}`);\n    console.log(`${COLORS.red}  git push --no-verify       # Blocked - cannot bypass tests${COLORS.reset}`);\n    console.log(`${COLORS.red}  vercel --prod              # Should only be done manually after tests${COLORS.reset}`);\n    \n    console.log(`\\n${COLORS.blue}üí° Next steps:${COLORS.reset}`);\n    console.log(`${COLORS.blue}  1. Make your changes${COLORS.reset}`);\n    console.log(`${COLORS.blue}  2. Commit your changes: git commit -m \"your message\"${COLORS.reset}`);\n    console.log(`${COLORS.blue}  3. Push (tests will run automatically): git push${COLORS.reset}`);\n    console.log(`${COLORS.blue}  4. If tests pass, promote to production: npm run promote:production${COLORS.reset}`);\n    \n  } catch (err) {\n    error(`Failed to set up git hooks: ${err.message}`);\n    process.exit(1);\n  }\n}",
    "start_line": 29,
    "end_line": 154,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setupGitHooks",
    "component_id": "scripts.setup-git-hooks.setupGitHooks"
  },
  "scripts.test-connection-management.testTerminal": {
    "id": "scripts.test-connection-management.testTerminal",
    "name": "testTerminal",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-connection-management.js",
    "relative_path": "scripts/test-connection-management.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function testTerminal(terminalId) {\n  const startTime = Date.now();\n  console.log(`üöÄ Terminal ${terminalId}: Starting connection test...`);\n  \n  try {\n    const response = await fetch(`${SERVER_URL}/chat`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-session-id': `test-terminal-${terminalId}-${Date.now()}`\n      },\n      body: JSON.stringify(testPayload)\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const result = await response.json();\n    const duration = Date.now() - startTime;\n    \n    console.log(`‚úÖ Terminal ${terminalId}: Success in ${duration}ms`);\n    console.log(`üìù Response: ${result.message?.content || 'No content'}`);\n    \n    return { success: true, duration, terminalId };\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    console.error(`‚ùå Terminal ${terminalId}: Failed after ${duration}ms - ${error.message}`);\n    return { success: false, duration, terminalId, error: error.message };\n  }\n}",
    "start_line": 17,
    "end_line": 47,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "terminalId"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testTerminal",
    "component_id": "scripts.test-connection-management.testTerminal"
  },
  "scripts.test-connection-management.checkStats": {
    "id": "scripts.test-connection-management.checkStats",
    "name": "checkStats",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-connection-management.js",
    "relative_path": "scripts/test-connection-management.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function checkStats() {\n  try {\n    const response = await fetch(`${SERVER_URL}/api/connection-stats`);\n    const stats = await response.json();\n    console.log(`üìä Connection Stats:`, {\n      active: stats.activeConnections,\n      queued: stats.queuedRequests,\n      completed: stats.completedRequests,\n      failed: stats.failedRequests,\n      timeouts: stats.totalTimeouts\n    });\n  } catch (error) {\n    console.error(`‚ùå Failed to get stats: ${error.message}`);\n  }\n}",
    "start_line": 49,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function checkStats",
    "component_id": "scripts.test-connection-management.checkStats"
  },
  "scripts.test-connection-management.runConcurrentTest": {
    "id": "scripts.test-connection-management.runConcurrentTest",
    "name": "runConcurrentTest",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-connection-management.js",
    "relative_path": "scripts/test-connection-management.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-connection-management.checkStats",
      "scripts.test-connection-management.testTerminal"
    ],
    "source_code": "async function runConcurrentTest() {\n  console.log(`üéØ Starting concurrent connection test with ${NUM_TERMINALS} terminals...`);\n  \n  // Check initial stats\n  console.log('\\nüìä Initial connection stats:');\n  await checkStats();\n  \n  // Launch all terminals concurrently\n  const terminals = [];\n  for (let i = 1; i <= NUM_TERMINALS; i++) {\n    terminals.push(testTerminal(i));\n  }\n  \n  console.log(`\\nüîÑ Running ${NUM_TERMINALS} concurrent connections...`);\n  const results = await Promise.allSettled(terminals);\n  \n  // Analyze results\n  const successful = results.filter(r => r.status === 'fulfilled' && r.value.success).length;\n  const failed = results.length - successful;\n  const avgDuration = results\n    .filter(r => r.status === 'fulfilled')\n    .reduce((sum, r) => sum + r.value.duration, 0) / results.length;\n  \n  console.log(`\\nüéØ TEST COMPLETED`);\n  console.log(`================`);\n  console.log(`‚úÖ Successful: ${successful}/${NUM_TERMINALS} (${(successful/NUM_TERMINALS*100).toFixed(1)}%)`);\n  console.log(`‚ùå Failed: ${failed}/${NUM_TERMINALS} (${(failed/NUM_TERMINALS*100).toFixed(1)}%)`);\n  console.log(`‚è±Ô∏è  Average duration: ${avgDuration.toFixed(0)}ms`);\n  \n  // Check final stats\n  console.log('\\nüìä Final connection stats:');\n  await checkStats();\n  \n  // Wait a moment for queue to clear\n  console.log('\\n‚è≥ Waiting 2 seconds for connections to settle...');\n  await new Promise(resolve => setTimeout(resolve, 2000));\n  \n  console.log('\\nüìä Final stats after settling:');\n  await checkStats();\n}",
    "start_line": 65,
    "end_line": 104,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function runConcurrentTest",
    "component_id": "scripts.test-connection-management.runConcurrentTest"
  },
  "scripts.test-icon-fallback-local.findLocalServer": {
    "id": "scripts.test-icon-fallback-local.findLocalServer",
    "name": "findLocalServer",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-icon-fallback-local.js",
    "relative_path": "scripts/test-icon-fallback-local.js",
    "depends_on": [],
    "source_code": "async function findLocalServer() {\n    const ports = [3000, 3001, 3002, 3003, 3004];\n    \n    for (const port of ports) {\n        try {\n            const response = await fetch(`http://localhost:${port}/api/embed`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ text: 'test' })\n            });\n            \n            if (response.ok) {\n                return `http://localhost:${port}`;\n            }\n        } catch (error) {\n            // Port not available, try next\n        }\n    }\n    return null;\n}",
    "start_line": 9,
    "end_line": 28,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function findLocalServer",
    "component_id": "scripts.test-icon-fallback-local.findLocalServer"
  },
  "scripts.test-icon-fallback-local.waitForLocalServer": {
    "id": "scripts.test-icon-fallback-local.waitForLocalServer",
    "name": "waitForLocalServer",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-icon-fallback-local.js",
    "relative_path": "scripts/test-icon-fallback-local.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-icon-fallback-local.findLocalServer"
    ],
    "source_code": "async function waitForLocalServer(maxRetries = 30) {\n    console.log('üîç Waiting for local dev server...');\n    \n    for (let i = 0; i < maxRetries; i++) {\n        const serverUrl = await findLocalServer();\n        if (serverUrl) {\n            console.log(`‚úÖ Local dev server is ready at ${serverUrl}`);\n            return serverUrl;\n        }\n        \n        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds\n    }\n    \n    throw new Error('‚ùå Local dev server not found on any port');\n}",
    "start_line": 30,
    "end_line": 44,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function waitForLocalServer",
    "component_id": "scripts.test-icon-fallback-local.waitForLocalServer"
  },
  "scripts.test-icon-fallback-local.testIconFallbackLocal": {
    "id": "scripts.test-icon-fallback-local.testIconFallbackLocal",
    "name": "testIconFallbackLocal",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-icon-fallback-local.js",
    "relative_path": "scripts/test-icon-fallback-local.js",
    "depends_on": [
      "scripts.test-icon-fallback-local.waitForLocalServer",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "async function testIconFallbackLocal() {\n    const serverUrl = await waitForLocalServer();\n    \n    console.log('üß™ Testing Icon Fallback System (LOCAL)');\n    console.log('========================================\\n');\n    \n    let allTestsPassed = true;\n    \n    // Test 1: Verify missing icon scenario\n    console.log('1Ô∏è‚É£ Testing missing icon: gcp_cloud_trace');\n    \n    try {\n        const iconResponse = await fetch(`${serverUrl}/icons/gcp/gcp_cloud_trace.png`);\n        const contentType = iconResponse.headers.get('content-type') || '';\n        \n        if (contentType.includes('text/html')) {\n            console.log('   ‚úÖ Icon correctly detected as missing (HTML response)');\n        } else {\n            console.log('   ‚ùå Icon loading detection failed');\n            allTestsPassed = false;\n        }\n    } catch (error) {\n        console.log(`   ‚ùå Error testing icon URL: ${error.message}`);\n        allTestsPassed = false;\n    }\n    \n    // Test 2: Check fallback embedding availability\n    console.log('\\n2Ô∏è‚É£ Testing fallback embedding availability');\n    \n    try {\n        const embeddingsResponse = await fetch(`${serverUrl}/precomputed-icon-embeddings.json`);\n        const embeddings = await embeddingsResponse.json();\n        \n        const hasTraceEmbedding = embeddings.embeddings && embeddings.embeddings['trace'];\n        if (hasTraceEmbedding) {\n            console.log('   ‚úÖ Trace embedding available for fallback');\n        } else {\n            console.log('   ‚ùå Trace embedding missing');\n            allTestsPassed = false;\n        }\n    } catch (error) {\n        console.log(`   ‚ùå Error checking embeddings: ${error.message}`);\n        allTestsPassed = false;\n    }\n    \n    // Test 3: Test semantic search API\n    console.log('\\n3Ô∏è‚É£ Testing semantic search API');\n    \n    try {\n        const searchResponse = await fetch(`${serverUrl}/api/embed`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ text: 'cloud trace monitoring' })\n        });\n        \n        if (searchResponse.ok) {\n            const searchData = await searchResponse.json();\n            if (searchData.embedding && searchData.embedding.length > 0) {\n                console.log('   ‚úÖ Semantic search API working');\n            } else {\n                console.log('   ‚ùå Semantic search returned invalid data');\n                allTestsPassed = false;\n            }\n        } else {\n            console.log(`   ‚ùå Semantic search API failed: ${searchResponse.status}`);\n            allTestsPassed = false;\n        }\n    } catch (error) {\n        console.log(`   ‚ùå Error with semantic search: ${error.message}`);\n        allTestsPassed = false;\n    }\n    \n    // Test 4: Test agent generation uses fallback for missing icons\n    console.log('\\n4Ô∏è‚É£ Testing agent uses fallback for missing icons');\n    \n    try {\n        const agentResponse = await fetch(`${serverUrl}/api/simple-agent`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ \n                message: 'Create a GCP architecture with gcp_cloud_trace monitoring', \n                tools: [] \n            })\n        });\n        \n        if (agentResponse.ok) {\n            const agentData = await agentResponse.json();\n            if (agentData.success && agentData.functionCalls && agentData.functionCalls.length > 0) {\n                // Check if the response contains gcp_cloud_trace (which should trigger fallback)\n                const responseText = JSON.stringify(agentData);\n                if (responseText.includes('gcp_cloud_trace')) {\n                    console.log('   ‚úÖ Agent correctly uses gcp_cloud_trace (will trigger fallback)');\n                } else {\n                    console.log('   ‚ö†Ô∏è Agent did not use gcp_cloud_trace - may have used fallback icon name');\n                }\n            } else {\n                console.log('   ‚ùå Agent did not generate valid response');\n                allTestsPassed = false;\n            }\n        } else {\n            console.log(`   ‚ùå Agent API failed: ${agentResponse.status}`);\n            allTestsPassed = false;\n        }\n    } catch (error) {\n        console.log(`   ‚ùå Error with agent test: ${error.message}`);\n        allTestsPassed = false;\n    }\n    \n    console.log('\\n========================================');\n    if (allTestsPassed) {\n        console.log('‚úÖ ALL LOCAL ICON FALLBACK TESTS PASSED');\n        console.log('üéØ System ready: Missing icons will trigger semantic fallback');\n    } else {\n        console.log('‚ùå SOME LOCAL ICON FALLBACK TESTS FAILED');\n        process.exit(1);\n    }\n}",
    "start_line": 46,
    "end_line": 162,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function testIconFallbackLocal",
    "component_id": "scripts.test-icon-fallback-local.testIconFallbackLocal"
  },
  "scripts.test-icon-fallback.findLocalServer": {
    "id": "scripts.test-icon-fallback.findLocalServer",
    "name": "findLocalServer",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-icon-fallback.js",
    "relative_path": "scripts/test-icon-fallback.js",
    "depends_on": [
      "scripts.find-server-port.findRunningServerPort",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "async function findLocalServer() {\n    try {\n        const port = await findRunningServerPort();\n        return `http://localhost:${port}`;\n    } catch (error) {\n        console.error('‚ùå Could not find running server:', error.message);\n        return null;\n    }\n}",
    "start_line": 10,
    "end_line": 18,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function findLocalServer",
    "component_id": "scripts.test-icon-fallback.findLocalServer"
  },
  "scripts.test-icon-fallback.waitForServers": {
    "id": "scripts.test-icon-fallback.waitForServers",
    "name": "waitForServers",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-icon-fallback.js",
    "relative_path": "scripts/test-icon-fallback.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-icon-fallback.findLocalServer"
    ],
    "source_code": "async function waitForServers(maxRetries = 30) {\n    console.log('üîç Waiting for servers...');\n    \n    let localUrl = null;\n    \n    for (let i = 0; i < maxRetries; i++) {\n        // Check local server\n        if (!localUrl) {\n            localUrl = await findLocalServer();\n            if (localUrl) {\n                console.log(`‚úÖ Local dev server is ready at ${localUrl}`);\n                return { local: localUrl };\n            }\n        }\n        \n        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds\n    }\n    \n    throw new Error('‚ùå Servers not found within timeout');\n}",
    "start_line": 20,
    "end_line": 39,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function waitForServers",
    "component_id": "scripts.test-icon-fallback.waitForServers"
  },
  "scripts.test-icon-fallback.runTests": {
    "id": "scripts.test-icon-fallback.runTests",
    "name": "runTests",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-icon-fallback.js",
    "relative_path": "scripts/test-icon-fallback.js",
    "depends_on": [
      "scripts.test-icon-fallback.waitForServers",
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "async function runTests() {\n    const { local } = await waitForServers();\n    \n    console.log('üß™ Testing Icon Fallback System');\n    console.log('===============================\\n');\n    \n    let allTestsPassed = true;\n    \n    // Test local server\n    const serverUrl = local;\n    console.log(`\\nüåê Testing LOCAL server at ${serverUrl}`);\n    console.log('‚îÄ'.repeat(50));\n        \n        // Test 1: Verify missing icon scenario\n        console.log('1Ô∏è‚É£ Testing missing icon: gcp_cloud_trace');\n        \n        try {\n            const iconResponse = await fetch(`${serverUrl}/icons/gcp/gcp_cloud_trace.png`);\n            const contentType = iconResponse.headers.get('content-type') || '';\n            \n            if (contentType.includes('text/html')) {\n                console.log('   ‚úÖ Icon correctly detected as missing (HTML response)');\n            } else {\n                console.log('   ‚ùå Icon loading detection failed');\n                allTestsPassed = false;\n            }\n        } catch (error) {\n            console.log(`   ‚ùå Error testing icon URL: ${error.message}`);\n            allTestsPassed = false;\n        }\n        \n        // Test 2: Check fallback embedding availability\n        console.log('\\n2Ô∏è‚É£ Testing fallback embedding availability');\n        \n        try {\n            const embeddingsResponse = await fetch(`${serverUrl}/precomputed-icon-embeddings.json`);\n            const embeddings = await embeddingsResponse.json();\n            \n            const hasTraceEmbedding = embeddings.embeddings && embeddings.embeddings['trace'];\n            if (hasTraceEmbedding) {\n                console.log('   ‚úÖ Trace embedding available for fallback');\n            } else {\n                console.log('   ‚ùå Trace embedding missing');\n                allTestsPassed = false;\n            }\n        } catch (error) {\n            console.log(`   ‚ùå Error checking embeddings: ${error.message}`);\n            allTestsPassed = false;\n        }\n        \n        // Test 3: Test semantic search API\n        console.log('\\n3Ô∏è‚É£ Testing semantic search API');\n        \n        try {\n            const searchResponse = await fetch(`${serverUrl}/api/embed`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ text: 'cloud trace monitoring' })\n            });\n            \n            if (searchResponse.ok) {\n                const searchData = await searchResponse.json();\n                if (searchData.embedding && searchData.embedding.length > 0) {\n                    console.log('   ‚úÖ Semantic search API working');\n                } else {\n                    console.log('   ‚ùå Semantic search returned invalid data');\n                    allTestsPassed = false;\n                }\n            } else {\n                console.log(`   ‚ùå Semantic search API failed: ${searchResponse.status}`);\n                allTestsPassed = false;\n            }\n        } catch (error) {\n            console.log(`   ‚ùå Error with semantic search: ${error.message}`);\n            allTestsPassed = false;\n        }\n    \n    console.log('\\n===============================');\n    if (allTestsPassed) {\n        console.log('‚úÖ ALL ICON FALLBACK TESTS PASSED');\n        console.log('üéØ System ready: Missing icons will trigger semantic fallback');\n        return true;\n    } else {\n        console.log('‚ùå ICON FALLBACK TESTS FAILED');\n        console.log('üö® Fix required before pushing to production');\n        return false;\n    }\n}",
    "start_line": 41,
    "end_line": 128,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function runTests",
    "component_id": "scripts.test-icon-fallback.runTests"
  },
  "scripts.test-icon-fallback.main": {
    "id": "scripts.test-icon-fallback.main",
    "name": "main",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-icon-fallback.js",
    "relative_path": "scripts/test-icon-fallback.js",
    "depends_on": [
      "scripts.test-vercel-preview.error",
      "scripts.test-icon-fallback.runTests"
    ],
    "source_code": "async function main() {\n    try {\n        await runTests();\n    } catch (error) {\n        console.error(`üö® Icon fallback test failed: ${error.message}`);\n        process.exit(1);\n    }\n}",
    "start_line": 132,
    "end_line": 139,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function main",
    "component_id": "scripts.test-icon-fallback.main"
  },
  "scripts.test-multiple-terminals.TerminalSession": {
    "id": "scripts.test-multiple-terminals.TerminalSession",
    "name": "TerminalSession",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-multiple-terminals.js",
    "relative_path": "scripts/test-multiple-terminals.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "class TerminalSession {\n  constructor(id) {\n    this.id = id;\n    this.sessionId = `terminal-${id}-${Date.now()}`;\n    this.stats = {\n      requests: 0,\n      successful: 0,\n      failed: 0,\n      totalTime: 0\n    };\n  }\n\n  async makeRequest(payload, requestNum) {\n    const startTime = Date.now();\n    \n    try {\n      console.log(`üöÄ Terminal ${this.id}: Starting request ${requestNum} (${payload.name})`);\n      \n      const response = await fetch(`${SERVER_URL}/stream`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-session-id': `${this.sessionId}-req-${requestNum}`\n        },\n        body: JSON.stringify({\n          payload: payload.conversation,\n          isCompressed: false\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      // Read the stream until completion\n      const reader = response.body.getReader();\n      const decoder = new TextDecoder();\n      let messageCount = 0;\n      \n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        \n        const chunk = decoder.decode(value, { stream: true });\n        const lines = chunk.split('\\n').filter(line => line.startsWith('data: '));\n        \n        for (const line of lines) {\n          const data = line.slice(6);\n          if (data === '[DONE]') {\n            console.log(`‚úÖ Terminal ${this.id}: Request ${requestNum} completed (${messageCount} messages)`);\n            return;\n          }\n          messageCount++;\n        }\n      }\n\n      const duration = Date.now() - startTime;\n      this.stats.successful++;\n      this.stats.totalTime += duration;\n      \n      console.log(`‚úÖ Terminal ${this.id}: Request ${requestNum} completed in ${duration}ms`);\n      \n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.stats.failed++;\n      this.stats.totalTime += duration;\n      \n      console.error(`‚ùå Terminal ${this.id}: Request ${requestNum} failed after ${duration}ms:`, error.message);\n    } finally {\n      this.stats.requests++;\n    }\n  }\n\n  async runSequence() {\n    console.log(`üéØ Starting terminal ${this.id} with ${REQUESTS_PER_TERMINAL} requests`);\n    \n    for (let i = 1; i <= REQUESTS_PER_TERMINAL; i++) {\n      const payload = testPayloads[(this.id + i - 1) % testPayloads.length];\n      await this.makeRequest(payload, i);\n      \n      // Small delay between requests within the same terminal\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    console.log(`üèÅ Terminal ${this.id} completed:`, this.stats);\n    return this.stats;\n  }\n}",
    "start_line": 50,
    "end_line": 137,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class TerminalSession",
    "component_id": "scripts.test-multiple-terminals.TerminalSession"
  },
  "scripts.test-multiple-terminals.getConnectionStats": {
    "id": "scripts.test-multiple-terminals.getConnectionStats",
    "name": "getConnectionStats",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-multiple-terminals.js",
    "relative_path": "scripts/test-multiple-terminals.js",
    "depends_on": [
      "client.components.graph.utils.elk.edgePoints.warn"
    ],
    "source_code": "async function getConnectionStats() {\n  try {\n    const response = await fetch(`${SERVER_URL}/api/connection-stats`);\n    if (response.ok) {\n      return await response.json();\n    }\n  } catch (error) {\n    console.warn('Could not fetch connection stats:', error.message);\n  }\n  return null;\n}",
    "start_line": 140,
    "end_line": 150,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function getConnectionStats",
    "component_id": "scripts.test-multiple-terminals.getConnectionStats"
  },
  "scripts.test-multiple-terminals.runParallelTerminalTest": {
    "id": "scripts.test-multiple-terminals.runParallelTerminalTest",
    "name": "runParallelTerminalTest",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-multiple-terminals.js",
    "relative_path": "scripts/test-multiple-terminals.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-multiple-terminals.getConnectionStats"
    ],
    "source_code": "async function runParallelTerminalTest() {\n  console.log(`üß™ Starting concurrent terminal test`);\n  console.log(`üìä Configuration: ${NUM_CONCURRENT_TERMINALS} terminals √ó ${REQUESTS_PER_TERMINAL} requests each`);\n  console.log(`üåê Server: ${SERVER_URL}`);\n  console.log('');\n\n  // Check initial connection stats\n  const initialStats = await getConnectionStats();\n  if (initialStats) {\n    console.log('üìà Initial connection stats:', initialStats);\n  }\n  console.log('');\n\n  const startTime = Date.now();\n  \n  // Create terminal sessions\n  const terminals = Array.from({ length: NUM_CONCURRENT_TERMINALS }, (_, i) => new TerminalSession(i + 1));\n  \n  // Run all terminals in parallel\n  const results = await Promise.all(terminals.map(terminal => terminal.runSequence()));\n  \n  const totalTime = Date.now() - startTime;\n  \n  // Calculate overall statistics\n  const totalStats = results.reduce((acc, stats) => ({\n    requests: acc.requests + stats.requests,\n    successful: acc.successful + stats.successful,\n    failed: acc.failed + stats.failed,\n    totalTime: acc.totalTime + stats.totalTime\n  }), { requests: 0, successful: 0, failed: 0, totalTime: 0 });\n\n  // Get final connection stats\n  const finalStats = await getConnectionStats();\n  \n  console.log('');\n  console.log('üéØ TEST COMPLETED');\n  console.log('================');\n  console.log(`‚è±Ô∏è  Total test time: ${totalTime}ms`);\n  console.log(`üìä Total requests: ${totalStats.requests}`);\n  console.log(`‚úÖ Successful: ${totalStats.successful} (${(totalStats.successful / totalStats.requests * 100).toFixed(1)}%)`);\n  console.log(`‚ùå Failed: ${totalStats.failed} (${(totalStats.failed / totalStats.requests * 100).toFixed(1)}%)`);\n  console.log(`üìà Average request time: ${Math.round(totalStats.totalTime / totalStats.requests)}ms`);\n  console.log('');\n  \n  if (finalStats) {\n    console.log('üìà Final connection stats:');\n    console.log(`   Active connections: ${finalStats.activeConnections}`);\n    console.log(`   Queued requests: ${finalStats.queuedRequests}`);\n    console.log(`   Completed requests: ${finalStats.completedRequests}`);\n    console.log(`   Failed requests: ${finalStats.failedRequests}`);\n    console.log(`   Total timeouts: ${finalStats.totalTimeouts}`);\n  }\n\n  // Exit with appropriate code\n  process.exit(totalStats.failed > 0 ? 1 : 0);\n}",
    "start_line": 153,
    "end_line": 208,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function runParallelTerminalTest",
    "component_id": "scripts.test-multiple-terminals.runParallelTerminalTest"
  },
  "scripts.test-vercel-preview.log": {
    "id": "scripts.test-vercel-preview.log",
    "name": "log",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-vercel-preview.js",
    "relative_path": "scripts/test-vercel-preview.js",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "log = (color, message) => console.log(`${color}${message}${COLORS.reset}`)",
    "start_line": 22,
    "end_line": 22,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "color",
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function log",
    "component_id": "scripts.test-vercel-preview.log"
  },
  "scripts.test-vercel-preview.success": {
    "id": "scripts.test-vercel-preview.success",
    "name": "success",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-vercel-preview.js",
    "relative_path": "scripts/test-vercel-preview.js",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "success = (message) => log(COLORS.green, `‚úÖ ${message}`)",
    "start_line": 23,
    "end_line": 23,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function success",
    "component_id": "scripts.test-vercel-preview.success"
  },
  "scripts.test-vercel-preview.error": {
    "id": "scripts.test-vercel-preview.error",
    "name": "error",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-vercel-preview.js",
    "relative_path": "scripts/test-vercel-preview.js",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "error = (message) => log(COLORS.red, `‚ùå ${message}`)",
    "start_line": 24,
    "end_line": 24,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function error",
    "component_id": "scripts.test-vercel-preview.error"
  },
  "scripts.test-vercel-preview.info": {
    "id": "scripts.test-vercel-preview.info",
    "name": "info",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-vercel-preview.js",
    "relative_path": "scripts/test-vercel-preview.js",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "info = (message) => log(COLORS.blue, `‚ÑπÔ∏è  ${message}`)",
    "start_line": 25,
    "end_line": 25,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function info",
    "component_id": "scripts.test-vercel-preview.info"
  },
  "scripts.test-vercel-preview.warning": {
    "id": "scripts.test-vercel-preview.warning",
    "name": "warning",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-vercel-preview.js",
    "relative_path": "scripts/test-vercel-preview.js",
    "depends_on": [
      "scripts.test-vercel-preview.log"
    ],
    "source_code": "warning = (message) => log(COLORS.yellow, `‚ö†Ô∏è  ${message}`)",
    "start_line": 26,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function warning",
    "component_id": "scripts.test-vercel-preview.warning"
  },
  "scripts.test-vercel-preview.VercelPreviewTester": {
    "id": "scripts.test-vercel-preview.VercelPreviewTester",
    "name": "VercelPreviewTester",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/scripts/test-vercel-preview.js",
    "relative_path": "scripts/test-vercel-preview.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "scripts.test-vercel-preview.success",
      "scripts.test-vercel-preview.info",
      "scripts.test-vercel-preview.warning",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "class VercelPreviewTester {\n  constructor() {\n    this.previewUrl = null;\n    this.testResults = {\n      endToEnd: false,\n      fallbackMechanism: false,\n      apiHealth: false,\n      staticAssets: false\n    };\n  }\n\n  async getLatestPreviewUrl() {\n    try {\n      info('Getting latest Vercel preview URL...');\n      \n      // Get the latest deployment\n      const result = execSync('vercel ls', { \n        encoding: 'utf8',\n        cwd: process.cwd()\n      });\n      \n      const lines = result.split('\\n');\n      \n      // Look for the most recent preview deployment\n      let deploymentLine = null;\n      for (const line of lines) {\n        if (line.includes('atelier-') && (line.includes('Preview') || line.includes('Ready'))) {\n          deploymentLine = line;\n          break; // Take the first (most recent) one\n        }\n      }\n      \n      if (!deploymentLine) {\n        // Fallback: try to find any atelier deployment\n        deploymentLine = lines.find(line => line.includes('atelier-') && line.includes('shreyaspatel031s-projects.vercel.app'));\n      }\n      \n      if (!deploymentLine) {\n        throw new Error('No preview deployment found. Available deployments:\\n' + result);\n      }\n      \n      // Extract URL from the deployment line - more flexible regex\n      const urlMatch = deploymentLine.match(/https:\\/\\/atelier-[a-z0-9]+-shreyaspatel031s-projects\\.vercel\\.app/);\n      if (!urlMatch) {\n        // Try alternative extraction\n        const words = deploymentLine.split(/\\s+/);\n        const urlWord = words.find(word => word.includes('atelier-') && word.includes('.vercel.app'));\n        if (urlWord) {\n          this.previewUrl = urlWord.startsWith('https://') ? urlWord : `https://${urlWord}`;\n        } else {\n          throw new Error(`Could not extract preview URL from: ${deploymentLine}`);\n        }\n      } else {\n        this.previewUrl = urlMatch[0];\n      }\n      success(`Found preview URL: ${this.previewUrl}`);\n      return this.previewUrl;\n      \n    } catch (err) {\n      error(`Failed to get preview URL: ${err.message}`);\n      throw err;\n    }\n  }\n\n  async testApiHealth() {\n    info('Testing API health...');\n    \n    const endpoints = [\n      '/api/simple-agent',\n      '/api/embed',\n      '/api/generateChatName'\n    ];\n    \n    for (const endpoint of endpoints) {\n      try {\n        const response = await fetch(`${this.previewUrl}${endpoint}`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ message: 'health-check' }),\n          timeout: 30000\n        });\n        \n        if (response.status === 500) {\n          const text = await response.text();\n          if (text.includes('<!DOCTYPE') || text.includes('<html>')) {\n            error(`${endpoint}: Returning HTML instead of JSON (routing issue)`);\n            return false;\n          }\n        }\n        \n        if (response.ok || response.status === 400) { // 400 is OK for malformed requests\n          success(`${endpoint}: Healthy`);\n        } else {\n          error(`${endpoint}: Unhealthy (${response.status})`);\n          return false;\n        }\n        \n      } catch (err) {\n        error(`${endpoint}: Failed - ${err.message}`);\n        return false;\n      }\n    }\n    \n    this.testResults.apiHealth = true;\n    return true;\n  }\n\n  async testStaticAssets() {\n    info('Testing static assets...');\n    \n    const assets = [\n      '/precomputed-icon-embeddings.json'\n      // Note: No longer testing hardcoded fallback assets - semantic fallback handles missing icons\n    ];\n    \n    for (const asset of assets) {\n      try {\n        const response = await fetch(`${this.previewUrl}${asset}`, {\n          method: 'HEAD',\n          timeout: 10000\n        });\n        \n        if (response.ok) {\n          success(`Static asset available: ${asset}`);\n        } else {\n          error(`Static asset missing: ${asset} (${response.status})`);\n          if (asset.includes('precomputed-icon-embeddings.json')) {\n            return false; // This is critical for fallback mechanism\n          }\n        }\n        \n      } catch (err) {\n        error(`Static asset test failed for ${asset}: ${err.message}`);\n        if (asset.includes('precomputed-icon-embeddings.json')) {\n          return false;\n        }\n      }\n    }\n    \n    this.testResults.staticAssets = true;\n    return true;\n  }\n\n  async testEndToEndFlow() {\n    info('Testing end-to-end architecture generation...');\n    \n    try {\n      const response = await fetch(`${this.previewUrl}/api/simple-agent`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          message: 'Create a simple AWS web application architecture'\n        }),\n        timeout: 60000 // 60 second timeout for agent\n      });\n      \n      if (!response.ok) {\n        error(`End-to-end test failed: ${response.status}`);\n        const text = await response.text();\n        error(`Response: ${text.substring(0, 200)}...`);\n        return false;\n      }\n      \n      const result = await response.json();\n      \n      // Check if we got a valid architecture response\n      if (result.success && result.functionCalls && Array.isArray(result.functionCalls)) {\n        success('End-to-end flow: Architecture generation successful');\n        \n        // Verify we have function calls (which represent the architecture operations)\n        const functionCalls = result.functionCalls;\n        if (functionCalls.length > 0) {\n          // Count the add_node operations to see how many components were generated\n          const addNodeCalls = functionCalls.filter(call => \n            call.name === 'batch_update' && \n            call.arguments && \n            call.arguments.operations &&\n            call.arguments.operations.some(op => op.name === 'add_node')\n          );\n          \n          if (addNodeCalls.length > 0) {\n            const totalNodes = addNodeCalls.reduce((count, call) => {\n              return count + call.arguments.operations.filter(op => op.name === 'add_node').length;\n            }, 0);\n            \n            success(`Generated architecture with ${totalNodes} components`);\n            this.testResults.endToEnd = true;\n            return true;\n          } else {\n            error('Generated architecture has no components');\n            return false;\n          }\n        } else {\n          error('Generated architecture is empty');\n          return false;\n        }\n      } else if (result.success && result.data && result.data.graph) {\n        // Fallback for old response format\n        success('End-to-end flow: Architecture generation successful (legacy format)');\n        const graph = result.data.graph;\n        if (graph.children && graph.children.length > 0) {\n          success(`Generated architecture with ${graph.children.length} components`);\n          this.testResults.endToEnd = true;\n          return true;\n        } else {\n          error('Generated architecture is empty');\n          return false;\n        }\n      } else {\n        error('End-to-end test: Invalid response structure');\n        error(`Response keys: ${Object.keys(result).join(', ')}`);\n        error(`Response sample: ${JSON.stringify(result).substring(0, 300)}...`);\n        return false;\n      }\n      \n    } catch (err) {\n      error(`End-to-end test failed: ${err.message}`);\n      return false;\n    }\n  }\n\n  async testFallbackMechanism() {\n    info('Testing icon fallback mechanism...');\n    \n    try {\n      // Test that the embedding file is accessible\n      const embeddingResponse = await fetch(`${this.previewUrl}/precomputed-icon-embeddings.json`, {\n        timeout: 10000\n      });\n      \n      if (!embeddingResponse.ok) {\n        error('Fallback mechanism: Embedding file not accessible');\n        return false;\n      }\n      \n      const embeddings = await embeddingResponse.json();\n      \n      // Verify the embedding structure\n      if (!embeddings.embeddings || !embeddings.similarities) {\n        error('Fallback mechanism: Invalid embedding file structure');\n        return false;\n      }\n      \n      const embeddingCount = Object.keys(embeddings.embeddings).length;\n      const similarityCount = Object.keys(embeddings.similarities).length;\n      \n      if (embeddingCount === 0) {\n        error('Fallback mechanism: No embeddings found');\n        return false;\n      }\n      \n      success(`Fallback mechanism: ${embeddingCount} icon embeddings available`);\n      success(`Fallback mechanism: ${similarityCount} similarity mappings available`);\n      \n      // Test with a request that will likely trigger fallback\n      const fallbackTestResponse = await fetch(`${this.previewUrl}/api/simple-agent`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          message: 'Create an architecture with unusual-nonexistent-icon-name components'\n        }),\n        timeout: 60000\n      });\n      \n      if (fallbackTestResponse.ok) {\n        const result = await fallbackTestResponse.json();\n        if (result.success) {\n          success('Fallback mechanism: Successfully handled request with non-standard icons');\n          this.testResults.fallbackMechanism = true;\n          return true;\n        }\n      }\n      \n      // Even if the specific test fails, if embeddings are available, fallback should work\n      warning('Fallback mechanism: Specific test inconclusive, but embeddings are available');\n      this.testResults.fallbackMechanism = true;\n      return true;\n      \n    } catch (err) {\n      error(`Fallback mechanism test failed: ${err.message}`);\n      return false;\n    }\n  }\n\n  async runAllTests() {\n    console.log(`${COLORS.bold}${COLORS.blue}üß™ Vercel Preview Testing Suite${COLORS.reset}\\n`);\n    \n    try {\n      // Get the preview URL\n      await this.getLatestPreviewUrl();\n      \n      console.log('\\n' + '='.repeat(50));\n      console.log('üè• HEALTH CHECKS');\n      console.log('='.repeat(50));\n      \n      // Test API health\n      const apiHealthy = await this.testApiHealth();\n      \n      // Test static assets\n      const assetsHealthy = await this.testStaticAssets();\n      \n      if (!apiHealthy || !assetsHealthy) {\n        error('Basic health checks failed. Aborting further tests.');\n        return false;\n      }\n      \n      console.log('\\n' + '='.repeat(50));\n      console.log('üîÑ END-TO-END TESTING');\n      console.log('='.repeat(50));\n      \n      // Test end-to-end flow\n      const endToEndPassed = await this.testEndToEndFlow();\n      \n      console.log('\\n' + '='.repeat(50));\n      console.log('üîß FALLBACK MECHANISM TESTING');\n      console.log('='.repeat(50));\n      \n      // Test fallback mechanism\n      const fallbackPassed = await this.testFallbackMechanism();\n      \n      // Summary\n      console.log('\\n' + '='.repeat(50));\n      console.log('üìä TEST RESULTS SUMMARY');\n      console.log('='.repeat(50));\n      \n      const results = [\n        ['API Health', this.testResults.apiHealth],\n        ['Static Assets', this.testResults.staticAssets],\n        ['End-to-End Flow', this.testResults.endToEnd],\n        ['Fallback Mechanism', this.testResults.fallbackMechanism]\n      ];\n      \n      results.forEach(([test, passed]) => {\n        if (passed) {\n          success(`${test}: PASSED`);\n        } else {\n          error(`${test}: FAILED`);\n        }\n      });\n      \n      const allPassed = results.every(([, passed]) => passed);\n      \n      console.log('\\n' + '='.repeat(50));\n      if (allPassed) {\n        success('üéâ ALL TESTS PASSED - READY FOR PRODUCTION PROMOTION');\n        console.log(`${COLORS.green}${COLORS.bold}‚úÖ Preview URL: ${this.previewUrl}${COLORS.reset}`);\n        console.log(`${COLORS.green}This deployment can be safely promoted to production.${COLORS.reset}`);\n      } else {\n        error('‚ùå SOME TESTS FAILED - DO NOT PROMOTE TO PRODUCTION');\n        console.log(`${COLORS.red}Fix the failing tests before promoting to production.${COLORS.reset}`);\n      }\n      console.log('='.repeat(50));\n      \n      return allPassed;\n      \n    } catch (err) {\n      error(`Test suite failed: ${err.message}`);\n      return false;\n    }\n  }\n}",
    "start_line": 28,
    "end_line": 388,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class VercelPreviewTester",
    "component_id": "scripts.test-vercel-preview.VercelPreviewTester"
  },
  "server.connectionManager.ConnectionManager": {
    "id": "server.connectionManager.ConnectionManager",
    "name": "ConnectionManager",
    "component_type": "class",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/server/connectionManager.js",
    "relative_path": "server/connectionManager.js",
    "depends_on": [
      "scripts.test-vercel-preview.log",
      "client.components.graph.utils.elk.edgePoints.warn",
      "api.agentConfig.isReasoningModel",
      "client.components.graph.utils.elk.edgePoints.add",
      "scripts.test-vercel-preview.error"
    ],
    "source_code": "class ConnectionManager extends EventEmitter {\n  static instance;\n  \n  constructor() {\n    super();\n    this.clients = new Map();\n    this.requestQueue = [];\n    this.activeRequests = new Set();\n    this.isProcessingQueue = false;\n  \n  // Configuration\n    this.maxConcurrentRequests = timeoutConfigs.maxConcurrentRequests; // Limit concurrent OpenAI requests\n    this.maxClientInstances = 5;    // Pool multiple client instances\n    this.queueTimeout = timeoutConfigs.queueTimeout;     // Centralized timeout config\n    this.requestTimeout = timeoutConfigs.requestTimeout;   // Centralized timeout config\n    this.o3Timeout = timeoutConfigs.o3Timeout;        // Centralized timeout config\n    this.retryDelays = [1000, 2000, 4000]; // Exponential backoff\n\n    this.stats = {\n    activeConnections: 0,\n    queuedRequests: 0,\n    completedRequests: 0,\n    failedRequests: 0,\n    totalTimeouts: 0,\n    socketTimeouts: 0,\n    prematureCloses: 0\n  };\n\n    this.initializeClients();\n    this.startQueueProcessor();\n  }\n\n  static getInstance() {\n    if (!ConnectionManager.instance) {\n      ConnectionManager.instance = new ConnectionManager();\n    }\n    return ConnectionManager.instance;\n  }\n\n  initializeClients() {\n    // Create a pool of OpenAI clients with different configurations\n    for (let i = 0; i < this.maxClientInstances; i++) {\n      const clientId = `client-${i}`;\n      const client = new OpenAI({\n        apiKey: process.env.OPENAI_API_KEY,\n        maxRetries: 0, // We handle retries manually\n        timeout: this.o3Timeout, // Use longer timeout for O3 model\n      });\n      this.clients.set(clientId, client);\n    }\n    console.log(`üîß Initialized ${this.maxClientInstances} OpenAI client instances`);\n  }\n\n  getAvailableClient() {\n    // Round-robin client selection for load distribution\n    const clientIds = Array.from(this.clients.keys());\n    const clientId = clientIds[this.stats.completedRequests % clientIds.length];\n    return this.clients.get(clientId);\n  }\n\n  startQueueProcessor() {\n    setInterval(() => {\n      this.processQueue();\n    }, 100); // Check queue every 100ms\n  }\n\n  async processQueue() {\n    if (this.isProcessingQueue || this.requestQueue.length === 0) {\n      return;\n    }\n\n    if (this.activeRequests.size >= this.maxConcurrentRequests) {\n      return; // Wait for active requests to complete\n    }\n\n    this.isProcessingQueue = true;\n\n    try {\n      // Sort queue by priority and timestamp\n      this.requestQueue.sort((a, b) => {\n        const priorityOrder = { high: 0, normal: 1, low: 2 };\n        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n        return priorityDiff !== 0 ? priorityDiff : a.timestamp - b.timestamp;\n      });\n\n      // Process requests up to the concurrent limit\n      while (\n        this.requestQueue.length > 0 && \n        this.activeRequests.size < this.maxConcurrentRequests\n      ) {\n        const queuedRequest = this.requestQueue.shift();\n        \n        // Check if request has timed out in queue\n        if (Date.now() - queuedRequest.timestamp > this.queueTimeout) {\n          this.stats.failedRequests++;\n          this.stats.totalTimeouts++;\n          queuedRequest.reject(new Error('Request timed out in queue'));\n          continue;\n        }\n\n        this.executeRequest(queuedRequest);\n      }\n\n      this.updateStats();\n    } finally {\n      this.isProcessingQueue = false;\n    }\n  }\n\n  async executeRequest(queuedRequest) {\n    const { id, request, resolve, reject } = queuedRequest;\n    \n    this.activeRequests.add(id);\n    this.stats.activeConnections++;\n\n    try {\n      console.log(`üöÄ Executing request ${id} (${this.activeRequests.size}/${this.maxConcurrentRequests} active)`);\n      \n      // Execute with retry logic\n      const result = await this.executeWithRetry(request);\n      \n      this.stats.completedRequests++;\n      resolve(result);\n      \n      console.log(`‚úÖ Request ${id} completed successfully`);\n    } catch (error) {\n      this.stats.failedRequests++;\n      reject(error);\n      \n      console.error(`‚ùå Request ${id} failed:`, error.message);\n    } finally {\n      this.activeRequests.delete(id);\n      this.stats.activeConnections--;\n      this.emit('requestCompleted', { id, activeCount: this.activeRequests.size });\n    }\n  }\n\n  async executeWithRetry(request) {\n    let lastError;\n\n    for (let attempt = 0; attempt <= this.retryDelays.length; attempt++) {\n      try {\n        return await request();\n      } catch (error) {\n        lastError = error;\n        \n        // Don't retry on certain error types\n        if (error.status === 401 || error.status === 403) {\n          throw error; // Authentication errors shouldn't be retried\n        }\n\n        // Handle socket timeout and premature close errors\n        if (error.message && (error.message.includes('Socket timeout') || error.message.includes('Premature close'))) {\n          console.log(`üîç ConnectionManager: Connection Error Details:`, {\n            attempt: attempt + 1,\n            error: error.message,\n            type: 'connection_error',\n            timestamp: new Date().toISOString()\n          });\n          \n          // Update stats for specific error types\n          if (error.message.includes('Socket timeout')) {\n            this.stats.socketTimeouts++;\n          } else if (error.message.includes('Premature close')) {\n            this.stats.prematureCloses++;\n          }\n          \n          // These errors are often transient, so we should retry\n          if (attempt < this.retryDelays.length) {\n            console.log(`‚ö†Ô∏è Connection error detected, will retry...`);\n          }\n        }\n\n        // Enhanced logging for 404 errors\n        if (error.status === 404 && error.message.includes('not found')) {\n          console.log(`üîç ConnectionManager: 404 Error Details:`, {\n            attempt: attempt + 1,\n            status: error.status,\n            message: error.message,\n            type: error.type,\n            param: error.param,\n            code: error.code,\n            request_id: error.request_id,\n            timestamp: new Date().toISOString()\n          });\n        }\n\n        if (attempt < this.retryDelays.length) {\n          const delay = this.retryDelays[attempt];\n          console.warn(`‚ö†Ô∏è Request failed (attempt ${attempt + 1}), retrying in ${delay}ms:`, error.message);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  updateStats() {\n    this.stats.queuedRequests = this.requestQueue.length;\n    this.emit('statsUpdated', this.stats);\n  }\n\n  // Public API\n  async queueRequest(requestFn, priority = 'normal') {\n    return new Promise((resolve, reject) => {\n      const requestId = `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      \n      const queuedRequest = {\n        id: requestId,\n        request: requestFn,\n        resolve,\n        reject,\n        timestamp: Date.now(),\n        priority\n      };\n\n      this.requestQueue.push(queuedRequest);\n      console.log(`üì• Queued request ${requestId} with priority ${priority} (${this.requestQueue.length} in queue)`);\n      console.log(`üîç ConnectionManager: Current state:`, {\n        activeRequests: this.activeRequests.size,\n        queuedRequests: this.requestQueue.length,\n        completedRequests: this.stats.completedRequests,\n        failedRequests: this.stats.failedRequests,\n        totalClients: this.clients.size,\n        maxConcurrentRequests: this.maxConcurrentRequests\n      });\n      \n      this.processQueue(); // Trigger immediate processing attempt\n    });\n  }\n\n  async createStream(conversation, sessionId) {\n    const client = this.getAvailableClient();\n    \n    return this.queueRequest(async () => {\n      console.log(`üîÑ Creating OpenAI stream for session ${sessionId || 'unknown'}`);\n      \n      return client.responses.create({\n        model: modelConfigs.reasoning.model,\n        input: conversation,\n        tools: [], // No tools at this layer\n        tool_choice: \"auto\",\n        parallel_tool_calls: modelConfigs.reasoning.parallel_tool_calls,\n        ...(isReasoningModel(modelConfigs.reasoning.model) ? {\n          reasoning: modelConfigs.reasoning.reasoning\n        } : {}),\n        stream: modelConfigs.reasoning.stream\n      });\n    }, sessionId ? 'high' : 'normal');\n  }\n\n  async createChatCompletion(messages) {\n    const client = this.getAvailableClient();\n    \n    return this.queueRequest(async () => {\n      return client.chat.completions.create({\n        model: modelConfigs.reasoning.model,\n        messages: messages,\n        tools: [],\n        tool_choice: \"auto\",\n        temperature: modelConfigs.reasoning.temperature,\n        max_tokens: modelConfigs.reasoning.max_tokens\n      });\n    }, 'low');\n  }\n\n  getStats() {\n    return { ...this.stats };\n  }\n\n  // Cleanup method\n  shutdown() {\n    this.clients.clear();\n    this.requestQueue.forEach(req => req.reject(new Error('Connection manager shutdown')));\n    this.requestQueue = [];\n    this.activeRequests.clear();\n    this.removeAllListeners();\n  }\n}",
    "start_line": 5,
    "end_line": 284,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "EventEmitter"
    ],
    "class_name": null,
    "display_name": "class ConnectionManager",
    "component_id": "server.connectionManager.ConnectionManager"
  },
  "server.server.findAvailablePort": {
    "id": "server.server.findAvailablePort",
    "name": "findAvailablePort",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/server/server.js",
    "relative_path": "server/server.js",
    "depends_on": [
      "server.server.findAvailablePort",
      "client.realtime.RtcClient.close"
    ],
    "source_code": "async function findAvailablePort(startPort = 3000) {\n  return new Promise((resolve, reject) => {\n    const server = app.listen(startPort, () => {\n      const port = server.address().port;\n      server.close(() => {\n        resolve(port);\n      });\n    });\n    \n    server.on('error', (err) => {\n      if (err.code === 'EADDRINUSE') {\n        // Port is in use, try the next one\n        findAvailablePort(startPort + 1).then(resolve).catch(reject);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}",
    "start_line": 277,
    "end_line": 295,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "async function findAvailablePort",
    "component_id": "server.server.findAvailablePort"
  },
  "vite.config.defineConfig": {
    "id": "vite.config.defineConfig",
    "name": "defineConfig",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/vite.config.ts",
    "relative_path": "vite.config.ts",
    "depends_on": [
      "vite.config.defineConfig"
    ],
    "source_code": "export default defineConfig({\n  root: join(dirname(path), \"client\"),\n  plugins: [react()],\n  optimizeDeps: {\n    include: ['@excalidraw/excalidraw', 'roughjs'],\n  },\n  resolve: {\n    alias: {\n      'roughjs/bin/rough': 'roughjs/bin/rough.js',\n    },\n  },\n  define: {\n    'process.env': {\n      NODE_ENV: JSON.stringify(process.env.NODE_ENV),\n    },\n  },\n  ssr: {\n    noExternal: ['@excalidraw/excalidraw'],\n  },\n  build: {\n    target: 'esnext',\n    rollupOptions: {\n      external: [/\\.(test|spec)\\.(ts|tsx)$/],\n    },\n  },\n});",
    "start_line": 8,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "export_default_call",
    "base_classes": null,
    "class_name": null,
    "display_name": "export default defineConfig(...)",
    "component_id": "vite.config.defineConfig"
  },
  "vite.embeddable.config.defineConfig": {
    "id": "vite.embeddable.config.defineConfig",
    "name": "defineConfig",
    "component_type": "function",
    "file_path": "/Users/shreyaspatel/Desktop/Code/openai-realtime-console-edit-figjam/vite.embeddable.config.ts",
    "relative_path": "vite.embeddable.config.ts",
    "depends_on": [
      "vite.embeddable.config.defineConfig"
    ],
    "source_code": "export default defineConfig({\n  plugins: [react()],\n  define: {\n    'process.env': {},\n    'process.env.NODE_ENV': '\"production\"',\n    global: 'globalThis'\n  },\n  build: {\n    lib: {\n      entry: resolve(__dirname, 'client/components/FramerEmbeddable.tsx'),\n      name: 'ArchitectureGenerator',\n      fileName: (format) => `architecture-generator.${format}.js`,\n      formats: ['umd']\n    },\n    rollupOptions: {\n      external: ['react', 'react-dom', 'react-dom/client'],\n      output: {\n        globals: {\n          'react': 'React',\n          'react-dom': 'ReactDOM',\n          'react-dom/client': 'ReactDOM'\n        },\n        exports: 'named'\n      }\n    },\n    outDir: 'dist/embeddable'\n  },\n  resolve: {\n    alias: {\n      '@': resolve(__dirname, 'client')\n    }\n  }\n})",
    "start_line": 5,
    "end_line": 37,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "export_default_call",
    "base_classes": null,
    "class_name": null,
    "display_name": "export default defineConfig(...)",
    "component_id": "vite.embeddable.config.defineConfig"
  }
}