import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface ChatNameRequest {
  architecture?: any;           // ELK graph structure
  userPrompt?: string;         // Original user request
  nodeCount?: number;          // Number of nodes in architecture
  edgeCount?: number;          // Number of edges in architecture
  services?: string[];         // List of service names
}

export default async function handler(req: any, res: any) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method Not Allowed' });
  }

  const { architecture, userPrompt, nodeCount, edgeCount, services }: ChatNameRequest = req.body;

  if (!userPrompt || userPrompt.trim() === '') {
    return res.status(400).json({ error: 'User prompt is required for chat name generation' });
  }

  try {
    // Extract key information for naming
    const architectureInfo = extractArchitectureInfo(architecture);
    
    // Build context for AI naming
    const context = buildNamingContext({
      userPrompt,
      nodeCount,
      edgeCount,
      services: services || architectureInfo.services,
      platforms: architectureInfo.platforms,
      patterns: architectureInfo.patterns
    });

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { 
          role: "system", 
          content: "You are a technical architect who creates concise, professional names for chat sessions about cloud architectures. Generate ONE single name that captures the essence and purpose of the architecture. The name should be 2-4 words. Avoid generic terms like 'Chat', 'Session', 'URL', 'Web', 'Link', or 'Based'. Focus on the technical pattern, platform, or use case. IMPORTANT: Return ONLY the single name text without any quotes, brackets, numbering, or extra formatting. Just the plain name."
        },
        { 
          role: "user", 
          content: `Generate a chat name for this architecture discussion:\n\n${context}`
        }
      ],
      max_tokens: 15,
      temperature: 0.7,
    });

    const rawName = completion.choices[0].message.content?.trim() || '';
    console.log('Raw name from OpenAI:', JSON.stringify(rawName));
    // Clean the name: remove quotes, numbering, and take only the first line
    let generatedName = rawName.replace(/^["']+|["']+$/g, '').replace(/^["']+|["']+$/g, '');
    // If it's a numbered list, take only the first item
    if (generatedName.includes('\n')) {
      generatedName = generatedName.split('\n')[0];
    }
    // Remove numbering like "1. " or "2. "
    generatedName = generatedName.replace(/^\d+\.\s*/, '');
    console.log('Cleaned name:', JSON.stringify(generatedName));

    if (generatedName) {
      res.status(200).json({ 
        name: generatedName,
        context: context // For debugging
      });
    } else {
      throw new Error("No name generated by OpenAI.");
    }
  } catch (error) {
    console.error('Error generating chat name with OpenAI:', error);
    
    // NO FALLBACKS - throw the error so the frontend knows it failed
    throw error;
  }
}

/**
 * Extract useful information from ELK architecture for naming
 */
function extractArchitectureInfo(architecture: any) {
  const services: string[] = [];
  const platforms: string[] = [];
  const patterns: string[] = [];

  if (!architecture) {
    return { services, platforms, patterns };
  }

  // Recursively extract node information
  function extractFromNodes(nodes: any[]) {
    if (!Array.isArray(nodes)) return;
    
    for (const node of nodes) {
      if (node.id && node.data?.label) {
        const label = node.data.label.toLowerCase();
        const id = node.id.toLowerCase();
        
        // Platform detection
        if (label.includes('gcp') || id.includes('gcp')) platforms.push('GCP');
        if (label.includes('aws') || id.includes('aws')) platforms.push('AWS');
        if (label.includes('azure') || id.includes('azure')) platforms.push('Azure');
        if (label.includes('kubernetes') || id.includes('k8s') || id.includes('gke')) platforms.push('Kubernetes');
        
        // Service types
        if (id.includes('api') || label.includes('api')) patterns.push('API');
        if (id.includes('db') || id.includes('sql') || label.includes('database')) patterns.push('Database');
        if (id.includes('storage') || label.includes('storage')) patterns.push('Storage');
        if (id.includes('ml') || id.includes('ai') || label.includes('vertex')) patterns.push('AI/ML');
        if (id.includes('microservice') || label.includes('service')) patterns.push('Microservices');
        if (id.includes('serverless') || id.includes('function') || id.includes('lambda')) patterns.push('Serverless');
        
        // Extract service names
        services.push(node.data.label);
      }
      
      // Recurse into children
      if (node.children) {
        extractFromNodes(node.children);
      }
    }
  }

  extractFromNodes(architecture.children || []);
  
  return {
    services: [...new Set(services)].slice(0, 5), // Limit to 5 unique services
    platforms: [...new Set(platforms)],
    patterns: [...new Set(patterns)]
  };
}

/**
 * Build context string for OpenAI naming
 */
function buildNamingContext(data: {
  userPrompt?: string;
  nodeCount?: number;
  edgeCount?: number;
  services?: string[];
  platforms?: string[];
  patterns?: string[];
}) {
  const parts = [];
  
  if (data.userPrompt) {
    parts.push(`User request: "${data.userPrompt}"`);
  }
  
  if (data.platforms?.length) {
    parts.push(`Platforms: ${data.platforms.join(', ')}`);
  }
  
  if (data.patterns?.length) {
    parts.push(`Patterns: ${data.patterns.join(', ')}`);
  }
  
  if (data.nodeCount && data.edgeCount) {
    parts.push(`Architecture: ${data.nodeCount} components, ${data.edgeCount} connections`);
  }
  
  if (data.services?.length) {
    const topServices = data.services.slice(0, 3);
    parts.push(`Key services: ${topServices.join(', ')}`);
  }
  
  return parts.join('\n');
}

// REMOVED: generateFallbackChatName function - NO FALLBACKS ALLOWED EVER
